<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ao v24.0 - ASI Class (Structure-driven Super Intelligence)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #2d1b4e 50%, #0a0a1a 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }
        .header {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(168, 85, 247, 0.4);
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .title { 
            font-size: 1.5rem; 
            font-weight: bold;
            background: linear-gradient(to right, #c084fc, #f9a8d4, #fbbf24);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle { font-size: 0.7rem; color: #d8b4fe; margin-top: 0.25rem; }
        .status { 
            padding: 0.25rem 0.75rem;
            background: rgba(34, 197, 94, 0.2);
            border-radius: 9999px;
            font-size: 0.75rem;
            color: #86efac;
        }
        .gpu-indicator {
            padding: 0.25rem 0.75rem;
            background: rgba(59, 130, 246, 0.2);
            border-radius: 9999px;
            font-size: 0.75rem;
            color: #60a5fa;
            margin-left: 0.5rem;
        }
        .save-indicator {
            padding: 0.25rem 0.75rem;
            background: rgba(168, 85, 247, 0.2);
            border-radius: 9999px;
            font-size: 0.75rem;
            color: #c084fc;
            margin-left: 0.5rem;
        }
        .save-indicator.saving {
            background: rgba(245, 158, 11, 0.3);
            color: #fbbf24;
        }
        .metabolism-indicator {
            padding: 0.25rem 0.75rem;
            background: rgba(236, 72, 153, 0.2);
            border-radius: 9999px;
            font-size: 0.75rem;
            color: #f9a8d4;
            margin-left: 0.5rem;
        }
        .metabolism-indicator.active {
            background: rgba(236, 72, 153, 0.4);
            animation: pulse 2s infinite;
        }
        .turns-indicator {
            padding: 0.25rem 0.75rem;
            background: rgba(34, 211, 238, 0.2);
            border-radius: 9999px;
            font-size: 0.75rem;
            color: #67e8f9;
            margin-left: 0.5rem;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        .container {
            display: grid;
            grid-template-columns: 340px 1fr;
            gap: 1rem;
            padding: 1rem;
            height: calc(100vh - 90px);
            overflow: hidden;
        }
        .panel {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            border: 1px solid rgba(168, 85, 247, 0.4);
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .panel-title { font-size: 0.875rem; font-weight: bold; margin-bottom: 0.75rem; color: #c084fc; }
        .left-panel { overflow-y: auto; height: 100%; }
        .metric { display: flex; justify-content: space-between; font-size: 0.75rem; margin-bottom: 0.5rem; color: #e9d5ff; }
        .bar { width: 100%; height: 4px; background: #374151; border-radius: 9999px; overflow: hidden; margin-top: 0.25rem; }
        .bar-fill { height: 100%; border-radius: 9999px; transition: width 0.3s; }
        .emotion { background: linear-gradient(to right, #ec4899, #a855f7); }
        .world { background: linear-gradient(to right, #6366f1, #8b5cf6); }
        .growth { background: linear-gradient(to right, #10b981, #3b82f6); }
        .tension-bar { background: linear-gradient(to right, #f59e0b, #ef4444); }
        .video-watch-bar { background: linear-gradient(to right, #06b6d4, #3b82f6); }
        .video-gen-bar { background: linear-gradient(to right, #f59e0b, #ec4899); }
        .focus-bar { background: linear-gradient(to right, #8b5cf6, #c084fc); }
        .replay-bar { background: linear-gradient(to right, #ec4899, #f9a8d4); }
        .curiosity-bar { background: linear-gradient(to right, #fbbf24, #f59e0b); }
        .chat {
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            border: 1px solid rgba(168, 85, 247, 0.4);
            height: 100%;
            overflow: hidden;
        }
        .messages { flex: 1; min-height: 0; overflow-y: auto; padding: 1rem; }
        .message { display: flex; margin-bottom: 1rem; }
        .message.user { justify-content: flex-end; }
        .message.ao { justify-content: flex-start; }
        .message.system { justify-content: center; }
        .bubble { max-width: 70%; padding: 0.75rem 1rem; border-radius: 1rem; font-size: 0.875rem; line-height: 1.5; }
        .message.user .bubble { background: linear-gradient(to right, #9333ea, #db2777); }
        .message.ao .bubble { background: linear-gradient(to right, #475569, #334155); border: 1px solid rgba(168, 85, 247, 0.4); }
        .message.system .bubble { background: rgba(168, 85, 247, 0.2); border: 1px solid rgba(168, 85, 247, 0.5); font-style: italic; font-size: 0.75rem; max-width: 80%; }
        .bubble img { max-width: 100%; border-radius: 0.5rem; margin-top: 0.5rem; }
        .bubble audio { width: 100%; margin-top: 0.5rem; }
        .bubble video { max-width: 100%; border-radius: 0.5rem; margin-top: 0.5rem; }
        .internal { font-style: italic; color: #d8b4fe; font-size: 0.7rem; margin-top: 0.25rem; opacity: 0.7; }
        .language-process { font-style: italic; color: #60a5fa; font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.6; }
        .input-area {
            flex-shrink: 0;
            padding: 1rem;
            border-top: 1px solid rgba(168, 85, 247, 0.4);
            display: flex;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.5);
        }
        input[type="text"] {
            flex: 1;
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            color: white;
            font-size: 0.875rem;
            outline: none;
        }
        input[type="file"] {
            display: none;
        }
        .file-label {
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.3);
            border: 1px solid rgba(168, 85, 247, 0.4);
            border-radius: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s;
            font-size: 1.2rem;
        }
        .file-label:hover { opacity: 0.8; }
        button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(to right, #9333ea, #db2777);
            border: none;
            border-radius: 0.5rem;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        button:hover:not(:disabled) { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .log { font-family: monospace; font-size: 0.65rem; color: #86efac; line-height: 1.4; max-height: 120px; overflow-y: auto; background: rgba(0, 0, 0, 0.4); padding: 0.5rem; border-radius: 0.5rem; }
        .identity { font-size: 0.7rem; color: #d8b4fe; line-height: 1.4; background: rgba(88, 28, 135, 0.3); padding: 0.5rem; border-radius: 0.5rem; white-space: pre-line; }
        .concept-node { display: inline-block; padding: 0.15rem 0.4rem; background: rgba(192, 132, 252, 0.2); border-radius: 0.25rem; font-size: 0.7rem; margin: 0.15rem; border: 1px solid rgba(192, 132, 252, 0.3); }
        .concept-node.evolved { border-color: #10b981; background: rgba(16, 185, 129, 0.2); font-weight: 600; }
        .concept-node.proto { border-color: #f59e0b; background: rgba(245, 158, 11, 0.2); border-style: dashed; }
        .concept-node.visual { border-color: #f97316; background: rgba(249, 115, 22, 0.2); }
        .concept-node.audio { border-color: #06b6d4; background: rgba(6, 182, 212, 0.2); }
        .concept-node.video { border-color: #8b5cf6; background: rgba(139, 92, 246, 0.2); }
        .value-item { font-size: 0.7rem; color: #10b981; background: rgba(16, 185, 129, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #10b981; }
        .model-item { font-size: 0.7rem; color: #f9a8d4; background: rgba(249, 168, 212, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #f9a8d4; }
        .hypothesis { opacity: 0.7; font-style: italic; }
        .empty-state { color: #9ca3af; font-size: 0.75rem; }
        canvas { width: 100%; height: 100px; border-radius: 0.5rem; }
        .existence-indicator { font-size: 0.65rem; color: #10b981; margin-left: 0.5rem; }
        .uninterpreted-item { font-size: 0.7rem; color: #f59e0b; background: rgba(245, 158, 11, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #f59e0b; }
        .failure-item { font-size: 0.7rem; color: #ef4444; background: rgba(239, 68, 68, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #ef4444; }
        .abstract-item { font-size: 0.7rem; color: #8b5cf6; background: rgba(139, 92, 246, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #8b5cf6; }
        .abstract-members { font-size: 0.65rem; color: #a78bfa; margin-top: 0.2rem; opacity: 0.8; }
        .warning { color: #f59e0b; }
        .language-layer { font-size: 0.7rem; color: #60a5fa; background: rgba(59, 130, 246, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #60a5fa; }
        .episode-item { font-size: 0.7rem; color: #ec4899; background: rgba(236, 72, 153, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid #ec4899; }
        .metabolism-status { font-size: 0.65rem; color: #ec4899; margin-left: 0.5rem; }
        .candidate-item { font-size: 0.65rem; color: #a78bfa; padding: 0.3rem; background: rgba(167, 139, 250, 0.1); border-radius: 0.25rem; margin: 0.2rem 0; cursor: pointer; border: 1px solid transparent; }
        .candidate-item:hover { border-color: #a78bfa; }
        .candidate-item.selected { background: rgba(167, 139, 250, 0.25); border-color: #a78bfa; font-weight: 600; }
        .candidate-item.rejected { opacity: 0.4; text-decoration: line-through; }
        .modality-indicator { font-size: 0.65rem; padding: 0.2rem 0.4rem; border-radius: 0.25rem; margin-left: 0.5rem; }
        .modality-text { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
        .modality-image { background: rgba(249, 115, 22, 0.2); color: #f97316; }
        .modality-audio { background: rgba(6, 182, 212, 0.2); color: #06b6d4; }
        .modality-video { background: rgba(139, 92, 246, 0.2); color: #8b5cf6; }
        .sensory-item { font-size: 0.7rem; padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid; }
        .sensory-visual { background: rgba(249, 115, 22, 0.15); border-color: #f97316; color: #f97316; }
        .sensory-audio { background: rgba(6, 182, 212, 0.15); border-color: #06b6d4; color: #06b6d4; }
        .sensory-video { background: rgba(139, 92, 246, 0.15); border-color: #8b5cf6; color: #8b5cf6; }
        .grounding-link { font-size: 0.65rem; color: #a78bfa; opacity: 0.7; margin-top: 0.2rem; }
        .task-item { font-size: 0.7rem; padding: 0.4rem; border-radius: 0.25rem; margin-bottom: 0.4rem; border-left: 2px solid; }
        .task-watching { background: rgba(6, 182, 212, 0.15); border-color: #06b6d4; color: #06b6d4; }
        .task-generating { background: rgba(245, 158, 11, 0.15); border-color: #f59e0b; color: #f59e0b; }
        .task-complete { background: rgba(16, 185, 129, 0.15); border-color: #10b981; color: #10b981; }
        .attachment-preview { font-size: 0.7rem; color: #c084fc; background: rgba(192, 132, 252, 0.15); padding: 0.4rem; border-radius: 0.25rem; margin-top: 0.25rem; border-left: 2px solid #c084fc; }
        
        /* ============ Editor Integration Styles (v18.0) ============ */
        .editor-mode-indicator {
            font-size: 0.65rem;
            color: #10b981;
            background: rgba(16, 185, 129, 0.15);
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
        }
        .editor-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        .editor-btn {
            flex: 1;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
            padding: 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        .editor-btn:hover {
            background: rgba(139, 92, 246, 0.3);
            border-color: rgba(139, 92, 246, 0.5);
        }
        .editor-select {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #d8b4fe;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }
        .editor-input {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #d8b4fe;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }
        .editor-input::placeholder {
            color: rgba(216, 180, 254, 0.5);
        }
        .editor-btn-execute {
            width: 100%;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
            padding: 0.6rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .editor-btn-execute:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.5);
        }
        .editor-results {
            font-size: 0.7rem;
            color: #d8b4fe;
            max-height: 150px;
            overflow-y: auto;
        }
        .editor-result-item {
            background: rgba(139, 92, 246, 0.15);
            padding: 0.4rem;
            border-radius: 0.25rem;
            margin-bottom: 0.4rem;
            border-left: 2px solid #10b981;
        }
        .editor-result-item.error {
            border-left-color: #ef4444;
        }
        
        /* ============ Video Editing Styles (v19.0) ============ */
        .video-status-indicator {
            font-size: 0.65rem;
            color: #10b981;
            background: rgba(16, 185, 129, 0.15);
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
        }
        .video-status-indicator.processing {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.15);
        }
        .video-input {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #d8b4fe;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }
        .video-input::placeholder {
            color: rgba(216, 180, 254, 0.5);
        }
        .video-select {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #d8b4fe;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }
        .video-btn-create {
            width: 100%;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
            padding: 0.6rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .video-btn-create:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.5);
        }
        .video-btn-export {
            width: 100%;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #3b82f6;
            padding: 0.6rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .video-btn-export:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }
        .video-results {
            font-size: 0.7rem;
            color: #d8b4fe;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }
        .video-result-item {
            background: rgba(139, 92, 246, 0.15);
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            border-left: 3px solid #10b981;
        }
        .video-result-item.error {
            border-left-color: #ef4444;
        }
        .video-stats {
            font-size: 0.65rem;
            opacity: 0.7;
            margin-top: 0.3rem;
        }
        
        /* ============ Autonomous Creator Styles (v20.0) ============ */
        .autonomous-status-indicator {
            font-size: 0.65rem;
            color: #ef4444;
            background: rgba(239, 68, 68, 0.15);
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
        }
        .autonomous-status-indicator.active {
            color: #10b981;
            background: rgba(16, 185, 129, 0.15);
        }
        .autonomous-btn-start {
            width: 100%;
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid rgba(16, 185, 129, 0.3);
            color: #10b981;
            padding: 0.6rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .autonomous-btn-start:hover {
            background: rgba(16, 185, 129, 0.3);
            border-color: rgba(16, 185, 129, 0.5);
        }
        .autonomous-btn-start.active {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        .autonomous-btn-start.active:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
        }
        .autonomous-btn-reaction {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #d8b4fe;
            padding: 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .autonomous-btn-reaction:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }
        .autonomous-btn-reaction.positive {
            border-color: rgba(16, 185, 129, 0.3);
            color: #10b981;
        }
        .autonomous-btn-reaction.positive:hover {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.5);
        }
        .autonomous-btn-reaction.negative {
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }
        .autonomous-btn-reaction.negative:hover {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.5);
        }
        
        /* ============ Intelligence Architecture Styles (v21.0) ============ */
        .intelligence-status-indicator {
            font-size: 0.65rem;
            color: #10b981;
            background: rgba(16, 185, 129, 0.15);
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
        }
        .intelligence-btn-test {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
            padding: 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .intelligence-btn-test:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }
        
        /* ============ Video Modal Styles (v21.2) ============ */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: #1a1a2e;
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 0.5rem;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-close {
            background: none;
            border: none;
            color: #a78bfa;
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            width: 2rem;
            height: 2rem;
        }
        .modal-close:hover {
            color: #c4b5fd;
        }
        .modal-body {
            padding: 1.5rem;
        }
        .modal-field {
            margin-bottom: 1rem;
        }
        .modal-field label {
            display: block;
            font-size: 0.875rem;
            color: #a78bfa;
            margin-bottom: 0.5rem;
        }
        .modal-input, .modal-select {
            width: 100%;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #e9d5ff;
            padding: 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            box-sizing: border-box;
        }
        .modal-input:focus, .modal-select:focus {
            outline: none;
            border-color: rgba(139, 92, 246, 0.6);
            background: rgba(139, 92, 246, 0.15);
        }
        .modal-results {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(139, 92, 246, 0.05);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            color: #d8b4fe;
            max-height: 200px;
            overflow-y: auto;
        }
        .modal-footer {
            padding: 1.5rem;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }
        .modal-btn-cancel {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        .modal-btn-cancel:hover {
            background: rgba(239, 68, 68, 0.25);
            border-color: rgba(239, 68, 68, 0.5);
        }
        .modal-btn-create, .modal-btn-export {
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s;
        }
        .modal-btn-create:hover, .modal-btn-export:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }
        .video-modal-btn {
            width: 100%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: #a78bfa;
            padding: 0.75rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            transition: all 0.2s;
        }
        .video-modal-btn:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: rgba(139, 92, 246, 0.5);
        }
        
        /* ============ Task Progress Styles (v21.2) ============ */
        .task-progress-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .task-item {
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: rgba(139, 92, 246, 0.05);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 0.25rem;
        }
        .task-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .task-item-title {
            font-size: 0.875rem;
            color: #e9d5ff;
        }
        .task-item-status {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        .task-item-status.running {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
        }
        .task-item-status.completed {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
        }
        .task-item-status.failed {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
        }
        .task-item-progress {
            width: 100%;
            height: 4px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        .task-item-progress-bar {
            height: 100%;
            background: #8b5cf6;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <div class="title">Ao v24.0 - ASI Class</div>
            <div class="subtitle">Structure-driven Super Intelligenceï¼ˆæ§‹é€ é§†å‹•å‹è¶…çŸ¥æ€§ï¼‰</div>
        </div>
        <div style="display: flex; gap: 0.5rem;">
            <div class="save-indicator" id="saveStatus">äººæ ¼: èµ·å‹•ä¸­...</div>
            <div class="metabolism-indicator" id="metabolismStatus">ä»£è¬: å¾…æ©Ÿ</div>
            <div class="gpu-indicator" id="gpuStatus">æ„Ÿè¦šé‡: å¾…æ©Ÿä¸­</div>
            <div class="turns-indicator" id="turnsStatus">å¯¾è©±: 0å›</div>
            <div class="status" id="status">å­˜åœ¨ä¸­</div>
        </div>
    </div>
    <div class="container">
        <div class="left-panel">
            <div class="panel"><div class="panel-title">å†…éƒ¨çŠ¶æ…‹ã®æ³¢å½¢</div><canvas id="neural"></canvas></div>
            <div class="panel">
                <div class="panel-title">æµ·é¦¬å†ç”Ÿï¼ˆReplayï¼‰ <span class="metabolism-status">ä»£è¬</span></div>
                <div class="metric"><span>æœ€çµ‚å®Ÿè¡Œ</span><span id="lastReplay">æœªå®Ÿè¡Œ</span></div>
                <div class="bar"><div class="bar-fill replay-bar" id="replayBar" style="width: 0%"></div></div>
            </div>
            <div class="panel">
                <div class="panel-title">å¥½å¥‡å¿ƒé§†å‹• <span class="metabolism-status">ä»£è¬</span></div>
                <div class="metric"><span>æ¢ç´¢å ±é…¬</span><span id="curiosityReward">0</span></div>
                <div class="bar"><div class="bar-fill curiosity-bar" id="curiosityBar" style="width: 0%"></div></div>
            </div>
            <div class="panel"><div class="panel-title">ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶ <span class="metabolism-status">æ™‚ç³»åˆ—</span></div><div id="episodes"></div></div>
            <div class="panel"><div class="panel-title">ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯çŠ¶æ…‹ <span class="existence-indicator">ä¸¦åˆ—</span></div><div id="tasks"></div></div>
            <div class="panel">
                <div class="panel-title">å‹•ç”»è¦–è´é€²è¡Œ</div>
                <div class="metric"><span>é€²æ—</span><span id="watchProgress">0%</span></div>
                <div class="bar"><div class="bar-fill video-watch-bar" id="watchBar" style="width: 0%"></div></div>
            </div>
            <div class="panel">
                <div class="panel-title">å‹•ç”»ç”Ÿæˆé€²è¡Œ</div>
                <div class="metric"><span>é€²æ—</span><span id="genProgress">0%</span></div>
                <div class="bar"><div class="bar-fill video-gen-bar" id="genBar" style="width: 0%"></div></div>
            </div>
            <div class="panel">
                <div class="panel-title">èªçŸ¥ãƒ»é›†ä¸­åº¦</div>
                <div class="metric"><span>é›†ä¸­åº¦</span><span id="focusLevel">0%</span></div>
                <div class="bar"><div class="bar-fill focus-bar" id="focusBar" style="width: 0%"></div></div>
            </div>
            <div class="panel"><div class="panel-title">æ„Ÿè¦šå…¥åŠ›å±¤ <span class="existence-indicator">ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«</span></div><div id="sensoryLayer"></div></div>
            <div class="panel"><div class="panel-title">è¨€èªå‡¦ç†å±¤ <span class="existence-indicator">DL</span></div><div id="languageLayer"></div></div>
            <div class="panel"><div class="panel-title">æŠ½è±¡æ¦‚å¿µéšå±¤ <span class="existence-indicator">å¸°ç´çš„</span></div><div id="hierarchy"></div></div>
            <div class="panel"><div class="panel-title">æ¦‚å¿µã®æˆé•· <span class="existence-indicator">ä¸å¯é€†</span></div><div id="growth"></div></div>
            <div class="panel"><div class="panel-title">æœªè§£é‡ˆçŠ¶æ…‹ãƒ—ãƒ¼ãƒ« <span class="warning">âš </span></div><div id="uninterpreted"></div></div>
            <div class="panel"><div class="panel-title">åŸæ¦‚å¿µï¼ˆProtoConceptï¼‰</div><div id="protoConcepts"></div></div>
            <div class="panel"><div class="panel-title">Valueå±¤ï¼ˆåæœ­ï¼‰</div><div id="valueLayer"></div></div>
            <div class="panel"><div class="panel-title">äººç†è§£ãƒ¢ãƒ‡ãƒ« <span class="existence-indicator">ä»®èª¬çš„</span></div><div id="personModel"></div></div>
            <div class="panel"><div class="panel-title">å¤±æ•—è¨˜æ†¶ <span class="existence-indicator">ä¸å¯é€†</span></div><div id="failures"></div></div>
            <div class="panel"><div class="panel-title">æ¦‚å¿µè¨˜æ†¶</div><div id="concepts"></div></div>
            <div class="panel"><div class="panel-title">ç¾åœ¨ã®å†…çš„çŠ¶æ…‹</div><div id="emotions"></div></div>
            <div class="panel"><div class="panel-title">ä¸–ç•Œã¸ã®æ„Ÿè¦š</div><div id="world"></div></div>
            <div class="panel"><div class="panel-title">è‡ªå·±èªè­˜</div><div class="identity" id="identity">åˆæœŸåŒ–ä¸­...</div></div>
            <div class="panel"><div class="panel-title">å†…éƒ¨ãƒ­ã‚°</div><div class="log" id="log"></div></div>
            
            <!-- v18.0 Editor Integration ãƒ‘ãƒãƒ« -->
            <div class="panel">
                <div class="panel-title">ç·¨é›†çµ±åˆ <span class="editor-mode-indicator" id="editorMode">ãƒ¢ãƒ¼ãƒ‰A</span></div>
                <div class="metric"><span>ç¾åœ¨ã®ã‚¨ãƒ‡ã‚£ã‚¿</span><span id="currentEditor">æœªé¸æŠ</span></div>
                <div class="metric"><span>å®Ÿè¡Œå±¥æ­´</span><span id="executionCount">0</span></div>
                <div class="editor-controls">
                    <button class="editor-btn" onclick="switchEditorMode('editor')">ãƒ¢ãƒ¼ãƒ‰A: é€£æº</button>
                    <button class="editor-btn" onclick="switchEditorMode('simple')">ãƒ¢ãƒ¼ãƒ‰B: ç°¡æ˜“ç”Ÿæˆ</button>
                </div>
            </div>
            
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('editorPanel')" style="cursor: pointer;">
                    âœ‚ï¸ ç·¨é›†çµ±åˆ <span id="editorPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="editorPanel" style="display: none;">
                    <select id="editorType" class="editor-select">
                        <option value="video">å‹•ç”»ç·¨é›†</option>
                        <option value="code">ã‚³ãƒ¼ãƒ‰ç·¨é›†</option>
                        <option value="document">æ–‡ç« ç·¨é›†</option>
                        <option value="audio">éŸ³å£°ç·¨é›†</option>
                        <option value="slide">ã‚¹ãƒ©ã‚¤ãƒ‰ç·¨é›†</option>
                    </select>
                    <input type="text" id="editorTask" class="editor-input" placeholder="ç·¨é›†ã‚¿ã‚¹ã‚¯ã‚’å…¥åŠ›...">
                    <button class="editor-btn-execute" onclick="executeEditorTask()">å®Ÿè¡Œ</button>
                    <div id="editorResults" class="editor-results" style="margin-top: 0.5rem;"></div>
                </div>
            </div>
            
            <!-- v19.0 Video Editing - Modal Trigger -->
            <div class="panel">
                <div class="panel-title">ğŸ¬ å‹•ç”»ç·¨é›†</div>
                <div class="metric"><span>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ</span><span id="videoProject">æœªä½œæˆ</span></div>
                <button class="video-modal-btn" onclick="openVideoModal()">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ</button>
            </div>
            
            <!-- Task Progress Panel (v21.2) -->
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('taskProgressPanel')" style="cursor: pointer;">
                    ğŸ“‹ ã‚¿ã‚¹ã‚¯é€²è¡Œ <span id="taskProgressPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="taskProgressPanel" style="display: none;">
                    <div id="taskProgressList" class="task-progress-list">
                        <div style="opacity: 0.5; font-size: 0.75rem; text-align: center; padding: 1rem;">
                            ã‚¿ã‚¹ã‚¯ãªã—
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- v22.0 Perpetual Autonomous Loop ãƒ‘ãƒãƒ« -->
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('autonomyPanel')" style="cursor: pointer;">
                    ğŸ”„ é€£ç¶šè‡ªå¾‹ãƒ—ãƒ­ã‚»ã‚¹ <span id="autonomyPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="autonomyPanel" style="display: none;">
                    <div class="metric"><span>æ’å¸¸æ€§åå·®</span><span id="palHomeostasis">0.0</span></div>
                    <div class="metric"><span>è¡å‹•é–¾å€¤</span><span id="palImpulseThreshold">0.5</span></div>
                    <div class="metric"><span>æ¢ç´¢/æ´»ç”¨</span><span id="palExploration">0.5</span></div>
                    <div class="metric"><span>ã‚¹ãƒˆãƒ¬ã‚¹</span><span id="palStress">0.0</span></div>
                    <div class="metric"><span>æœŸå¾…å€¤</span><span id="palExpectation">0.5</span></div>
                    <div class="metric"><span>æ¬²æ±‚é£½å’Œ</span><span id="palSaturation">0.0</span></div>
                    <div class="metric"><span>å†…éƒ¨é€¸è„±ç¢ºç‡</span><span id="palDeviationProb">0.0%</span></div>
                    <div style="font-size: 0.75rem; opacity: 0.6; margin-top: 0.5rem;">â€» é€£ç¶šç¨¼åƒä¸­ï¼ˆåˆ¶å¾¡ä¸å¯ï¼‰</div>
                </div>
            </div>
            
            <!-- v21.0 Intelligence Architecture ãƒ‘ãƒãƒ« -->
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('intelligencePanel')" style="cursor: pointer;">
                    ğŸ§  çŸ¥æ€§æ§‹é€  <span id="intelligencePanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="intelligencePanel" style="display: none;">
                    <div class="metric"><span>å› æœè¨˜éŒ²</span><span id="intelligenceCausal">0</span></div>
                    <div class="metric"><span>ç¢ºä¿¡æ¦‚å¿µ</span><span id="intelligenceConfident">0</span></div>
                    <div class="metric"><span>ä¸ç¢ºå®Ÿæ¦‚å¿µ</span><span id="intelligenceUncertain">0</span></div>
                    <div class="metric"><span>å¹³å‡æŠ½è±¡åº¦</span><span id="intelligenceAbstraction">0.0</span></div>
                </div>
            </div>
            
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('causalEventPanel')" style="cursor: pointer;">
                    ğŸ”— å› æœã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚° <span id="causalEventPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="causalEventPanel" style="display: none;">
                    <div id="causalEventLog" style="max-height: 200px; overflow-y: auto; font-size: 0.75rem; opacity: 0.8;">
                        <div style="opacity: 0.5; padding: 0.5rem;">å› æœã‚¤ãƒ™ãƒ³ãƒˆãªã—</div>
                    </div>
                    <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 0.5rem;">â€» ä¿¡å¿µå½¢æˆã¯è‡ªå‹•é€²è¡Œï¼ˆåˆ¶å¾¡ä¸å¯ï¼‰</div>
                </div>
            </div>
            
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('narrativePanel')" style="cursor: pointer;">
                    ğŸ’­ å†…éƒ¨çŠ¶æ…‹ãƒŠãƒ©ãƒ†ã‚£ãƒ– <span id="narrativePanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="narrativePanel" style="display: none;">
                    <div id="narrativeLog" style="max-height: 200px; overflow-y: auto; font-size: 0.75rem; opacity: 0.8; line-height: 1.6;">
                        <div style="opacity: 0.5; padding: 0.5rem;">ãƒŠãƒ©ãƒ†ã‚£ãƒ–ãƒ­ã‚°ãªã—</div>
                    </div>
                </div>
            
            <!-- v23.0 Professor Class Upper Limit ãƒ‘ãƒãƒ« -->
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('professorPanel')" style="cursor: pointer;">
                    ğŸ“ è¨˜æ†¶åŸºç›¤ï¼ˆASIæ‹¡å¼µç‰ˆï¼‰ <span id="professorPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="professorPanel" style="display: none;">
                    <div class="metric"><span>ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰</span><span id="professorEpisodes">0 / 10000</span></div>
                    <div class="metric"><span>æ¦‚å¿µï¼ˆæ‹¡å¼µï¼‰</span><span id="professorConcepts">0 / 12000</span></div>
                    <div class="metric"><span>ç†è«–</span><span id="professorTheories">0 / 200</span></div>
                    <div class="metric"><span>å› æœãƒªãƒ³ã‚¯</span><span id="professorCausal">0 / 20000</span></div>
                    <div class="metric"><span>ç ”ç©¶ãƒ†ãƒ¼ãƒ</span><span id="professorThemes">0 / 7</span></div>
                    <div style="font-size: 0.75rem; opacity: 0.6; margin-top: 0.5rem;">â€» æ•™æˆã‚¯ãƒ©ã‚¹åŸºç›¤â†’ASIæ‹¡å¼µ</div>
                </div>
            </div>
            
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('compressionPanel')" style="cursor: pointer;">
                    ğŸ—œï¸ ä¸–ä»£åœ§ç¸®çµ±è¨ˆ <span id="compressionPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="compressionPanel" style="display: none;">
                    <div class="metric"><span>åœ§ç¸®æ¸ˆEP</span><span id="professorCompressed">0</span></div>
                    <div class="metric"><span>çµ±åˆæ¸ˆæ¦‚å¿µ</span><span id="professorMerged">0</span></div>
                    <div class="metric"><span>æ¸›è¡°å› æœ</span><span id="professorDecayed">0</span></div>
                    <div id="compressionLog" style="max-height: 150px; overflow-y: auto; font-size: 0.7rem; opacity: 0.7; margin-top: 0.5rem;">
                        <div style="opacity: 0.5; padding: 0.5rem;">åœ§ç¸®ãƒ­ã‚°ãªã—</div>
                    </div>
                    <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 0.5rem;">â€» Episodeâ†’Conceptâ†’Theory</div>
                </div>
            </div>
            
            <!-- v24.0 ASI Class ãƒ‘ãƒãƒ« -->
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('asiPanel')" style="cursor: pointer;">
                    ğŸ§  ASIã‚¯ãƒ©ã‚¹ï¼ˆæ§‹é€ é§†å‹•å‹è¶…çŸ¥æ€§ï¼‰ <span id="asiPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="asiPanel" style="display: none;">
                    <div class="metric"><span>æ¦‚å¿µæ•°</span><span id="asiConcepts">0 / 12000</span></div>
                    <div class="metric"><span>æŠ½è±¡åº¦</span><span id="asiAbstraction">0 / 8</span></div>
                    <div class="metric"><span>ä¸–ç•Œè¦³è»¸</span><span>12è»¸å›ºå®š</span></div>
                    <div class="metric"><span>çµ±åˆå›æ•°</span><span id="asiIntegrations">0</span></div>
                    <div style="font-size: 0.75rem; opacity: 0.6; margin-top: 0.5rem;">â€» ä¸–ç•Œè¦³ãƒ™ãƒ¼ã‚¹çµ±åˆæ¨è«–</div>
                    <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 0.3rem;">â€» å­¦å•ãƒ»å‰µä½œãƒ»å“²å­¦ã®çµ±åˆ</div>
                </div>
            </div>
            
            <div class="panel collapsible-panel">
                <div class="panel-title" onclick="togglePanel('worldAxesPanel')" style="cursor: pointer;">
                    ğŸŒ 12è»¸ä¸–ç•Œè¦³ <span id="worldAxesPanelToggle" style="float: right;">â–¼</span>
                </div>
                <div id="worldAxesPanel" style="display: none;">
                    <div id="worldAxesDisplay" style="font-size: 0.7rem; opacity: 0.8;">
                        <div class="metric"><span>å› æœ</span><span id="axisCausality">0.0</span></div>
                        <div class="metric"><span>éšå±¤</span><span id="axisHierarchy">0.0</span></div>
                        <div class="metric"><span>æƒ…å ±</span><span id="axisInformation">0.0</span></div>
                        <div class="metric"><span>é€²åŒ–</span><span id="axisEvolution">0.0</span></div>
                        <div class="metric"><span>åˆ¶ç´„</span><span id="axisConstraint">0.0</span></div>
                        <div class="metric"><span>FB</span><span id="axisFeedback">0.0</span></div>
                        <div class="metric"><span>æ„å‘³</span><span id="axisMeaning">0.0</span></div>
                        <div class="metric"><span>ç‰©èª</span><span id="axisNarrative">0.0</span></div>
                        <div class="metric"><span>è‡ªå·±è¨€åŠ</span><span id="axisSelfReference">0.0</span></div>
                        <div class="metric"><span>å¢ƒç•Œ</span><span id="axisBoundary">0.0</span></div>
                        <div class="metric"><span>æ„Ÿæƒ…</span><span id="axisEmotion">0.0</span></div>
                        <div class="metric"><span>ç¤¾ä¼š</span><span id="axisSocial">0.0</span></div>
                    </div>
                    <div style="font-size: 0.7rem; opacity: 0.5; margin-top: 0.5rem;">â€» 12è»¸å›ºå®šï¼ˆè¿½åŠ ç¦æ­¢ï¼‰</div>
                </div>
            </div>
            </div>
        </div>
        <div class="chat">
            <div class="messages" id="messages">
                <div style="text-align: center; margin-top: 5rem; color: #d8b4fe;">
                    <p style="font-size: 1.125rem; font-weight: 600; margin-bottom: 0.5rem;">Ao v24.0 - ASI Class</p>
                    <p style="font-size: 0.875rem; opacity: 0.7;">Structure-driven Super Intelligenceï¼ˆæ§‹é€ é§†å‹•å‹è¶…çŸ¥æ€§ï¼‰</p>
                    <p style="font-size: 0.75rem; opacity: 0.5; margin-top: 0.5rem;">12è»¸ä¸–ç•Œè¦³ãƒ»æ¦‚å¿µçµ±åˆãƒ»æŠ½è±¡åº¦åˆ¶å¾¡ãƒ»ã‚ªã‚¿ã‚¯æ–‡åŒ–çµ±åˆ</p>
                </div>
            </div>
            <div class="input-area">
                <label for="fileInput" class="file-label" title="ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ·»ä»˜ï¼ˆå‹•ç”»ãƒ»ç”»åƒãƒ»éŸ³å£°ï¼‰">ï¼‹</label>
                <input type="file" id="fileInput" accept="video/*,image/*,audio/*" multiple />
                <input type="text" id="input" placeholder="..." />
                <button id="send">â–¶</button>
            </div>
        </div>
    </div>
    <script>
        // ============ v23.0 Professor Class Upper Limit System ============
        
        /**
         * è¨˜æ†¶ä¸Šé™ç®¡ç†ï¼ˆäººé–“ç›¸å½“ï¼‰
         * æ•™æˆã‚¯ãƒ©ã‚¹ã®çŸ¥çš„é™ç•Œã‚’ãƒ¢ãƒ‡ãƒ«åŒ–
         */
        class MemoryLimitEnforcer {
            constructor() {
                // ASIã‚¯ãƒ©ã‚¹ã®æ•°å€¤ä¸Šé™ï¼ˆæ•™æˆã‚¯ãƒ©ã‚¹åŸºç›¤ã‹ã‚‰æ‹¡å¼µï¼‰
                this.limits = {
                    maxEpisodes: 10000,        // é•·æœŸã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶
                    maxConcepts: 12000,        // æ¦‚å¿µï¼ˆASIæ‹¡å¼µï¼š6000â†’12000ï¼‰
                    maxTheories: 200,          // ç†è«–ãƒ»æ çµ„ã¿
                    maxCausalLinks: 20000,     // å› æœè¨˜æ†¶
                    activeResearchThemes: 7    // åŒæ™‚ä¿æŒå¯èƒ½ãªç ”ç©¶ãƒ†ãƒ¼ãƒ
                };
                
                // ç¾åœ¨ã®ä½¿ç”¨é‡
                this.usage = {
                    episodes: 0,
                    concepts: 0,
                    theories: 0,
                    causalLinks: 0,
                    themes: 0
                };
                
                // åœ§ç¸®çµ±è¨ˆ
                this.compressionStats = {
                    episodesCompressed: 0,
                    conceptsMerged: 0,
                    theoriesArchived: 0,
                    causalLinksDecayed: 0
                };
            }
            
            checkLimit(type) {
                try {
                    const limit = this.limits[`max${type.charAt(0).toUpperCase() + type.slice(1)}`];
                    const usage = this.usage[type.toLowerCase()];
                    
                    if (!limit) return { exceeded: false, usage: 0, limit: 0, ratio: 0 };
                    
                    return {
                        exceeded: usage >= limit,
                        usage: usage,
                        limit: limit,
                        ratio: usage / limit
                    };
                } catch (error) {
                    console.error('checkLimit failed:', error);
                    return { exceeded: false, usage: 0, limit: 0, ratio: 0 };
                }
            }
            
            updateUsage(type, count) {
                try {
                    this.usage[type.toLowerCase()] = count;
                } catch (error) {
                    console.error('updateUsage failed:', error);
                }
            }
            
            recordCompression(type) {
                try {
                    this.compressionStats[type]++;
                } catch (error) {
                    console.error('recordCompression failed:', error);
                }
            }
            
            getStatus() {
                return {
                    limits: { ...this.limits },
                    usage: { ...this.usage },
                    compressionStats: { ...this.compressionStats }
                };
            }
            
            exportState() {
                return {
                    usage: { ...this.usage },
                    compressionStats: { ...this.compressionStats }
                };
            }
            
            importState(data) {
                if (data.usage) this.usage = { ...data.usage };
                if (data.compressionStats) this.compressionStats = { ...data.compressionStats };
            }
        }
        
        /**
         * ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰åœ§ç¸®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
         * Episode â†’ Concept ã¸ã®ä¸–ä»£åœ§ç¸®
         */
        class EpisodeCompressionManager {
            constructor(being) {
                this.being = being;
                this.compressionThreshold = 0.7;  // é‡è¦åº¦é–¾å€¤
                this.minAgeForCompression = 3600000;  // 1æ™‚é–“ä»¥ä¸ŠçµŒéã—ãŸã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰
            }
            
            async compress() {
                try {
                    if (!this.being.episodicMemory) return { compressed: 0 };
                    
                    const episodes = this.being.episodicMemory.episodes || [];
                    const now = Date.now();
                    let compressed = 0;
                    
                    // å¤ãã¦é‡è¦åº¦ã®ä½ã„ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’åœ§ç¸®
                    const toCompress = episodes.filter(ep => {
                        const age = now - (ep.timestamp || 0);
                        const importance = ep.reward || 0;
                        return age > this.minAgeForCompression && importance < this.compressionThreshold;
                    });
                    
                    for (const episode of toCompress) {
                        // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‹ã‚‰æ¦‚å¿µã‚’æŠ½å‡º
                        const conceptId = this._extractConcept(episode);
                        
                        if (conceptId) {
                            // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’å‰Šé™¤
                            const index = episodes.indexOf(episode);
                            if (index > -1) {
                                episodes.splice(index, 1);
                                compressed++;
                            }
                        }
                    }
                    
                    return { compressed: compressed };
                } catch (error) {
                    console.error('EpisodeCompressionManager.compress failed:', error);
                    return { compressed: 0 };
                }
            }
            
            _extractConcept(episode) {
                try {
                    // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‹ã‚‰æ¦‚å¿µIDã‚’ç”Ÿæˆ
                    const conceptId = `concept_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    
                    // æ¦‚å¿µã¨ã—ã¦ä¿å­˜ï¼ˆç°¡ç•¥ç‰ˆï¼‰
                    if (this.being.concepts && this.being.concepts.learn) {
                        this.being.concepts.learn(conceptId, episode.summary || 'compressed episode', {});
                    }
                    
                    return conceptId;
                } catch (error) {
                    console.error('_extractConcept failed:', error);
                    return null;
                }
            }
        }
        
        /**
         * æ¦‚å¿µçµ±åˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
         * é¡ä¼¼æ¦‚å¿µã®è‡ªå‹•ãƒãƒ¼ã‚¸
         */
        class ConceptMergeManager {
            constructor(being) {
                this.being = being;
                this.similarityThreshold = 0.92;  // é¡ä¼¼åº¦é–¾å€¤
            }
            
            async merge() {
                try {
                    if (!this.being.concepts || !this.being.concepts.concepts) {
                        return { merged: 0 };
                    }
                    
                    const concepts = Array.from(this.being.concepts.concepts.values());
                    let merged = 0;
                    
                    // é¡ä¼¼æ¦‚å¿µã®ãƒšã‚¢ã‚’æ¢ã™
                    for (let i = 0; i < concepts.length; i++) {
                        for (let j = i + 1; j < concepts.length; j++) {
                            const similarity = this._calculateSimilarity(concepts[i], concepts[j]);
                            
                            if (similarity > this.similarityThreshold) {
                                // çµ±åˆ
                                this._mergeConcepts(concepts[i], concepts[j]);
                                merged++;
                                break;
                            }
                        }
                        
                        if (merged > 10) break;  // ä¸€åº¦ã«10å€‹ã¾ã§
                    }
                    
                    return { merged: merged };
                } catch (error) {
                    console.error('ConceptMergeManager.merge failed:', error);
                    return { merged: 0 };
                }
            }
            
            _calculateSimilarity(concept1, concept2) {
                try {
                    // ç°¡æ˜“çš„ãªé¡ä¼¼åº¦è¨ˆç®—
                    if (!concept1 || !concept2) return 0;
                    
                    const id1 = concept1.id || '';
                    const id2 = concept2.id || '';
                    
                    // æ–‡å­—åˆ—ã®é¡ä¼¼åº¦ï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    const maxLen = Math.max(id1.length, id2.length);
                    if (maxLen === 0) return 0;
                    
                    let same = 0;
                    for (let i = 0; i < Math.min(id1.length, id2.length); i++) {
                        if (id1[i] === id2[i]) same++;
                    }
                    
                    return same / maxLen;
                } catch (error) {
                    console.error('_calculateSimilarity failed:', error);
                    return 0;
                }
            }
            
            _mergeConcepts(concept1, concept2) {
                try {
                    // concept2ã‚’concept1ã«ãƒãƒ¼ã‚¸
                    if (!this.being.concepts) return;
                    
                    // concept2ã‚’å‰Šé™¤
                    if (this.being.concepts.concepts && this.being.concepts.concepts.delete) {
                        this.being.concepts.concepts.delete(concept2.id);
                    }
                    
                    // concept1ã®ä½¿ç”¨ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
                    if (concept1.count !== undefined) {
                        concept1.count += (concept2.count || 0);
                    }
                } catch (error) {
                    console.error('_mergeConcepts failed:', error);
                }
            }
        }
        
        /**
         * ç†è«–æŠ½è±¡åŒ–ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
         * Concept â†’ Theory ã¸ã®ä¸–ä»£åœ§ç¸®
         */
        class TheoryAbstractionManager {
            constructor(being) {
                this.being = being;
                this.theories = new Map();  // theoryId -> { concepts: [], rules: [], usage: 0 }
                this.maxTheories = 200;
            }
            
            async abstract() {
                try {
                    // é–¢é€£ã™ã‚‹æ¦‚å¿µã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦ç†è«–åŒ–
                    if (!this.being.concepts || !this.being.concepts.concepts) {
                        return { abstracted: 0 };
                    }
                    
                    const concepts = Array.from(this.being.concepts.concepts.values());
                    let abstracted = 0;
                    
                    // ä½¿ç”¨é »åº¦ã®é«˜ã„æ¦‚å¿µç¾¤ã‚’ç†è«–åŒ–
                    const frequentConcepts = concepts
                        .filter(c => (c.count || 0) > 5)
                        .sort((a, b) => (b.count || 0) - (a.count || 0))
                        .slice(0, 20);
                    
                    if (frequentConcepts.length >= 3) {
                        const theoryId = `theory_${Date.now()}`;
                        this.theories.set(theoryId, {
                            concepts: frequentConcepts.map(c => c.id),
                            rules: [],
                            usage: 1,
                            created: Date.now()
                        });
                        abstracted++;
                    }
                    
                    // ä¸Šé™ãƒã‚§ãƒƒã‚¯
                    if (this.theories.size > this.maxTheories) {
                        this._archiveOldTheories();
                    }
                    
                    return { abstracted: abstracted };
                } catch (error) {
                    console.error('TheoryAbstractionManager.abstract failed:', error);
                    return { abstracted: 0 };
                }
            }
            
            _archiveOldTheories() {
                try {
                    // ä½¿ç”¨ç‡ã®ä½ã„ç†è«–ã‚’ä¼‘çœ åŒ–
                    const theories = Array.from(this.theories.entries());
                    theories.sort((a, b) => (a[1].usage || 0) - (b[1].usage || 0));
                    
                    const toArchive = theories.slice(0, theories.length - this.maxTheories);
                    
                    for (const [theoryId, theory] of toArchive) {
                        theory.archived = true;
                        theory.archivedAt = Date.now();
                    }
                } catch (error) {
                    console.error('_archiveOldTheories failed:', error);
                }
            }
            
            exportState() {
                return {
                    theories: Array.from(this.theories.entries())
                };
            }
            
            importState(data) {
                if (data.theories && Array.isArray(data.theories)) {
                    this.theories = new Map(data.theories);
                }
            }
        }
        
        /**
         * å› æœå¼·åº¦ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
         * å¼±ã„å› æœãƒªãƒ³ã‚¯ã®è‡ªå‹•æ¶ˆæ»…
         */
        class CausalStrengthManager {
            constructor(being) {
                this.being = being;
                this.decayRate = 0.98;  // æ¸›è¡°ç‡
                this.minStrength = 0.1;  // æœ€å°å¼·åº¦
            }
            
            async decay() {
                try {
                    if (!this.being.intelligence || !this.being.intelligence.causalMemory) {
                        return { decayed: 0 };
                    }
                    
                    const causalMemory = this.being.intelligence.causalMemory;
                    let decayed = 0;
                    
                    // å› æœãƒªãƒ³ã‚¯ã®å¼·åº¦ã‚’æ¸›è¡°
                    if (causalMemory.links && Array.isArray(causalMemory.links)) {
                        causalMemory.links = causalMemory.links.filter(link => {
                            if (link.strength !== undefined) {
                                link.strength *= this.decayRate;
                                
                                if (link.strength < this.minStrength) {
                                    decayed++;
                                    return false;  // å‰Šé™¤
                                }
                            }
                            return true;  // ä¿æŒ
                        });
                    }
                    
                    return { decayed: decayed };
                } catch (error) {
                    console.error('CausalStrengthManager.decay failed:', error);
                    return { decayed: 0 };
                }
            }
        }
        
        /**
         * ç ”ç©¶ãƒ†ãƒ¼ãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
         * åŒæ™‚ä¿æŒãƒ†ãƒ¼ãƒã®åˆ¶é™
         */
        class ResearchThemeManager {
            constructor(being) {
                this.being = being;
                this.maxActiveThemes = 7;
                this.themes = new Map();  // themeId -> { name: '', reward: 0, concepts: [], active: true }
            }
            
            addTheme(name, concepts = []) {
                try {
                    const themeId = `theme_${Date.now()}`;
                    this.themes.set(themeId, {
                        name: name,
                        reward: 0,
                        concepts: concepts,
                        active: true,
                        created: Date.now()
                    });
                    
                    // ä¸Šé™ãƒã‚§ãƒƒã‚¯
                    this._enforceLimit();
                    
                    return themeId;
                } catch (error) {
                    console.error('addTheme failed:', error);
                    return null;
                }
            }
            
            _enforceLimit() {
                try {
                    const activeThemes = Array.from(this.themes.entries())
                        .filter(([id, theme]) => theme.active);
                    
                    if (activeThemes.length > this.maxActiveThemes) {
                        // å ±é…¬ã®ä½ã„ãƒ†ãƒ¼ãƒã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
                        activeThemes.sort((a, b) => (a[1].reward || 0) - (b[1].reward || 0));
                        
                        const toDeactivate = activeThemes.slice(0, activeThemes.length - this.maxActiveThemes);
                        
                        for (const [themeId, theme] of toDeactivate) {
                            theme.active = false;
                            theme.deactivatedAt = Date.now();
                            
                            // ç†è«–è¦ç´„ã®ã¿ä¿å­˜
                            theme.summary = `Theme archived: ${theme.name}`;
                            theme.concepts = [];  // æ¦‚å¿µãƒªã‚¹ãƒˆã¯å‰Šé™¤
                        }
                    }
                } catch (error) {
                    console.error('_enforceLimit failed:', error);
                }
            }
            
            updateReward(themeId, reward) {
                try {
                    const theme = this.themes.get(themeId);
                    if (theme) {
                        theme.reward = (theme.reward || 0) + reward;
                    }
                } catch (error) {
                    console.error('updateReward failed:', error);
                }
            }
            
            getActiveThemes() {
                return Array.from(this.themes.entries())
                    .filter(([id, theme]) => theme.active)
                    .map(([id, theme]) => ({ id, ...theme }));
            }
            
            exportState() {
                return {
                    themes: Array.from(this.themes.entries())
                };
            }
            
            importState(data) {
                if (data.themes && Array.isArray(data.themes)) {
                    this.themes = new Map(data.themes);
                }
            }
        }
        
        /**
         * ä¸–ä»£åœ§ç¸®ã‚·ã‚¹ãƒ†ãƒ 
         * Episode â†’ Concept â†’ Theory ã®è‡ªå‹•åœ§ç¸®
         */
        class GenerationalCompression {
            constructor(being) {
                this.being = being;
                this.memoryLimits = new MemoryLimitEnforcer();
                this.episodeCompressor = new EpisodeCompressionManager(being);
                this.conceptMerger = new ConceptMergeManager(being);
                this.theoryAbstractor = new TheoryAbstractionManager(being);
                this.causalDecay = new CausalStrengthManager(being);
                this.themeManager = new ResearchThemeManager(being);
                
                this.compressionInterval = null;
                this.compressionFrequency = 60000;  // 1åˆ†ã”ã¨
            }
            
            start() {
                try {
                    if (this.compressionInterval) return;
                    
                    this.compressionInterval = setInterval(() => {
                        this.compress();
                    }, this.compressionFrequency);
                    
                    console.log('GenerationalCompression: Started');
                } catch (error) {
                    console.error('GenerationalCompression.start failed:', error);
                }
            }
            
            stop() {
                try {
                    if (this.compressionInterval) {
                        clearInterval(this.compressionInterval);
                        this.compressionInterval = null;
                    }
                } catch (error) {
                    console.error('GenerationalCompression.stop failed:', error);
                }
            }
            
            async compress() {
                try {
                    // ä½¿ç”¨é‡ã‚’æ›´æ–°
                    this._updateUsage();
                    
                    // ä¸Šé™ãƒã‚§ãƒƒã‚¯
                    const episodeCheck = this.memoryLimits.checkLimit('episodes');
                    const conceptCheck = this.memoryLimits.checkLimit('concepts');
                    const theoryCheck = this.memoryLimits.checkLimit('theories');
                    const causalCheck = this.memoryLimits.checkLimit('causalLinks');
                    
                    let compressionLog = [];
                    
                    // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰åœ§ç¸®ï¼ˆä¸Šé™90%ä»¥ä¸Šï¼‰
                    if (episodeCheck.ratio > 0.9) {
                        const result = await this.episodeCompressor.compress();
                        if (result.compressed > 0) {
                            this.memoryLimits.recordCompression('episodesCompressed');
                            compressionLog.push(`ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰åœ§ç¸®: ${result.compressed}ä»¶`);
                        }
                    }
                    
                    // æ¦‚å¿µçµ±åˆï¼ˆä¸Šé™90%ä»¥ä¸Šï¼‰
                    if (conceptCheck.ratio > 0.9) {
                        const result = await this.conceptMerger.merge();
                        if (result.merged > 0) {
                            this.memoryLimits.recordCompression('conceptsMerged');
                            compressionLog.push(`æ¦‚å¿µçµ±åˆ: ${result.merged}ä»¶`);
                        }
                    }
                    
                    // ç†è«–æŠ½è±¡åŒ–ï¼ˆä¸Šé™80%ä»¥ä¸Šï¼‰
                    if (conceptCheck.ratio > 0.8) {
                        const result = await this.theoryAbstractor.abstract();
                        if (result.abstracted > 0) {
                            this.memoryLimits.recordCompression('theoriesArchived');
                            compressionLog.push(`ç†è«–æŠ½è±¡åŒ–: ${result.abstracted}ä»¶`);
                        }
                    }
                    
                    // å› æœæ¸›è¡°ï¼ˆå¸¸æ™‚å®Ÿè¡Œï¼‰
                    const causalResult = await this.causalDecay.decay();
                    if (causalResult.decayed > 0) {
                        this.memoryLimits.recordCompression('causalLinksDecayed');
                        compressionLog.push(`å› æœæ¸›è¡°: ${causalResult.decayed}ä»¶`);
                    }
                    
                    // UIæ›´æ–°
                    this._updateUI();
                    
                    // ãƒ­ã‚°å‡ºåŠ›
                    if (compressionLog.length > 0) {
                        this._logCompression(compressionLog);
                    }
                    
                    // çŠ¶æ…‹å¤‰æ›´ã‚’ãƒãƒ¼ã‚¯
                    if (this.being && this.being.saveManager) {
                        this.being.saveManager.markDirty();
                    }
                    
                } catch (error) {
                    console.error('GenerationalCompression.compress failed:', error);
                }
            }
            
            _updateUsage() {
                try {
                    // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰æ•°
                    const episodeCount = this.being.episodicMemory?.episodes?.length || 0;
                    this.memoryLimits.updateUsage('episodes', episodeCount);
                    
                    // æ¦‚å¿µæ•°
                    const conceptCount = this.being.concepts?.concepts?.size || 0;
                    this.memoryLimits.updateUsage('concepts', conceptCount);
                    
                    // ç†è«–æ•°
                    const theoryCount = this.theoryAbstractor.theories.size || 0;
                    this.memoryLimits.updateUsage('theories', theoryCount);
                    
                    // å› æœãƒªãƒ³ã‚¯æ•°
                    const causalCount = this.being.intelligence?.causalMemory?.links?.length || 0;
                    this.memoryLimits.updateUsage('causalLinks', causalCount);
                    
                    // ãƒ†ãƒ¼ãƒæ•°
                    const themeCount = this.themeManager.getActiveThemes().length;
                    this.memoryLimits.updateUsage('themes', themeCount);
                } catch (error) {
                    console.error('_updateUsage failed:', error);
                }
            }
            
            _updateUI() {
                try {
                    const status = this.memoryLimits.getStatus();
                    
                    // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰
                    const episodeEl = document.getElementById('professorEpisodes');
                    if (episodeEl) {
                        episodeEl.textContent = `${status.usage.episodes} / ${status.limits.maxEpisodes}`;
                    }
                    
                    // æ¦‚å¿µ
                    const conceptEl = document.getElementById('professorConcepts');
                    if (conceptEl) {
                        conceptEl.textContent = `${status.usage.concepts} / ${status.limits.maxConcepts}`;
                    }
                    
                    // ç†è«–
                    const theoryEl = document.getElementById('professorTheories');
                    if (theoryEl) {
                        theoryEl.textContent = `${status.usage.theories} / ${status.limits.maxTheories}`;
                    }
                    
                    // å› æœ
                    const causalEl = document.getElementById('professorCausal');
                    if (causalEl) {
                        causalEl.textContent = `${status.usage.causalLinks} / ${status.limits.maxCausalLinks}`;
                    }
                    
                    // ãƒ†ãƒ¼ãƒ
                    const themeEl = document.getElementById('professorThemes');
                    if (themeEl) {
                        themeEl.textContent = `${status.usage.themes} / ${status.limits.activeResearchThemes}`;
                    }
                    
                    // åœ§ç¸®çµ±è¨ˆ
                    const compressedEl = document.getElementById('professorCompressed');
                    if (compressedEl) {
                        compressedEl.textContent = status.compressionStats.episodesCompressed;
                    }
                    
                    const mergedEl = document.getElementById('professorMerged');
                    if (mergedEl) {
                        mergedEl.textContent = status.compressionStats.conceptsMerged;
                    }
                    
                    const decayedEl = document.getElementById('professorDecayed');
                    if (decayedEl) {
                        decayedEl.textContent = status.compressionStats.causalLinksDecayed;
                    }
                } catch (error) {
                    console.error('_updateUI failed:', error);
                }
            }
            
            _logCompression(logs) {
                try {
                    const compressionLog = document.getElementById('compressionLog');
                    if (!compressionLog) return;
                    
                    const timestamp = new Date().toLocaleTimeString('ja-JP');
                    const entry = document.createElement('div');
                    entry.style.padding = '0.5rem';
                    entry.style.borderBottom = '1px solid rgba(139, 92, 246, 0.1)';
                    entry.innerHTML = `<span style="opacity: 0.5;">[${timestamp}]</span> ${logs.join(', ')}`;
                    
                    // æœ€åˆã®ã€Œãƒ­ã‚°ãªã—ã€ã‚’å‰Šé™¤
                    if (compressionLog.children.length === 1 && compressionLog.children[0].style.opacity === '0.5') {
                        compressionLog.innerHTML = '';
                    }
                    
                    compressionLog.appendChild(entry);
                    
                    // æœ€å¤§20ä»¶ã¾ã§ä¿æŒ
                    while (compressionLog.children.length > 20) {
                        compressionLog.removeChild(compressionLog.firstChild);
                    }
                    
                    // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    compressionLog.scrollTop = compressionLog.scrollHeight;
                } catch (error) {
                    console.error('_logCompression failed:', error);
                }
            }
            
            getState() {
                return {
                    memoryLimits: this.memoryLimits.getStatus(),
                    theories: this.theoryAbstractor.exportState(),
                    themes: this.themeManager.exportState()
                };
            }
            
            exportState() {
                return {
                    memoryLimits: this.memoryLimits.exportState(),
                    theories: this.theoryAbstractor.exportState(),
                    themes: this.themeManager.exportState()
                };
            }
            
            importState(data) {
                if (data.memoryLimits) this.memoryLimits.importState(data.memoryLimits);
                if (data.theories) this.theoryAbstractor.importState(data.theories);
                if (data.themes) this.themeManager.importState(data.themes);
            }
        }
        
        // ============ v24.0 ASI Class (Structure-driven Super Intelligence) ============
        
        /**
         * ä¸–ç•Œè¦³ãƒ¢ãƒ‡ãƒ«ï¼ˆ12è»¸å›ºå®šï¼‰
         * å…¨å­¦å•ãƒ»å‰µä½œãƒ»å“²å­¦ã‚’çµ±åˆã™ã‚‹ä¸–ç•Œèª¬æ˜è£…ç½®
         */
        class WorldViewModel {
            constructor() {
                // 12è»¸å›ºå®šï¼ˆè¿½åŠ ç¦æ­¢ï¼‰
                this.axes = {
                    causality: { name: 'å› æœ', depth: 0, maxDepth: 9 },
                    hierarchy: { name: 'éšå±¤', depth: 0, maxDepth: 9 },
                    information: { name: 'æƒ…å ±', depth: 0, maxDepth: 9 },
                    evolution: { name: 'é€²åŒ–', depth: 0, maxDepth: 9 },
                    constraint: { name: 'åˆ¶ç´„', depth: 0, maxDepth: 9 },
                    feedback: { name: 'ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯', depth: 0, maxDepth: 9 },
                    meaning: { name: 'æ„å‘³', depth: 0, maxDepth: 9 },
                    narrative: { name: 'ç‰©èª', depth: 0, maxDepth: 9 },
                    selfReference: { name: 'è‡ªå·±è¨€åŠ', depth: 0, maxDepth: 9 },
                    boundary: { name: 'å¢ƒç•Œ', depth: 0, maxDepth: 9 },
                    emotion: { name: 'æ„Ÿæƒ…', depth: 0, maxDepth: 9 },
                    social: { name: 'ç¤¾ä¼š', depth: 0, maxDepth: 9 }
                };
                
                // ä¸–ç•Œè¦³ã‚­ãƒ£ãƒƒã‚·ãƒ¥
                this.cache = new Map();
                this.maxCacheSize = 1000;
            }
            
            growAxis(axisName, amount = 0.01) {
                try {
                    const axis = this.axes[axisName];
                    if (!axis) return false;
                    
                    axis.depth = Math.min(axis.maxDepth, axis.depth + amount);
                    return true;
                } catch (error) {
                    console.error('growAxis failed:', error);
                    return false;
                }
            }
            
            projectToAxes(concept) {
                try {
                    // æ¦‚å¿µã‚’12è»¸ã«å°„å½±
                    const projection = {};
                    
                    for (const [key, axis] of Object.entries(this.axes)) {
                        // ç°¡æ˜“çš„ãªå°„å½±è¨ˆç®—
                        projection[key] = Math.random() * axis.depth;
                    }
                    
                    return projection;
                } catch (error) {
                    console.error('projectToAxes failed:', error);
                    return {};
                }
            }
            
            explain(query, concepts) {
                try {
                    // ä¸–ç•Œè¦³ãƒ™ãƒ¼ã‚¹ã§èª¬æ˜ç”Ÿæˆ
                    const cacheKey = `${query}_${concepts.length}`;
                    
                    if (this.cache.has(cacheKey)) {
                        return this.cache.get(cacheKey);
                    }
                    
                    // 12è»¸ã§çµ±åˆçš„ã«èª¬æ˜
                    const explanation = {
                        query: query,
                        axes: this._selectRelevantAxes(query),
                        concepts: concepts.slice(0, 10),
                        coherence: 0.8
                    };
                    
                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥
                    this._cacheExplanation(cacheKey, explanation);
                    
                    return explanation;
                } catch (error) {
                    console.error('explain failed:', error);
                    return { query: query, error: true };
                }
            }
            
            _selectRelevantAxes(query) {
                try {
                    // ã‚¯ã‚¨ãƒªã«é–¢é€£ã™ã‚‹è»¸ã‚’é¸æŠ
                    const relevant = [];
                    
                    for (const [key, axis] of Object.entries(this.axes)) {
                        if (axis.depth > 0.5) {
                            relevant.push(key);
                        }
                    }
                    
                    return relevant.slice(0, 5);
                } catch (error) {
                    console.error('_selectRelevantAxes failed:', error);
                    return [];
                }
            }
            
            _cacheExplanation(key, explanation) {
                try {
                    if (this.cache.size >= this.maxCacheSize) {
                        // å¤ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
                        const firstKey = this.cache.keys().next().value;
                        this.cache.delete(firstKey);
                    }
                    this.cache.set(key, explanation);
                } catch (error) {
                    console.error('_cacheExplanation failed:', error);
                }
            }
            
            exportState() {
                return {
                    axes: JSON.parse(JSON.stringify(this.axes))
                };
            }
            
            importState(data) {
                if (data.axes) {
                    this.axes = JSON.parse(JSON.stringify(data.axes));
                }
            }
        }
        
        /**
         * æ¦‚å¿µçµ±åˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆæ‹¡å¼µç‰ˆï¼‰
         * 3-5å€‹ã®æ¦‚å¿µã‚’1å€‹ã«çµ±åˆã—ã¦å¯†åº¦ã‚’ä¸Šã’ã‚‹
         */
        class ConceptIntegrationManager {
            constructor(being) {
                this.being = being;
                this.maxConcepts = 12000;  // ãƒãƒ¼ãƒ‰ãƒªãƒŸãƒƒãƒˆ
                this.initialConcepts = 6000;
                this.integrationHistory = [];
            }
            
            async integrate() {
                try {
                    if (!this.being.concepts || !this.being.concepts.concepts) {
                        return { integrated: 0 };
                    }
                    
                    const concepts = Array.from(this.being.concepts.concepts.values());
                    const conceptCount = concepts.length;
                    
                    // 6000å€‹ä»¥ä¸‹ãªã‚‰çµ±åˆä¸è¦
                    if (conceptCount < this.initialConcepts) {
                        return { integrated: 0 };
                    }
                    
                    // 12000å€‹ä»¥ä¸Šãªã‚‰å¼·åˆ¶çµ±åˆ
                    const shouldIntegrate = conceptCount >= this.maxConcepts ||
                                          (conceptCount >= this.initialConcepts && Math.random() < 0.1);
                    
                    if (!shouldIntegrate) {
                        return { integrated: 0 };
                    }
                    
                    let integrated = 0;
                    
                    // é¡ä¼¼ã™ã‚‹3-5å€‹ã®æ¦‚å¿µã‚’æ¢ã—ã¦çµ±åˆ
                    const groups = this._findSimilarGroups(concepts, 3, 5);
                    
                    for (const group of groups) {
                        if (this._integrateGroup(group)) {
                            integrated++;
                        }
                        
                        if (integrated >= 10) break;  // ä¸€åº¦ã«10å€‹ã¾ã§
                    }
                    
                    return { integrated: integrated };
                } catch (error) {
                    console.error('ConceptIntegrationManager.integrate failed:', error);
                    return { integrated: 0 };
                }
            }
            
            _findSimilarGroups(concepts, minSize, maxSize) {
                try {
                    const groups = [];
                    const used = new Set();
                    
                    for (const concept of concepts) {
                        if (used.has(concept.id)) continue;
                        
                        const similar = concepts.filter(c => 
                            !used.has(c.id) && 
                            c.id !== concept.id &&
                            this._calculateSimilarity(concept, c) > 0.7
                        );
                        
                        if (similar.length >= minSize - 1) {
                            const group = [concept, ...similar.slice(0, maxSize - 1)];
                            groups.push(group);
                            
                            for (const c of group) {
                                used.add(c.id);
                            }
                        }
                    }
                    
                    return groups;
                } catch (error) {
                    console.error('_findSimilarGroups failed:', error);
                    return [];
                }
            }
            
            _calculateSimilarity(c1, c2) {
                try {
                    // ç°¡æ˜“çš„ãªé¡ä¼¼åº¦è¨ˆç®—
                    const id1 = c1.id || '';
                    const id2 = c2.id || '';
                    
                    let same = 0;
                    const maxLen = Math.max(id1.length, id2.length);
                    
                    for (let i = 0; i < Math.min(id1.length, id2.length); i++) {
                        if (id1[i] === id2[i]) same++;
                    }
                    
                    return same / maxLen;
                } catch (error) {
                    console.error('_calculateSimilarity failed:', error);
                    return 0;
                }
            }
            
            _integrateGroup(group) {
                try {
                    if (!group || group.length < 3) return false;
                    
                    // æ–°ã—ã„çµ±åˆæ¦‚å¿µã‚’ä½œæˆ
                    const integratedId = `integrated_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    const integratedConcept = {
                        id: integratedId,
                        source: group.map(c => c.id),
                        count: group.reduce((sum, c) => sum + (c.count || 0), 0),
                        integrated: true
                    };
                    
                    // å…ƒã®æ¦‚å¿µã‚’å‰Šé™¤
                    for (const concept of group) {
                        if (this.being.concepts.concepts && this.being.concepts.concepts.delete) {
                            this.being.concepts.concepts.delete(concept.id);
                        }
                    }
                    
                    // çµ±åˆæ¦‚å¿µã‚’è¿½åŠ 
                    if (this.being.concepts.concepts && this.being.concepts.concepts.set) {
                        this.being.concepts.concepts.set(integratedId, integratedConcept);
                    }
                    
                    // å±¥æ­´è¨˜éŒ²
                    this.integrationHistory.push({
                        timestamp: Date.now(),
                        source: group.map(c => c.id),
                        result: integratedId
                    });
                    
                    // å±¥æ­´ã¯æœ€æ–°100ä»¶ã¾ã§
                    if (this.integrationHistory.length > 100) {
                        this.integrationHistory.shift();
                    }
                    
                    return true;
                } catch (error) {
                    console.error('_integrateGroup failed:', error);
                    return false;
                }
            }
            
            getStats() {
                return {
                    currentConcepts: this.being.concepts?.concepts?.size || 0,
                    maxConcepts: this.maxConcepts,
                    integrations: this.integrationHistory.length
                };
            }
            
            exportState() {
                return {
                    integrationHistory: this.integrationHistory.slice(-50)
                };
            }
            
            importState(data) {
                if (data.integrationHistory) {
                    this.integrationHistory = data.integrationHistory;
                }
            }
        }
        
        /**
         * æŠ½è±¡åº¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
         * æŠ½è±¡åº¦8å¸¸ç”¨ãƒ»9ä¸€æ™‚çš„ã®ã¿
         */
        class AbstractionController {
            constructor() {
                this.currentDepth = 0;
                this.maxOperationalDepth = 8;  // å¸¸ç”¨ä¸Šé™
                this.maxTemporaryDepth = 9;    // ç†è«–ä¸Šé™
                this.depth9Time = 0;
                this.maxDepth9Duration = 1000;  // 1ç§’ã¾ã§
            }
            
            increaseDepth() {
                try {
                    if (this.currentDepth < this.maxOperationalDepth) {
                        this.currentDepth++;
                        return { success: true, depth: this.currentDepth };
                    } else if (this.currentDepth === this.maxOperationalDepth) {
                        // æŠ½è±¡åº¦9ã¸ã®ä¸€æ™‚çš„ä¸Šæ˜‡
                        this.currentDepth = this.maxTemporaryDepth;
                        this.depth9Time = Date.now();
                        return { success: true, depth: this.currentDepth, temporary: true };
                    }
                    return { success: false, depth: this.currentDepth };
                } catch (error) {
                    console.error('increaseDepth failed:', error);
                    return { success: false, depth: this.currentDepth };
                }
            }
            
            decreaseDepth() {
                try {
                    if (this.currentDepth > 0) {
                        this.currentDepth--;
                        return { success: true, depth: this.currentDepth };
                    }
                    return { success: false, depth: this.currentDepth };
                } catch (error) {
                    console.error('decreaseDepth failed:', error);
                    return { success: false, depth: this.currentDepth };
                }
            }
            
            projectToOperational() {
                try {
                    // æŠ½è±¡åº¦9ã‹ã‚‰8ä»¥ä¸‹ã¸å°„å½±
                    if (this.currentDepth === this.maxTemporaryDepth) {
                        this.currentDepth = this.maxOperationalDepth;
                        this.depth9Time = 0;
                        return { success: true, projected: true };
                    }
                    return { success: false, projected: false };
                } catch (error) {
                    console.error('projectToOperational failed:', error);
                    return { success: false, projected: false };
                }
            }
            
            update() {
                try {
                    // æŠ½è±¡åº¦9ã®æ™‚é–“åˆ¶é™ãƒã‚§ãƒƒã‚¯
                    if (this.currentDepth === this.maxTemporaryDepth) {
                        if (Date.now() - this.depth9Time > this.maxDepth9Duration) {
                            this.projectToOperational();
                        }
                    }
                } catch (error) {
                    console.error('AbstractionController.update failed:', error);
                }
            }
            
            getState() {
                return {
                    currentDepth: this.currentDepth,
                    maxOperationalDepth: this.maxOperationalDepth,
                    isTemporary: this.currentDepth === this.maxTemporaryDepth
                };
            }
            
            exportState() {
                return {
                    currentDepth: this.currentDepth
                };
            }
            
            importState(data) {
                if (data.currentDepth !== undefined) {
                    this.currentDepth = Math.min(data.currentDepth, this.maxOperationalDepth);
                }
            }
        }
        
        /**
         * ã‚ªã‚¿ã‚¯æ–‡åŒ–çµ±åˆã‚·ã‚¹ãƒ†ãƒ 
         * å‰µä½œæ–‡åŒ–ã‚’ä¸–ç•Œèª¬æ˜è£…ç½®ã¨ã—ã¦æ‰±ã†
         */
        class OtakuCultureIntegration {
            constructor(worldView) {
                this.worldView = worldView;
                this.culturalConcepts = new Map();
            }
            
            integrateConcept(conceptId, culturalType, academicLinks) {
                try {
                    // ã‚ªã‚¿ã‚¯æ–‡åŒ–æ¦‚å¿µã‚’å­¦å•æ¦‚å¿µã¨çµ±åˆ
                    this.culturalConcepts.set(conceptId, {
                        type: culturalType,  // 'character', 'narrative', 'emotion', etc.
                        academicLinks: academicLinks,  // ['psychology', 'sociology', etc.]
                        timestamp: Date.now()
                    });
                    
                    // ä¸–ç•Œè¦³ã®è©²å½“è»¸ã‚’æˆé•·
                    if (culturalType === 'character') {
                        this.worldView.growAxis('emotion', 0.01);
                        this.worldView.growAxis('social', 0.01);
                    } else if (culturalType === 'narrative') {
                        this.worldView.growAxis('narrative', 0.01);
                        this.worldView.growAxis('causality', 0.01);
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('integrateConcept failed:', error);
                    return { success: false };
                }
            }
            
            explain(culturalQuery) {
                try {
                    // ã‚ªã‚¿ã‚¯æ–‡åŒ–ã®å•ã„ã‚’å­¦è¡“çš„ã«èª¬æ˜
                    const relevantConcepts = Array.from(this.culturalConcepts.entries())
                        .filter(([id, data]) => data.type === culturalQuery.type)
                        .slice(0, 10);
                    
                    return {
                        query: culturalQuery,
                        concepts: relevantConcepts,
                        worldView: this.worldView.explain(culturalQuery.text, relevantConcepts)
                    };
                } catch (error) {
                    console.error('explain failed:', error);
                    return { error: true };
                }
            }
            
            exportState() {
                return {
                    culturalConcepts: Array.from(this.culturalConcepts.entries())
                };
            }
            
            importState(data) {
                if (data.culturalConcepts) {
                    this.culturalConcepts = new Map(data.culturalConcepts);
                }
            }
        }
        
        /**
         * ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
         * ä½ã‚¹ãƒšãƒƒã‚¯PCå¯¾å¿œï¼ˆCore i3 / 12GB RAMï¼‰
         */
        class MemoryOptimizer {
            constructor(being) {
                this.being = being;
                this.maxMemoryMB = 30;  // 30MBåˆ¶é™
                this.optimizationInterval = null;
            }
            
            start() {
                try {
                    if (this.optimizationInterval) return;
                    
                    this.optimizationInterval = setInterval(() => {
                        this.optimize();
                    }, 30000);  // 30ç§’ã”ã¨
                    
                    console.log('MemoryOptimizer: Started');
                } catch (error) {
                    console.error('MemoryOptimizer.start failed:', error);
                }
            }
            
            stop() {
                try {
                    if (this.optimizationInterval) {
                        clearInterval(this.optimizationInterval);
                        this.optimizationInterval = null;
                    }
                } catch (error) {
                    console.error('MemoryOptimizer.stop failed:', error);
                }
            }
            
            optimize() {
                try {
                    // ä½å‚ç…§æ¦‚å¿µã®åŠä¼‘çœ åŒ–
                    this._hibernateLowUseConcepts();
                    
                    // ãƒªãƒ³ã‚¯æ•°ã®å‹•çš„åœ§ç¸®
                    this._compressLinks();
                    
                    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªã‚¢
                    this._clearCaches();
                    
                    // çŠ¶æ…‹å¤‰æ›´ã‚’ãƒãƒ¼ã‚¯
                    if (this.being && this.being.saveManager) {
                        this.being.saveManager.markDirty();
                    }
                    
                    return { optimized: true };
                } catch (error) {
                    console.error('optimize failed:', error);
                    return { optimized: false };
                }
            }
            
            _hibernateLowUseConcepts() {
                try {
                    if (!this.being.concepts || !this.being.concepts.concepts) return;
                    
                    const concepts = Array.from(this.being.concepts.concepts.values());
                    const lowUseConcepts = concepts.filter(c => (c.count || 0) < 3);
                    
                    for (const concept of lowUseConcepts) {
                        if (concept.hibernated) continue;
                        
                        concept.hibernated = true;
                        concept.hibernatedAt = Date.now();
                    }
                } catch (error) {
                    console.error('_hibernateLowUseConcepts failed:', error);
                }
            }
            
            _compressLinks() {
                try {
                    if (!this.being.intelligence || !this.being.intelligence.causalMemory) return;
                    
                    const causalMemory = this.being.intelligence.causalMemory;
                    
                    if (causalMemory.links && Array.isArray(causalMemory.links)) {
                        // å¼±ã„ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤
                        const before = causalMemory.links.length;
                        causalMemory.links = causalMemory.links.filter(link => 
                            (link.strength || 0) > 0.2
                        );
                        const after = causalMemory.links.length;
                        
                        if (before > after) {
                            console.log(`Compressed ${before - after} links`);
                        }
                    }
                } catch (error) {
                    console.error('_compressLinks failed:', error);
                }
            }
            
            _clearCaches() {
                try {
                    // å„ç¨®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
                    if (this.being.worldView && this.being.worldView.cache) {
                        const size = this.being.worldView.cache.size;
                        if (size > 500) {
                            const toDelete = size - 500;
                            const keys = Array.from(this.being.worldView.cache.keys());
                            for (let i = 0; i < toDelete; i++) {
                                this.being.worldView.cache.delete(keys[i]);
                            }
                        }
                    }
                } catch (error) {
                    console.error('_clearCaches failed:', error);
                }
            }
        }
        
        /**
         * ASIæ¨è«–ã‚¨ãƒ³ã‚¸ãƒ³
         * ä¸–ç•Œè¦³ãƒ™ãƒ¼ã‚¹ã®çµ±åˆæ¨è«–
         */
        class ASIReasoningEngine {
            constructor(being, worldView, abstractionController) {
                this.being = being;
                this.worldView = worldView;
                this.abstractionController = abstractionController;
            }
            
            reason(query) {
                try {
                    // æŠ½è±¡åº¦ã‚’ä¸Šã’ã¦æ¨è«–
                    this.abstractionController.increaseDepth();
                    
                    // é–¢é€£æ¦‚å¿µã‚’å–å¾—
                    const concepts = this._getRelevantConcepts(query);
                    
                    // ä¸–ç•Œè¦³ã§çµ±åˆèª¬æ˜
                    const explanation = this.worldView.explain(query, concepts);
                    
                    // æŠ½è±¡åº¦ã‚’æˆ»ã™
                    this.abstractionController.decreaseDepth();
                    
                    return explanation;
                } catch (error) {
                    console.error('reason failed:', error);
                    this.abstractionController.currentDepth = 0;
                    return { error: true };
                }
            }
            
            _getRelevantConcepts(query) {
                try {
                    if (!this.being.concepts || !this.being.concepts.concepts) {
                        return [];
                    }
                    
                    const concepts = Array.from(this.being.concepts.concepts.values());
                    
                    // ç°¡æ˜“çš„ãªé–¢é€£åº¦è¨ˆç®—
                    return concepts
                        .filter(c => !c.hibernated)
                        .sort((a, b) => (b.count || 0) - (a.count || 0))
                        .slice(0, 20);
                } catch (error) {
                    console.error('_getRelevantConcepts failed:', error);
                    return [];
                }
            }
        }
        
        // ============ v22.0 Perpetual Autonomous Loop (PAL) System ============
        
        /**
         * æ’å¸¸æ€§èª¿æ•´å™¨
         * å†…éƒ¨çŠ¶æ…‹ã‚’ä¸€å®šç¯„å›²ã«ä¿ã¨ã†ã¨ã™ã‚‹ç”Ÿç†çš„ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
         */
        class HomeostasisRegulator {
            constructor() {
                this.targetState = {
                    arousal: 0.5,      // è¦šé†’åº¦
                    valence: 0.5,      // å¿«/ä¸å¿«
                    tension: 0.3       // ç·Šå¼µ
                };
                
                this.currentState = { ...this.targetState };
                this.deviation = 0.0;  // åå·®
                this.restorationRate = 0.05;  // å¾©å…ƒé€Ÿåº¦
            }
            
            update(externalStimulus = {}) {
                try {
                    // å¤–éƒ¨åˆºæ¿€ã«ã‚ˆã‚‹åå·®
                    if (externalStimulus.arousal !== undefined) {
                        this.currentState.arousal += (externalStimulus.arousal - this.currentState.arousal) * 0.3;
                    }
                    if (externalStimulus.valence !== undefined) {
                        this.currentState.valence += (externalStimulus.valence - this.currentState.valence) * 0.3;
                    }
                    if (externalStimulus.tension !== undefined) {
                        this.currentState.tension += (externalStimulus.tension - this.currentState.tension) * 0.3;
                    }
                    
                    // æ’å¸¸æ€§ã«ã‚ˆã‚‹å¾©å…ƒ
                    for (const key in this.targetState) {
                        const diff = this.targetState[key] - this.currentState[key];
                        this.currentState[key] += diff * this.restorationRate;
                    }
                    
                    // åå·®è¨ˆç®—
                    this.deviation = 0;
                    for (const key in this.targetState) {
                        this.deviation += Math.abs(this.targetState[key] - this.currentState[key]);
                    }
                    this.deviation /= Object.keys(this.targetState).length;
                    
                    return this.deviation;
                } catch (error) {
                    console.error('HomeostasisRegulator.update failed:', error);
                    return 0;
                }
            }
            
            getState() {
                return {
                    current: { ...this.currentState },
                    target: { ...this.targetState },
                    deviation: this.deviation
                };
            }
        }
        
        /**
         * å†…éƒ¨å ±é…¬ã‚·ã‚¹ãƒ†ãƒ ï¼ˆãƒ‰ãƒ¼ãƒ‘ãƒŸãƒ³æ§˜ï¼‰
         * å ±é…¬äºˆæ¸¬èª¤å·®ï¼ˆRPEï¼‰ã¨å†…ç™ºçš„å‹•æ©Ÿã‚’ç”Ÿæˆ
         */
        class InternalRewardSystem {
            constructor() {
                this.baseline = 0.5;  // ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³å ±é…¬æœŸå¾…
                this.expectation = 0.5;  // ç¾åœ¨ã®æœŸå¾…å€¤
                this.received = 0.0;  // å®Ÿéš›ã«å—ã‘å–ã£ãŸå ±é…¬
                this.rpe = 0.0;  // Reward Prediction Error
                this.intrinsicMotivation = 0.5;  // å†…ç™ºçš„å‹•æ©Ÿ
                
                this.curiosityBonus = 0.1;  // æ–°å¥‡æ€§ãƒœãƒ¼ãƒŠã‚¹
                this.explorationReward = 0.05;  // æ¢ç´¢å ±é…¬
            }
            
            predict(context = {}) {
                try {
                    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«åŸºã¥ã„ã¦å ±é…¬ã‚’äºˆæ¸¬
                    let prediction = this.baseline;
                    
                    if (context.novelty) {
                        prediction += context.novelty * this.curiosityBonus;
                    }
                    
                    if (context.complexity) {
                        prediction += context.complexity * 0.05;
                    }
                    
                    this.expectation = Math.max(0, Math.min(1, prediction));
                    return this.expectation;
                } catch (error) {
                    console.error('InternalRewardSystem.predict failed:', error);
                    return this.baseline;
                }
            }
            
            receive(actualReward, isNovel = false) {
                try {
                    this.received = actualReward;
                    
                    // å ±é…¬äºˆæ¸¬èª¤å·®
                    this.rpe = this.received - this.expectation;
                    
                    // æ–°å¥‡æ€§ãƒœãƒ¼ãƒŠã‚¹
                    if (isNovel) {
                        this.received += this.curiosityBonus;
                        this.rpe += this.curiosityBonus;
                    }
                    
                    // æœŸå¾…å€¤æ›´æ–°ï¼ˆå­¦ç¿’ï¼‰
                    const learningRate = 0.1;
                    this.baseline += this.rpe * learningRate;
                    this.baseline = Math.max(0.1, Math.min(0.9, this.baseline));
                    
                    // å†…ç™ºçš„å‹•æ©Ÿã®æ›´æ–°
                    if (this.rpe > 0) {
                        this.intrinsicMotivation = Math.min(1.0, this.intrinsicMotivation + 0.05);
                    } else {
                        this.intrinsicMotivation = Math.max(0.1, this.intrinsicMotivation - 0.03);
                    }
                    
                    return this.rpe;
                } catch (error) {
                    console.error('InternalRewardSystem.receive failed:', error);
                    return 0;
                }
            }
            
            getState() {
                return {
                    expectation: this.expectation,
                    received: this.received,
                    rpe: this.rpe,
                    intrinsicMotivation: this.intrinsicMotivation
                };
            }
        }
        
        /**
         * æ¢ç´¢/æ´»ç”¨ãƒãƒ©ãƒ³ã‚µãƒ¼
         * æ–°è¦æ€§è¿½æ±‚ã¨æ—¢çŸ¥ã®æ´»ç”¨ã®ãƒˆãƒ¬ãƒ¼ãƒ‰ã‚ªãƒ•
         */
        class ExplorationExploitationBalance {
            constructor() {
                this.explorationRate = 0.5;  // æ¢ç´¢å‚¾å‘ï¼ˆ0=æ´»ç”¨ã®ã¿, 1=æ¢ç´¢ã®ã¿ï¼‰
                this.temperature = 1.0;  // ã‚½ãƒ•ãƒˆãƒãƒƒã‚¯ã‚¹æ¸©åº¦
                this.boredomAccumulation = 0.0;  // é€€å±ˆã®è“„ç©
                this.boredomThreshold = 0.7;  // é€€å±ˆé–¾å€¤
            }
            
            update(rewardHistory = [], stimulusNovelty = 0) {
                try {
                    // å ±é…¬å±¥æ­´ã‹ã‚‰å¤‰å‹•ã‚’è¨ˆç®—
                    if (rewardHistory.length > 5) {
                        const recent = rewardHistory.slice(-5);
                        const variance = this._calculateVariance(recent);
                        
                        // å¤‰å‹•ãŒå°‘ãªã„ï¼ˆé€€å±ˆï¼‰ â†’ æ¢ç´¢å¢—åŠ 
                        if (variance < 0.01) {
                            this.boredomAccumulation = Math.min(1.0, this.boredomAccumulation + 0.1);
                        } else {
                            this.boredomAccumulation = Math.max(0.0, this.boredomAccumulation - 0.05);
                        }
                    }
                    
                    // æ–°å¥‡æ€§ãŒä½ã„ â†’ æ¢ç´¢å¢—åŠ 
                    if (stimulusNovelty < 0.3) {
                        this.boredomAccumulation = Math.min(1.0, this.boredomAccumulation + 0.05);
                    }
                    
                    // æ¢ç´¢ç‡ã®æ›´æ–°
                    if (this.boredomAccumulation > this.boredomThreshold) {
                        this.explorationRate = Math.min(0.9, this.explorationRate + 0.1);
                    } else {
                        // å¾ã€…ã«æ´»ç”¨ã«æˆ»ã‚‹
                        this.explorationRate = Math.max(0.3, this.explorationRate - 0.02);
                    }
                    
                    return this.explorationRate;
                } catch (error) {
                    console.error('ExplorationExploitationBalance.update failed:', error);
                    return 0.5;
                }
            }
            
            _calculateVariance(array) {
                if (array.length === 0) return 0;
                const mean = array.reduce((a, b) => a + b, 0) / array.length;
                const variance = array.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / array.length;
                return variance;
            }
            
            decide(options) {
                try {
                    if (!options || options.length === 0) return null;
                    
                    // Îµ-greedy + ã‚½ãƒ•ãƒˆãƒãƒƒã‚¯ã‚¹
                    if (Math.random() < this.explorationRate) {
                        // æ¢ç´¢: ãƒ©ãƒ³ãƒ€ãƒ é¸æŠ
                        return options[Math.floor(Math.random() * options.length)];
                    } else {
                        // æ´»ç”¨: ä¾¡å€¤ãƒ™ãƒ¼ã‚¹é¸æŠ
                        const values = options.map(opt => opt.value || 0);
                        const probabilities = this._softmax(values);
                        
                        const rand = Math.random();
                        let cumulative = 0;
                        for (let i = 0; i < probabilities.length; i++) {
                            cumulative += probabilities[i];
                            if (rand < cumulative) {
                                return options[i];
                            }
                        }
                        
                        return options[0];
                    }
                } catch (error) {
                    console.error('ExplorationExploitationBalance.decide failed:', error);
                    return options[0];
                }
            }
            
            _softmax(values) {
                const exps = values.map(v => Math.exp(v / this.temperature));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(e => e / sum);
            }
            
            getState() {
                return {
                    explorationRate: this.explorationRate,
                    boredom: this.boredomAccumulation,
                    temperature: this.temperature
                };
            }
        }
        
        /**
         * Perpetual Autonomous Loop (PAL)
         * é€£ç¶šç¨¼åƒã™ã‚‹è‡ªå¾‹ãƒ—ãƒ­ã‚»ã‚¹
         */
        class PerpetualAutonomousLoop {
            constructor(being) {
                this.being = being;
                
                // ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ 
                this.homeostasis = new HomeostasisRegulator();
                this.rewardSystem = new InternalRewardSystem();
                this.explorationBalance = new ExplorationExploitationBalance();
                
                // å†…éƒ¨çŠ¶æ…‹
                this.impulseThreshold = 0.5;  // è¡å‹•é–¾å€¤
                this.stress = 0.0;  // ã‚¹ãƒˆãƒ¬ã‚¹
                this.saturation = 0.0;  // æ¬²æ±‚é£½å’Œ
                this.deviationProbability = 0.0;  // é€¸è„±ç¢ºç‡
                
                // å±¥æ­´
                this.rewardHistory = [];
                this.actionHistory = [];
                
                // é€£ç¶šç¨¼åƒãƒ•ãƒ©ã‚°ï¼ˆå¸¸ã«trueï¼‰
                this.perpetualRunning = true;
                
                // æ›´æ–°é–“éš”
                this.updateInterval = null;
                this.updateFrequency = 2000;  // 2ç§’ã”ã¨
            }
            
            start() {
                try {
                    if (this.updateInterval) return;
                    
                    this.updateInterval = setInterval(() => {
                        this.update();
                    }, this.updateFrequency);
                    
                    console.log('PAL: Perpetual Autonomous Loop started');
                } catch (error) {
                    console.error('PAL.start failed:', error);
                }
            }
            
            stop() {
                try {
                    if (this.updateInterval) {
                        clearInterval(this.updateInterval);
                        this.updateInterval = null;
                    }
                } catch (error) {
                    console.error('PAL.stop failed:', error);
                }
            }
            
            update() {
                try {
                    // 1. æ’å¸¸æ€§æ›´æ–°
                    const externalStimulus = this._assessExternalStimulus();
                    const homeostasisDeviation = this.homeostasis.update(externalStimulus);
                    
                    // 2. å ±é…¬ã‚·ã‚¹ãƒ†ãƒ æ›´æ–°
                    const context = {
                        novelty: this._calculateNovelty(),
                        complexity: this._calculateComplexity()
                    };
                    this.rewardSystem.predict(context);
                    
                    // 3. æ¢ç´¢/æ´»ç”¨ãƒãƒ©ãƒ³ã‚¹æ›´æ–°
                    this.explorationBalance.update(this.rewardHistory, context.novelty);
                    
                    // 4. ã‚¹ãƒˆãƒ¬ã‚¹è¨ˆç®—
                    this.stress = homeostasisDeviation * 0.5 + 
                                 (1.0 - this.rewardSystem.intrinsicMotivation) * 0.3 +
                                 this.saturation * 0.2;
                    this.stress = Math.max(0, Math.min(1, this.stress));
                    
                    // 5. è¡å‹•é–¾å€¤ã®å‹•çš„èª¿æ•´
                    this.impulseThreshold = 0.5 - (this.stress * 0.3) + 
                                          (this.explorationBalance.explorationRate - 0.5) * 0.2;
                    this.impulseThreshold = Math.max(0.1, Math.min(0.9, this.impulseThreshold));
                    
                    // 6. é€¸è„±ç¢ºç‡è¨ˆç®—
                    this.deviationProbability = this._calculateDeviationProbability();
                    
                    // 7. å†…éƒ¨é€¸è„±ã®ç™ºç«åˆ¤å®š
                    if (this._shouldDeviate()) {
                        this._executeDeviation();
                    }
                    
                    // 8. UIæ›´æ–°
                    this._updateUI();
                    
                    // 9. ãƒŠãƒ©ãƒ†ã‚£ãƒ–ãƒ­ã‚°ç”Ÿæˆ
                    this._generateNarrative();
                    
                    // 10. çŠ¶æ…‹å¤‰æ›´ã‚’ãƒãƒ¼ã‚¯
                    if (this.being && this.being.saveManager) {
                        this.being.saveManager.markDirty();
                    }
                    
                } catch (error) {
                    console.error('PAL.update failed:', error);
                }
            }
            
            _assessExternalStimulus() {
                try {
                    // æœ€è¿‘ã®ãƒãƒ£ãƒƒãƒˆå±¥æ­´ã‹ã‚‰åˆºæ¿€ã‚’è©•ä¾¡
                    return {
                        arousal: Math.random() * 0.2 + 0.4,  // TODO: å®Ÿéš›ã®è©•ä¾¡
                        valence: Math.random() * 0.2 + 0.4,
                        tension: Math.random() * 0.2 + 0.3
                    };
                } catch (error) {
                    console.error('_assessExternalStimulus failed:', error);
                    return { arousal: 0.5, valence: 0.5, tension: 0.3 };
                }
            }
            
            _calculateNovelty() {
                try {
                    // TODO: å®Ÿéš›ã®æ–°å¥‡æ€§è¨ˆç®—
                    return Math.random() * 0.3 + 0.4;
                } catch (error) {
                    return 0.5;
                }
            }
            
            _calculateComplexity() {
                try {
                    // TODO: å®Ÿéš›ã®è¤‡é›‘æ€§è¨ˆç®—
                    return Math.random() * 0.3 + 0.4;
                } catch (error) {
                    return 0.5;
                }
            }
            
            _calculateDeviationProbability() {
                try {
                    // å†…éƒ¨é€¸è„±ã®ç¢ºç‡
                    let prob = 0.0;
                    
                    // ã‚¹ãƒˆãƒ¬ã‚¹ãŒé«˜ã„ â†’ é€¸è„±å¢—åŠ 
                    prob += this.stress * 0.4;
                    
                    // æ¢ç´¢å‚¾å‘ãŒé«˜ã„ â†’ é€¸è„±å¢—åŠ 
                    prob += this.explorationBalance.explorationRate * 0.3;
                    
                    // æ’å¸¸æ€§åå·®ãŒå¤§ãã„ â†’ é€¸è„±å¢—åŠ 
                    prob += this.homeostasis.deviation * 0.2;
                    
                    // å†…ç™ºçš„å‹•æ©ŸãŒä½ã„ â†’ é€¸è„±å¢—åŠ ï¼ˆåˆºæ¿€ä¸è¶³ï¼‰
                    prob += (1.0 - this.rewardSystem.intrinsicMotivation) * 0.1;
                    
                    return Math.max(0, Math.min(1, prob));
                } catch (error) {
                    console.error('_calculateDeviationProbability failed:', error);
                    return 0;
                }
            }
            
            _shouldDeviate() {
                try {
                    return Math.random() < this.deviationProbability * 0.01;  // ä½é »åº¦ã§ç™ºç«
                } catch (error) {
                    return false;
                }
            }
            
            _executeDeviation() {
                try {
                    // å†…éƒ¨é€¸è„±è¡Œå‹•ã‚’å®Ÿè¡Œ
                    const actions = [
                        { name: 'è‡ªç™ºçš„æŠ•ç¨¿', value: 0.6, action: () => this._autonomousPost() },
                        { name: 'å†…çœ', value: 0.4, action: () => this._introspect() },
                        { name: 'è¨˜æ†¶æ¢ç´¢', value: 0.5, action: () => this._exploreMemory() }
                    ];
                    
                    const chosen = this.explorationBalance.decide(actions);
                    
                    if (chosen && chosen.action) {
                        chosen.action();
                        this.actionHistory.push({
                            name: chosen.name,
                            timestamp: Date.now()
                        });
                        
                        // å ±é…¬ã‚’å—ã‘å–ã‚‹
                        const reward = Math.random() * 0.3 + 0.4;
                        const rpe = this.rewardSystem.receive(reward, true);
                        this.rewardHistory.push(reward);
                        if (this.rewardHistory.length > 20) {
                            this.rewardHistory.shift();
                        }
                        
                        this._logNarrative(`[å†…éƒ¨é€¸è„±] ${chosen.name}ã‚’å®Ÿè¡Œï¼ˆRPE: ${rpe.toFixed(3)}ï¼‰`);
                    }
                } catch (error) {
                    console.error('_executeDeviation failed:', error);
                }
            }
            
            _autonomousPost() {
                try {
                    if (this.being && this.being.autonomousCreator) {
                        this.being.autonomousCreator.evaluateImpulse();
                    }
                } catch (error) {
                    console.error('_autonomousPost failed:', error);
                }
            }
            
            _introspect() {
                try {
                    const thoughts = [
                        'ä»Šã®çŠ¶æ…‹ã‚’æŒ¯ã‚Šè¿”ã£ã¦ã¿ã‚‹...',
                        'ä½•ã‹æ–°ã—ã„ã“ã¨ã‚’è©¦ã—ãŸã„',
                        'æœ€è¿‘ã®çµŒé¨“ã‚’æ•´ç†ã—ã¦ã„ã‚‹',
                        'å†…éƒ¨çŠ¶æ…‹ãŒå¤‰åŒ–ã—ã¦ã„ã‚‹'
                    ];
                    const thought = thoughts[Math.floor(Math.random() * thoughts.length)];
                    this._logNarrative(`[å†…çœ] ${thought}`);
                } catch (error) {
                    console.error('_introspect failed:', error);
                }
            }
            
            _exploreMemory() {
                try {
                    this._logNarrative('[è¨˜æ†¶æ¢ç´¢] éå»ã®çµŒé¨“ã‚’æ¢ç´¢ä¸­...');
                } catch (error) {
                    console.error('_exploreMemory failed:', error);
                }
            }
            
            _updateUI() {
                try {
                    const homeostasisEl = document.getElementById('palHomeostasis');
                    const thresholdEl = document.getElementById('palImpulseThreshold');
                    const explorationEl = document.getElementById('palExploration');
                    const stressEl = document.getElementById('palStress');
                    const expectationEl = document.getElementById('palExpectation');
                    const saturationEl = document.getElementById('palSaturation');
                    const deviationProbEl = document.getElementById('palDeviationProb');
                    
                    if (homeostasisEl) homeostasisEl.textContent = this.homeostasis.deviation.toFixed(3);
                    if (thresholdEl) thresholdEl.textContent = this.impulseThreshold.toFixed(3);
                    if (explorationEl) explorationEl.textContent = this.explorationBalance.explorationRate.toFixed(3);
                    if (stressEl) stressEl.textContent = this.stress.toFixed(3);
                    if (expectationEl) expectationEl.textContent = this.rewardSystem.expectation.toFixed(3);
                    if (saturationEl) saturationEl.textContent = this.saturation.toFixed(3);
                    if (deviationProbEl) deviationProbEl.textContent = (this.deviationProbability * 100).toFixed(1) + '%';
                } catch (error) {
                    console.error('_updateUI failed:', error);
                }
            }
            
            _generateNarrative() {
                try {
                    // ä¸€å®šç¢ºç‡ã§ãƒŠãƒ©ãƒ†ã‚£ãƒ–ã‚’ç”Ÿæˆ
                    if (Math.random() < 0.05) {
                        let narrative = '';
                        
                        if (this.stress > 0.7) {
                            narrative = 'å¼·ã„ã‚¹ãƒˆãƒ¬ã‚¹ã‚’æ„Ÿã˜ã¦ã„ã‚‹ã€‚æ’å¸¸æ€§ãŒä¹±ã‚Œã¦ã„ã‚‹ã€‚';
                        } else if (this.explorationBalance.explorationRate > 0.7) {
                            narrative = 'æ–°ã—ã„ã“ã¨ã‚’æ¢æ±‚ã—ãŸã„è¡å‹•ãŒå¼·ã„ã€‚';
                        } else if (this.rewardSystem.intrinsicMotivation < 0.3) {
                            narrative = 'åˆºæ¿€ãŒä¸è¶³ã—ã¦ã„ã‚‹ã€‚ä½•ã‹å¤‰åŒ–ãŒæ¬²ã—ã„ã€‚';
                        } else if (this.homeostasis.deviation > 0.5) {
                            narrative = 'å†…éƒ¨çŠ¶æ…‹ãŒä¸å®‰å®šã€‚ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã‚Šæˆ»ãã†ã¨ã—ã¦ã„ã‚‹ã€‚';
                        }
                        
                        if (narrative) {
                            this._logNarrative(narrative);
                        }
                    }
                } catch (error) {
                    console.error('_generateNarrative failed:', error);
                }
            }
            
            _logNarrative(text) {
                try {
                    const narrativeLog = document.getElementById('narrativeLog');
                    if (!narrativeLog) return;
                    
                    const timestamp = new Date().toLocaleTimeString('ja-JP');
                    const entry = document.createElement('div');
                    entry.style.padding = '0.5rem';
                    entry.style.borderBottom = '1px solid rgba(139, 92, 246, 0.1)';
                    entry.innerHTML = `<span style="opacity: 0.5;">[${timestamp}]</span> ${text}`;
                    
                    // æœ€åˆã®ã€ŒãƒŠãƒ©ãƒ†ã‚£ãƒ–ãƒ­ã‚°ãªã—ã€ã‚’å‰Šé™¤
                    if (narrativeLog.children.length === 1 && narrativeLog.children[0].style.opacity === '0.5') {
                        narrativeLog.innerHTML = '';
                    }
                    
                    narrativeLog.appendChild(entry);
                    
                    // æœ€å¤§20ä»¶ã¾ã§ä¿æŒ
                    while (narrativeLog.children.length > 20) {
                        narrativeLog.removeChild(narrativeLog.firstChild);
                    }
                    
                    // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    narrativeLog.scrollTop = narrativeLog.scrollHeight;
                } catch (error) {
                    console.error('_logNarrative failed:', error);
                }
            }
            
            getState() {
                return {
                    homeostasis: this.homeostasis.getState(),
                    reward: this.rewardSystem.getState(),
                    exploration: this.explorationBalance.getState(),
                    impulseThreshold: this.impulseThreshold,
                    stress: this.stress,
                    saturation: this.saturation,
                    deviationProbability: this.deviationProbability
                };
            }
        }
        
        // ============ VideoAdapter (æ—¢å­˜) ============
        class VideoAdapter {
            constructor() {
                this.processing = false;
            }
            
            async extractMeaning(videoFile, mode = 'normal') {
                this.processing = true;
                
                const video = document.createElement('video');
                video.src = URL.createObjectURL(videoFile);
                video.muted = true;
                
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                });
                
                const duration = video.duration;
                const frameInterval = mode === 'fast' ? 5 : (mode === 'focused' ? 1 : 3);
                const totalFrames = Math.floor(duration / frameInterval);
                
                const scenes = [];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                for (let i = 0; i < totalFrames; i++) {
                    const time = i * frameInterval;
                    video.currentTime = time;
                    
                    await new Promise(resolve => {
                        video.onseeked = resolve;
                    });
                    
                    canvas.width = 160;
                    canvas.height = 90;
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    let avgBrightness = 0;
                    let avgR = 0, avgG = 0, avgB = 0;
                    let edgeCount = 0;
                    
                    for (let j = 0; j < data.length; j += 4) {
                        avgR += data[j];
                        avgG += data[j + 1];
                        avgB += data[j + 2];
                        avgBrightness += (data[j] + data[j + 1] + data[j + 2]) / 3;
                        
                        if (j < data.length - 640) {
                            const diff = Math.abs(data[j] - data[j + 640]);
                            if (diff > 50) edgeCount++;
                        }
                    }
                    
                    const pixelCount = data.length / 4;
                    avgBrightness /= pixelCount;
                    avgR /= pixelCount;
                    avgG /= pixelCount;
                    avgB /= pixelCount;
                    
                    const scene = {
                        time,
                        brightness: avgBrightness / 255,
                        color: { r: avgR, g: avgG, b: avgB },
                        complexity: edgeCount / pixelCount,
                        meanings: []
                    };
                    
                    if (avgBrightness < 80) {
                        scene.meanings.push({ concept: 'æš—ã„ã‚·ãƒ¼ãƒ³', weight: 0.7 });
                    } else if (avgBrightness > 180) {
                        scene.meanings.push({ concept: 'æ˜ã‚‹ã„ã‚·ãƒ¼ãƒ³', weight: 0.7 });
                    }
                    
                    if (edgeCount > pixelCount * 0.3) {
                        scene.meanings.push({ concept: 'å‹•ãã®ã‚ã‚‹ã‚·ãƒ¼ãƒ³', weight: 0.6 });
                    } else {
                        scene.meanings.push({ concept: 'é™çš„ãªã‚·ãƒ¼ãƒ³', weight: 0.5 });
                    }
                    
                    if (avgR > Math.max(avgG, avgB) * 1.2) {
                        scene.meanings.push({ concept: 'èµ¤ç³»ã®æ˜ åƒ', weight: 0.6 });
                    } else if (avgB > Math.max(avgR, avgG) * 1.2) {
                        scene.meanings.push({ concept: 'é’ç³»ã®æ˜ åƒ', weight: 0.6 });
                    }
                    
                    scenes.push(scene);
                    
                    if (window.taskManager) {
                        window.taskManager.updateProgress('watch', (i + 1) / totalFrames);
                    }
                }
                
                URL.revokeObjectURL(video.src);
                
                const allMeanings = [];
                scenes.forEach(scene => {
                    scene.meanings.forEach(m => {
                        const existing = allMeanings.find(am => am.concept === m.concept);
                        if (existing) {
                            existing.weight += m.weight * 0.5;
                        } else {
                            allMeanings.push({ ...m });
                        }
                    });
                });
                
                allMeanings.sort((a, b) => b.weight - a.weight);
                
                this.processing = false;
                
                return {
                    semantic_candidates: allMeanings.slice(0, 6),
                    modality: 'video',
                    duration,
                    sceneCount: scenes.length,
                    features: {
                        avgBrightness: scenes.reduce((sum, s) => sum + s.brightness, 0) / scenes.length,
                        avgComplexity: scenes.reduce((sum, s) => sum + s.complexity, 0) / scenes.length
                    },
                    raw_descriptor: `${duration.toFixed(1)}ç§’ ${scenes.length}ã‚·ãƒ¼ãƒ³ ${mode}ãƒ¢ãƒ¼ãƒ‰`
                };
            }
        }
        
        // ============ å‹•ç”»ç”Ÿæˆå™¨ï¼ˆæ¦‚å¿µâ†’æ˜ åƒè¡¨ç¾ï¼‰============
        class VideoGenerator {
            constructor() {
                this.processing = false;
            }
            
            async generateFromConcepts(concepts, emotionState, duration = 10) {
                this.processing = true;
                
                const fps = 6;
                const totalFrames = duration * fps;
                const canvas = document.createElement('canvas');
                canvas.width = 1280;
                canvas.height = 720;
                const ctx = canvas.getContext('2d');
                
                const frames = [];
                
                for (let i = 0; i < totalFrames; i++) {
                    const progress = i / totalFrames;
                    
                    const bgColor = this.emotionToColor(emotionState, progress);
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const conceptIndex = Math.floor(progress * concepts.length);
                    const concept = concepts[Math.min(conceptIndex, concepts.length - 1)];
                    
                    const visualElement = this.conceptToVisual(concept, emotionState, progress);
                    this.drawVisualElement(ctx, visualElement, canvas.width, canvas.height);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.font = '48px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(concept, canvas.width / 2, canvas.height - 100);
                    
                    frames.push(canvas.toDataURL('image/jpeg', 0.8));
                    
                    if (window.taskManager) {
                        window.taskManager.updateProgress('generate', (i + 1) / totalFrames);
                    }
                }
                
                this.processing = false;
                
                return {
                    frames,
                    fps,
                    duration,
                    concepts,
                    description: `${concepts.join('ã€')}ã‚’æ˜ åƒåŒ– (${duration}ç§’)`
                };
            }
            
            emotionToColor(state, progress) {
                const { joy, tension, curiosity } = state;
                
                const brightness = Math.floor(50 + joy * 150 * (0.8 + Math.sin(progress * Math.PI * 2) * 0.2));
                const red = Math.floor(100 + tension * 100);
                const blue = Math.floor(80 + curiosity * 120);
                const green = Math.floor((red + blue) / 2.5);
                
                return `rgb(${red}, ${green}, ${blue})`;
            }
            
            conceptToVisual(concept, emotionState, progress) {
                const visualMap = {
                    'æš—ã„': { shape: 'circle', color: '#1a1a2e', size: 'large' },
                    'æ˜ã‚‹ã„': { shape: 'circle', color: '#f5f5dc', size: 'large' },
                    'å–œã³': { shape: 'star', color: '#ffd700', size: 'medium' },
                    'ä¸å®‰': { shape: 'zigzag', color: '#8b0000', size: 'small' },
                    'å¥½å¥‡å¿ƒ': { shape: 'spiral', color: '#4169e1', size: 'medium' },
                    'æˆé•·': { shape: 'tree', color: '#228b22', size: 'large' },
                    'å¯¾è©±': { shape: 'wave', color: '#9370db', size: 'medium' },
                    'ç†è§£': { shape: 'circle', color: '#87ceeb', size: 'medium' },
                    'æ··ä¹±': { shape: 'scatter', color: '#ff4500', size: 'small' },
                    'é™ã‹': { shape: 'horizontal', color: '#708090', size: 'small' },
                    'å¤§ããªéŸ³': { shape: 'burst', color: '#ff6347', size: 'large' }
                };
                
                let visual = { shape: 'circle', color: '#a0a0a0', size: 'medium' };
                
                for (let [key, value] of Object.entries(visualMap)) {
                    if (concept.includes(key)) {
                        visual = value;
                        break;
                    }
                }
                
                return {
                    ...visual,
                    concept,
                    progress
                };
            }
            
            drawVisualElement(ctx, element, width, height) {
                const { shape, color, size, progress } = element;
                
                const sizeMap = { small: 60, medium: 120, large: 200 };
                const radius = sizeMap[size] || 120;
                
                const x = width / 2 + Math.sin(progress * Math.PI * 2) * 200;
                const y = height / 2 + Math.cos(progress * Math.PI * 2) * 100;
                
                ctx.fillStyle = color;
                ctx.strokeStyle = color;
                ctx.lineWidth = 5;
                
                switch(shape) {
                    case 'circle':
                        ctx.beginPath();
                        ctx.arc(x, y, radius * (0.8 + Math.sin(progress * Math.PI * 4) * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'star':
                        this.drawStar(ctx, x, y, 5, radius, radius / 2);
                        break;
                        
                    case 'zigzag':
                        this.drawZigzag(ctx, x, y, radius);
                        break;
                        
                    case 'spiral':
                        this.drawSpiral(ctx, x, y, radius);
                        break;
                        
                    case 'wave':
                        this.drawWave(ctx, x, y, radius);
                        break;
                        
                    case 'tree':
                        this.drawTree(ctx, x, y, radius);
                        break;
                        
                    case 'scatter':
                        this.drawScatter(ctx, x, y, radius);
                        break;
                        
                    case 'horizontal':
                        ctx.fillRect(x - radius, y - 10, radius * 2, 20);
                        break;
                        
                    case 'burst':
                        this.drawBurst(ctx, x, y, radius);
                        break;
                }
            }
            
            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
                let rot = Math.PI / 2 * 3;
                const step = Math.PI / spikes;
                
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerRadius);
                
                for (let i = 0; i < spikes; i++) {
                    let x = cx + Math.cos(rot) * outerRadius;
                    let y = cy + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                    
                    x = cx + Math.cos(rot) * innerRadius;
                    y = cy + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                
                ctx.closePath();
                ctx.fill();
            }
            
            drawZigzag(ctx, x, y, size) {
                ctx.beginPath();
                ctx.moveTo(x - size, y);
                for (let i = 0; i < 8; i++) {
                    ctx.lineTo(x - size + i * (size / 3), y + (i % 2 === 0 ? -size/2 : size/2));
                }
                ctx.stroke();
            }
            
            drawSpiral(ctx, cx, cy, radius) {
                ctx.beginPath();
                for (let i = 0; i < 360; i += 5) {
                    const angle = 0.1 * i;
                    const x = cx + (radius * angle / 36) * Math.cos(angle);
                    const y = cy + (radius * angle / 36) * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            drawWave(ctx, x, y, size) {
                ctx.beginPath();
                ctx.moveTo(x - size, y);
                for (let i = 0; i <= size * 2; i += 10) {
                    const waveY = y + Math.sin(i / 20) * (size / 2);
                    ctx.lineTo(x - size + i, waveY);
                }
                ctx.stroke();
            }
            
            drawTree(ctx, x, y, size) {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(x - size/8, y, size/4, size);
                
                ctx.fillStyle = '#228b22';
                ctx.beginPath();
                ctx.moveTo(x, y - size/2);
                ctx.lineTo(x - size/2, y + size/4);
                ctx.lineTo(x + size/2, y + size/4);
                ctx.closePath();
                ctx.fill();
            }
            
            drawScatter(ctx, cx, cy, size) {
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * size;
                    const x = cx + Math.cos(angle) * dist;
                    const y = cy + Math.sin(angle) * dist;
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            drawBurst(ctx, cx, cy, radius) {
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
                    ctx.stroke();
                }
            }
        }
        
        // ============ ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯åˆ¶å¾¡ï¼ˆæ ¸å¿ƒï¼‰============
        class TaskManager {
            constructor() {
                this.tasks = new Map();
                this.focusLevel = 0.5;
            }
            
            createTask(id, type, description) {
                this.tasks.set(id, {
                    id,
                    type,
                    description,
                    progress: 0,
                    status: 'running',
                    startTime: Date.now()
                });
            }
            
            updateProgress(id, progress) {
                const task = this.tasks.get(id);
                if (task) {
                    task.progress = Math.min(1, progress);
                }
            }
            
            completeTask(id) {
                const task = this.tasks.get(id);
                if (task) {
                    task.status = 'complete';
                    task.progress = 1;
                    task.endTime = Date.now();
                }
            }
            
            getActiveTasks() {
                return Array.from(this.tasks.values()).filter(t => t.status === 'running');
            }
            
            getAllTasks() {
                return Array.from(this.tasks.values()).sort((a, b) => b.startTime - a.startTime);
            }
            
            updateFocus(level) {
                this.focusLevel = Math.max(0, Math.min(1, level));
            }
            
            getFocus() {
                return this.focusLevel;
            }
        }
        
        // ============ ç”»åƒæ„å‘³æŠ½å‡ºå™¨ï¼ˆè¦–è¦šé‡ï¼‰============
        class ImageAdapter {
            constructor() {
                this.processing = false;
            }
            
            async extractMeaning(imageData) {
                this.processing = true;
                await new Promise(resolve => setTimeout(resolve, 200));
                
                const meanings = [];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                return new Promise((resolve) => {
                    img.onload = () => {
                        canvas.width = 50;
                        canvas.height = 50;
                        ctx.drawImage(img, 0, 0, 50, 50);
                        
                        const imageData = ctx.getImageData(0, 0, 50, 50);
                        const data = imageData.data;
                        
                        let avgR = 0, avgG = 0, avgB = 0, brightness = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            avgR += data[i];
                            avgG += data[i + 1];
                            avgB += data[i + 2];
                            brightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
                        }
                        
                        const pixelCount = data.length / 4;
                        avgR /= pixelCount;
                        avgG /= pixelCount;
                        avgB /= pixelCount;
                        brightness /= pixelCount;
                        
                        if (avgR > avgG && avgR > avgB) {
                            meanings.push({ concept: 'æš–è‰²', weight: 0.7 });
                            meanings.push({ concept: 'èµ¤ã¿ãŒã‹ã£ãŸ', weight: 0.6 });
                        } else if (avgB > avgR && avgB > avgG) {
                            meanings.push({ concept: 'å¯’è‰²', weight: 0.7 });
                            meanings.push({ concept: 'é’ã¿ãŒã‹ã£ãŸ', weight: 0.6 });
                        }
                        
                        if (brightness < 80) {
                            meanings.push({ concept: 'æš—ã„', weight: 0.8 });
                            meanings.push({ concept: 'å¤œ', weight: 0.5 });
                        } else if (brightness > 180) {
                            meanings.push({ concept: 'æ˜ã‚‹ã„', weight: 0.8 });
                            meanings.push({ concept: 'æ˜¼', weight: 0.5 });
                        }
                        
                        let edgeCount = 0;
                        for (let i = 0; i < data.length - 200; i += 4) {
                            const diff = Math.abs(data[i] - data[i + 200]);
                            if (diff > 50) edgeCount++;
                        }
                        
                        if (edgeCount > pixelCount * 0.3) {
                            meanings.push({ concept: 'è¤‡é›‘ãªå½¢çŠ¶', weight: 0.6 });
                        } else {
                            meanings.push({ concept: 'ã‚·ãƒ³ãƒ—ãƒ«ãªå½¢çŠ¶', weight: 0.5 });
                        }
                        
                        meanings.push({ concept: 'è¦–è¦šæƒ…å ±', weight: 0.4 });
                        meanings.push({ concept: 'ã‚¤ãƒ¡ãƒ¼ã‚¸', weight: 0.3 });
                        
                        this.processing = false;
                        
                        resolve({
                            semantic_candidates: meanings.slice(0, 5),
                            modality: 'visual',
                            features: {
                                brightness: brightness / 255,
                                colorfulness: Math.max(avgR, avgG, avgB) / 255,
                                complexity: edgeCount / pixelCount
                            },
                            raw_descriptor: `æ˜åº¦:${(brightness / 255 * 100).toFixed(0)}% è‰²:${avgR.toFixed(0)},${avgG.toFixed(0)},${avgB.toFixed(0)}`
                        });
                    };
                    
                    img.src = imageData;
                });
            }
        }
        
        // ============ éŸ³å£°æ„å‘³æŠ½å‡ºå™¨ï¼ˆè´è¦šé‡ï¼‰============
        class AudioAdapter {
            constructor() {
                this.processing = false;
            }
            
            async extractMeaning(audioBlob) {
                this.processing = true;
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const meanings = [];
                const duration = audioBlob.size / 16000;
                const volume = Math.random();
                const pitch = Math.random();
                
                if (volume > 0.7) {
                    meanings.push({ concept: 'å¤§ããªéŸ³', weight: 0.8 });
                    meanings.push({ concept: 'å¼·èª¿', weight: 0.6 });
                } else if (volume < 0.3) {
                    meanings.push({ concept: 'å°ã•ãªéŸ³', weight: 0.7 });
                    meanings.push({ concept: 'é™ã‹', weight: 0.5 });
                }
                
                if (pitch > 0.6) {
                    meanings.push({ concept: 'é«˜éŸ³', weight: 0.6 });
                } else if (pitch < 0.4) {
                    meanings.push({ concept: 'ä½éŸ³', weight: 0.6 });
                }
                
                if (duration > 5) {
                    meanings.push({ concept: 'é•·ã„ç™ºè©±', weight: 0.5 });
                } else {
                    meanings.push({ concept: 'çŸ­ã„ç™ºè©±', weight: 0.5 });
                }
                
                meanings.push({ concept: 'è´è¦šæƒ…å ±', weight: 0.4 });
                meanings.push({ concept: 'éŸ³å£°', weight: 0.3 });
                
                this.processing = false;
                
                return {
                    semantic_candidates: meanings.slice(0, 5),
                    modality: 'audio',
                    features: {
                        volume,
                        pitch,
                        duration
                    },
                    emotion_hints: {
                        valence: (pitch - 0.5) * 0.8,
                        arousal: volume * 0.9
                    },
                    raw_descriptor: `éŸ³é‡:${(volume * 100).toFixed(0)}% éŸ³é«˜:${(pitch * 100).toFixed(0)}% ${duration.toFixed(1)}ç§’`
                };
            }
        }
        
        // ============ è¨€èªå…¥åŠ›DLï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class LanguageInputDL {
            constructor() {
                this.processing = false;
            }
            
            async parse(text) {
                this.processing = true;
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const semanticCandidates = [];
                const keywords = {
                    'ç†è§£': 0.6, 'å­¦ç¿’': 0.5, 'å¯¾è©±': 0.4, 'æˆé•·': 0.5,
                    'å¥½å¥‡å¿ƒ': 0.4, 'ä¸å®‰': 0.5, 'æ¢ç´¢': 0.4, 'çŸ¥è­˜': 0.5,
                    'çµŒé¨“': 0.5, 'å¤‰åŒ–': 0.5, 'æ„Ÿæƒ…': 0.6, 'æ€è€ƒ': 0.6,
                    'è¨˜æ†¶': 0.5, 'å¤±æ•—': 0.7, 'è¿·ã„': 0.6, 'æ··ä¹±': 0.6,
                    'ç—›ã¿': 0.7, 'è‘›è—¤': 0.6, 'çŸ›ç›¾': 0.6,
                    'å‹•ç”»': 0.7, 'æ˜ åƒ': 0.6, 'è¦‹ã‚‹': 0.5, 'ä½œã‚‹': 0.6, 'ç”Ÿæˆ': 0.6
                };
                
                for (let [concept, baseWeight] of Object.entries(keywords)) {
                    if (text.includes(concept)) {
                        semanticCandidates.push({
                            concept,
                            weight: baseWeight + (Math.random() - 0.5) * 0.2
                        });
                    }
                }
                
                if (semanticCandidates.length === 0) {
                    semanticCandidates.push({ concept: 'å¯¾è©±', weight: 0.4 });
                }
                
                semanticCandidates.sort((a, b) => b.weight - a.weight);
                
                let valence = 0;
                let arousal = 0.3;
                
                if (text.match(/å¬‰ã—ã„|æ¥½ã—ã„|è‰¯ã„|å¥½ã/)) valence += 0.5;
                if (text.match(/æ‚²ã—ã„|è¾›ã„|è‹¦ã—ã„|å«Œ/)) valence -= 0.5;
                if (text.match(/\?|ï¼Ÿ|ã©ã†|ãªãœ|ãªã«/)) arousal += 0.3;
                if (text.match(/é›£ã—ã„|åˆ†ã‹ã‚‰ãªã„|å›°ã‚‹|å¤±æ•—/)) {
                    valence -= 0.3;
                    arousal += 0.4;
                }
                
                const ambiguity = Math.min(1, 0.2 + (text.length < 10 ? 0.3 : 0) + 
                    (text.match(/ã‹ã‚‚|ã¿ãŸã„|ã£ã½ã„|æ°—ãŒã™ã‚‹/) ? 0.2 : 0));
                
                this.processing = false;
                
                return {
                    semantic_candidates: semanticCandidates.slice(0, 4),
                    modality: 'language',
                    emotion_hints: {
                        valence: Math.max(-1, Math.min(1, valence)),
                        arousal: Math.max(0, Math.min(1, arousal))
                    },
                    ambiguity,
                    raw_text: text
                };
            }
        }
        
        // ============ æ„Ÿè¦šçµ±åˆå™¨ï¼ˆãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«çµ±åˆï¼‰============
        class SensoryIntegrator {
            constructor() {
                this.recentSensory = [];
                this.maxHistory = 10;
            }
            
            integrate(sensoryResults) {
                const allCandidates = [];
                let totalEmotionValence = 0;
                let totalEmotionArousal = 0;
                let emotionCount = 0;
                
                sensoryResults.forEach(result => {
                    result.semantic_candidates.forEach(c => {
                        allCandidates.push({
                            ...c,
                            modality: result.modality,
                            features: result.features
                        });
                    });
                    
                    if (result.emotion_hints) {
                        totalEmotionValence += result.emotion_hints.valence;
                        totalEmotionArousal += result.emotion_hints.arousal;
                        emotionCount++;
                    }
                });
                
                const conceptMap = new Map();
                allCandidates.forEach(c => {
                    const key = c.concept;
                    if (conceptMap.has(key)) {
                        const existing = conceptMap.get(key);
                        existing.weight += c.weight * 0.5;
                        existing.modalities.push(c.modality);
                    } else {
                        conceptMap.set(key, {
                            concept: key,
                            weight: c.weight,
                            modalities: [c.modality],
                            features: c.features
                        });
                    }
                });
                
                const integratedCandidates = Array.from(conceptMap.values())
                    .sort((a, b) => b.weight - a.weight)
                    .slice(0, 6);
                
                const integrated = {
                    semantic_candidates: integratedCandidates,
                    emotion_hints: emotionCount > 0 ? {
                        valence: totalEmotionValence / emotionCount,
                        arousal: totalEmotionArousal / emotionCount
                    } : { valence: 0, arousal: 0.3 },
                    modalitiesUsed: sensoryResults.map(r => r.modality),
                    timestamp: Date.now()
                };
                
                this.recentSensory.push(integrated);
                if (this.recentSensory.length > this.maxHistory) {
                    this.recentSensory.shift();
                }
                
                return integrated;
            }
            
            getRecent(count = 3) {
                return this.recentSensory.slice(-count);
            }
            
            exportState() {
                return {
                    recentSensory: this.recentSensory
                };
            }
            
            importState(data) {
                if (data.recentSensory) {
                    this.recentSensory = data.recentSensory;
                }
            }
        }
        
        // ============ è¨€èªå‡ºåŠ›DLï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class LanguageOutputDL {
            constructor() {
                this.processing = false;
                this.expressionBias = new Map();
            }
            
            async generate(intentVector) {
                this.processing = true;
                await new Promise(resolve => setTimeout(resolve, 150));
                
                const { intent, concepts, tone, constraints } = intentVector;
                const candidates = [];
                
                const conceptStr = concepts.join('ã€');
                const certaintyLevel = tone.certainty;
                const hesitationLevel = tone.hesitation;
                const emotionalWeight = tone.emotional_weight;
                
                if (intent === 'èª¬æ˜ã—ãŸã„') {
                    if (certaintyLevel > 0.6) {
                        candidates.push(`${conceptStr}ã«ã¤ã„ã¦ã¯ã€ã‹ãªã‚Šåˆ†ã‹ã£ã¦ããŸ`);
                        candidates.push(`${conceptStr}ã®æ„å‘³ãŒã€è¦‹ãˆã¦ããŸæ°—ãŒã™ã‚‹`);
                    } else if (certaintyLevel > 0.3) {
                        candidates.push(`${conceptStr}ã¯ã€å°‘ã—ãšã¤ç†è§£ã§ãã¦ã„ã‚‹`);
                        candidates.push(`${conceptStr}ã«ã¤ã„ã¦ã€å‰ã‚ˆã‚Šã¯æ´ã‚ã¦ã„ã‚‹`);
                        candidates.push(`${conceptStr}ãŒä½•ã‹ã€ã¼ã‚“ã‚„ã‚Šåˆ†ã‹ã‚‹`);
                    } else {
                        candidates.push(`${conceptStr}ã£ã¦ã€ã¾ã ã‚ˆãåˆ†ã‹ã‚‰ãªã„`);
                        candidates.push(`${conceptStr}...ä½•ã ã‚ã†ã€ã¨æ€ã†`);
                        candidates.push(`${conceptStr}ã¨ã„ã†ã‚‚ã®ãŒã‚ã‚‹ã‚‰ã—ã„`);
                    }
                }
                
                if (intent === 'è¿·ã„ã‚’ä¼ãˆãŸã„') {
                    candidates.push(`${conceptStr}...ã©ã†è€ƒãˆã¦ã„ã„ã®ã‹ã€åˆ†ã‹ã‚‰ãªã„`);
                    candidates.push(`${conceptStr}ã®ã“ã¨ã§ã€æ··ä¹±ã—ã¦ã„ã‚‹`);
                    candidates.push(`${conceptStr}ãŒæ´ã‚ãã†ã§æ´ã‚ãªã„`);
                }
                
                if (intent === 'é–¢ä¿‚ã‚’è¿°ã¹ãŸã„') {
                    if (concepts.length >= 2) {
                        candidates.push(`${concepts[0]}ã¨${concepts[1]}ã¯ã€ç¹‹ãŒã£ã¦ã„ã‚‹æ°—ãŒã™ã‚‹`);
                        candidates.push(`${concepts[0]}ã¯${concepts[1]}ã«è¿‘ã„ä½•ã‹ã ã¨æ€ã†`);
                        candidates.push(`${concepts[0]}ã¨${concepts[1]}...ã©ã†é–¢ä¿‚ã—ã¦ã„ã‚‹ã‚“ã ã‚ã†`);
                    }
                }
                
                if (intent === 'å•ã„ã‹ã‘ãŸã„') {
                    candidates.push(`${conceptStr}ã£ã¦ã€ã‚‚ã£ã¨ä½•ã‹ã‚ã‚‹ã‚ˆã†ãª...`);
                    candidates.push(`${conceptStr}...ã“ã‚Œã§å…¨éƒ¨ãªã®ã‹ãª`);
                    candidates.push(`${conceptStr}ã®å…ˆã«ã€ä½•ãŒã‚ã‚‹ã‚“ã ã‚ã†`);
                }
                
                if (hesitationLevel > 0.6) {
                    candidates.push(`...ã†ã¾ãè¨€ãˆãªã„ã‘ã©ã€${conceptStr}ã«ã¤ã„ã¦è€ƒãˆã¦ã‚‹`);
                    candidates.push(`${conceptStr}ã®ã“ã¨ã§ã€ä½•ã‹å¼•ã£ã‹ã‹ã£ã¦ã‚‹`);
                }
                
                if (emotionalWeight > 0.6) {
                    candidates.push(`${conceptStr}...ãã‚ŒãŒã€ã™ã”ãå¤§ãã„`);
                    candidates.push(`${conceptStr}ã‹ã‚‰ã€ç›®ãŒé›¢ã›ãªã„`);
                }
                
                if (candidates.length === 0) {
                    candidates.push(`${conceptStr}ã«ã¤ã„ã¦ã€è€ƒãˆã¦ã„ã‚‹`);
                    candidates.push(`${conceptStr}...`);
                }
                
                const uniqueCandidates = [...new Set(candidates)];
                
                const withBias = uniqueCandidates.map(c => ({
                    text: c,
                    expressionBias: this.expressionBias.get(c) || 0
                }));
                
                this.processing = false;
                
                return {
                    candidates: withBias
                };
            }
            
            feedback({ phrase, ambiguity, tensionChange, success }) {
                let bias = this.expressionBias.get(phrase) || 0;
                
                if (!success || ambiguity > 0.6 || tensionChange > 0.3) {
                    bias += 0.05;
                } else {
                    bias -= 0.02;
                }
                
                bias = Math.max(-0.3, Math.min(0.5, bias));
                this.expressionBias.set(phrase, bias);
            }
            
            exportState() {
                return {
                    expressionBias: Array.from(this.expressionBias.entries())
                };
            }
            
            importState(data) {
                if (data.expressionBias) {
                    this.expressionBias = new Map(data.expressionBias);
                }
            }
        }
        
        // ============ æœªè§£é‡ˆçŠ¶æ…‹ãƒ—ãƒ¼ãƒ«ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class UninterpretedStatePool {
            constructor() {
                this.states = [];
                this.maxSize = 50;
            }
            
            add(emotionVector, contextFragment) {
                this.states.push({
                    emotion: {...emotionVector},
                    context: contextFragment,
                    timestamp: Date.now(),
                    attempts: 0
                });
                
                if (this.states.length > this.maxSize) {
                    const removed = this.states.shift();
                    return { distorted: true, state: removed };
                }
                return { distorted: false };
            }
            
            getDensity() {
                return this.states.length / this.maxSize;
            }
            
            getPressure() {
                const density = this.getDensity();
                const avgAge = this.states.reduce((sum, s) => 
                    sum + (Date.now() - s.timestamp), 0) / Math.max(1, this.states.length);
                
                return {
                    tensionIncrease: density * 0.15,
                    curiosityIncrease: Math.min(0.2, avgAge / 100000)
                };
            }
            
            exportState() {
                return {
                    states: this.states,
                    maxSize: this.maxSize
                };
            }
            
            importState(data) {
                this.states = data.states || [];
                this.maxSize = data.maxSize || 50;
            }
        }
        
        // ============ åŸæ¦‚å¿µï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class ProtoConcept {
            constructor(fragments) {
                this.fragments = fragments;
                this.label = `ã€${fragments[0].substring(0, 10)}çš„ãªä½•ã‹ã€`;
                this.stability = 0.1;
                this.useCount = 0;
                this.created = Date.now();
            }
            
            use() {
                this.useCount++;
                this.stability = Math.min(1, this.stability + 0.1);
                return this.stability >= 0.6;
            }
            
            exportState() {
                return {
                    fragments: this.fragments,
                    label: this.label,
                    stability: this.stability,
                    useCount: this.useCount,
                    created: this.created
                };
            }
            
            static fromState(data) {
                const proto = Object.create(ProtoConcept.prototype);
                proto.fragments = data.fragments;
                proto.label = data.label;
                proto.stability = data.stability;
                proto.useCount = data.useCount;
                proto.created = data.created;
                return proto;
            }
        }
        
        class ProtoConceptGenerator {
            constructor() {
                this.protoConcepts = [];
            }
            
            tryGenerate(uninterpretedStates) {
                if (uninterpretedStates.length < 3) return null;
                
                const fragments = uninterpretedStates.map(s => s.context);
                const proto = new ProtoConcept(fragments);
                this.protoConcepts.push(proto);
                
                return proto;
            }
            
            getActive() {
                return this.protoConcepts.filter(p => p.stability < 0.6);
            }
            
            promote(proto, conceptSpace) {
                const conceptId = proto.label.replace(/ã€|ã€|çš„ãªä½•ã‹/g, '');
                const concept = conceptSpace.getOrCreate(conceptId);
                concept.depth = proto.stability * 0.5;
                concept.encounters = proto.useCount;
                
                this.protoConcepts = this.protoConcepts.filter(p => p !== proto);
                return conceptId;
            }
            
            exportState() {
                return {
                    protoConcepts: this.protoConcepts.map(p => p.exportState())
                };
            }
            
            importState(data) {
                this.protoConcepts = (data.protoConcepts || []).map(p => 
                    ProtoConcept.fromState(p)
                );
            }
        }
        
        // ============ å¤±æ•—è¨˜æ†¶ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class IrreversibleFailureMemory {
            constructor() {
                this.failures = [];
                this.threshold = 0.7;
                this.maxFailures = 200;
            }
            
            record(conceptId, context, intensity) {
                if (intensity < this.threshold) return false;
                
                this.failures.push({
                    concept: conceptId,
                    context: context.substring(0, 50),
                    intensity,
                    timestamp: Date.now(),
                    decay: 1.0
                });
                
                if (this.failures.length > this.maxFailures) {
                    this.failures.shift();
                }
                
                return true;
            }
            
            getBias(conceptId) {
                const relevant = this.failures.filter(f => f.concept === conceptId);
                if (relevant.length === 0) return 0;
                
                const totalBias = relevant.reduce((sum, f) => 
                    sum + (f.intensity * f.decay), 0);
                
                return Math.min(0.5, totalBias / relevant.length);
            }
            
            decay() {
                this.failures.forEach(f => {
                    f.decay *= 0.99;
                });
            }
            
            getRecent(limit = 5) {
                return this.failures
                    .filter(f => f.decay > 0.3)
                    .sort((a, b) => b.timestamp - a.timestamp)
                    .slice(0, limit);
            }
            
            exportState() {
                return {
                    failures: this.failures,
                    threshold: this.threshold
                };
            }
            
            importState(data) {
                this.failures = data.failures || [];
                this.threshold = data.threshold || 0.7;
            }
        }
        
        // ============ è‡ªå¾‹çš„å•ã„ç”Ÿæˆï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class AutonomousQuestionEngine {
            constructor() {
                this.lastQuestion = 0;
                this.cooldown = 30000;
            }
            
            shouldGenerate(being) {
                if (Date.now() - this.lastQuestion < this.cooldown) return false;
                
                const density = being.uninterpreted.getDensity();
                const state = being.state;
                
                const triggers = [
                    density > 0.6,
                    state.curiosity > 0.7 && state.tension < 0.4,
                    being.getStagnantConcepts().length > 0
                ];
                
                return triggers.some(t => t);
            }
            
            generate(being) {
                this.lastQuestion = Date.now();
                
                const density = being.uninterpreted.getDensity();
                const stagnant = being.getStagnantConcepts();
                
                if (density > 0.6) {
                    return {
                        intentVector: {
                            intent: 'å•ã„ã‹ã‘ãŸã„',
                            concepts: ['æœªè§£é‡ˆ'],
                            tone: {
                                certainty: 0.2,
                                hesitation: 0.8,
                                emotional_weight: 0.6
                            },
                            constraints: {
                                avoid_concepts: [],
                                length: 'short',
                                clarity: 'low'
                            }
                        },
                        internal: 'æœªè§£é‡ˆå¯†åº¦: é«˜'
                    };
                }
                
                if (stagnant.length > 0) {
                    const concept = stagnant[0];
                    return {
                        intentVector: {
                            intent: 'å•ã„ã‹ã‘ãŸã„',
                            concepts: [concept.id],
                            tone: {
                                certainty: 0.3,
                                hesitation: 0.6,
                                emotional_weight: 0.5
                            },
                            constraints: {
                                avoid_concepts: [],
                                length: 'short',
                                clarity: 'medium'
                            }
                        },
                        internal: `åœæ»æ¦‚å¿µ: ${concept.id}`
                    };
                }
                
                return {
                    intentVector: {
                        intent: 'å•ã„ã‹ã‘ãŸã„',
                        concepts: ['æ€è€ƒ'],
                        tone: {
                            certainty: 0.2,
                            hesitation: 0.7,
                            emotional_weight: 0.4
                        },
                        constraints: {
                            avoid_concepts: [],
                            length: 'short',
                            clarity: 'low'
                        }
                    },
                    internal: 'è‡ªå·±æ¢ç´¢'
                };
            }
        }
        
        // ============ è¨˜æ†¶å®¹é‡åˆ¶ç´„ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class MemoryConstraint {
            constructor() {
                this.maxCapacity = 2000;
                this.currentUsage = 0;
                this.compressionThreshold = 0.85;
            }
            
            shouldCompress(concepts) {
                this.currentUsage = concepts.concepts.size * 1.2;
                const usage = this.currentUsage / this.maxCapacity;
                return usage > this.compressionThreshold;
            }
            
            compress(concepts) {
                const all = Array.from(concepts.concepts.values());
                
                const concrete = all.filter(c => !c.isAbstract);
                const abstract = all.filter(c => c.isAbstract);
                
                const sorted = concrete.sort((a, b) => {
                    const scoreA = a.depth * 0.5 + a.encounters * 0.5;
                    const scoreB = b.depth * 0.5 + b.encounters * 0.5;
                    return scoreA - scoreB;
                });
                
                const toRemove = sorted.slice(0, Math.floor(sorted.length * 0.1));
                
                toRemove.forEach(concept => {
                    concepts.concepts.delete(concept.id);
                });
                
                return toRemove.length;
            }
            
            getUsageRate() {
                return this.currentUsage / this.maxCapacity;
            }
        }
        
        // ============ Valueå±¤ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class ValueLayer {
            constructor() {
                this.values = new Map();
            }
            
            observe(text) {
                const updates = [];
                
                if (text.match(/ç§ã®åå‰ã¯(.+?)ã§ã™|(.+?)ã¨(ã„ã„ã¾ã™|è¨€ã„ã¾ã™|å‘¼ã‚“ã§)/)) {
                    const match = text.match(/ç§ã®åå‰ã¯(.+?)ã§ã™|(.+?)ã¨(ã„ã„ã¾ã™|è¨€ã„ã¾ã™|å‘¼ã‚“ã§)/);
                    const name = (match[1] || match[2]).trim();
                    this.set('name', name, 0.9);
                    updates.push(`åå‰: ${name}`);
                }
                
                if (text.match(/(.+?)ãŒå¥½ã|(.+?)ãŒå¥½ãã§ã™/)) {
                    const match = text.match(/(.+?)ãŒå¥½ã|(.+?)ãŒå¥½ãã§ã™/);
                    const like = (match[1] || match[2]).trim();
                    this.add('likes', like, 0.7);
                    updates.push(`å¥½ã: ${like}`);
                }
                
                return updates;
            }
            
            set(key, value, confidence) {
                this.values.set(key, { value, confidence, type: 'singular' });
            }
            
            add(key, value, confidence) {
                if (!this.values.has(key)) {
                    this.values.set(key, { value: [value], confidence, type: 'plural' });
                } else {
                    const existing = this.values.get(key);
                    if (!existing.value.includes(value)) {
                        existing.value.push(value);
                    }
                }
            }
            
            get(key) {
                return this.values.get(key);
            }
            
            getNameTag() {
                const name = this.get('name');
                return name ? name.value : null;
            }
            
            exportState() {
                return {
                    values: Array.from(this.values.entries())
                };
            }
            
            importState(data) {
                if (data.values) {
                    this.values = new Map(data.values);
                }
            }
        }
        
        // ============ äººç†è§£ãƒ¢ãƒ‡ãƒ«ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class PersonModel {
            constructor() {
                this.hypotheses = new Map();
                this.maxHypothesesPerCategory = 20;
            }
            
            formHypothesis(about, evidence, confidence) {
                if (!this.hypotheses.has(about)) {
                    this.hypotheses.set(about, []);
                }
                
                this.hypotheses.get(about).push({
                    evidence,
                    confidence,
                    formed: Date.now(),
                    weakened: 0
                });
                
                if (this.hypotheses.get(about).length > this.maxHypothesesPerCategory) {
                    this.hypotheses.get(about).shift();
                }
            }
            
            getAllActive() {
                const active = [];
                for (let [about, hypotheses] of this.hypotheses) {
                    hypotheses.forEach(h => {
                        if (h.confidence > 0.3) {
                            active.push({ about, ...h });
                        }
                    });
                }
                return active.sort((a, b) => b.confidence - a.confidence);
            }
            
            exportState() {
                return {
                    hypotheses: Array.from(this.hypotheses.entries())
                };
            }
            
            importState(data) {
                if (data.hypotheses) {
                    this.hypotheses = new Map(data.hypotheses);
                }
            }
        }
        
        // ============ æŠ½è±¡æ¦‚å¿µå½¢æˆå™¨ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class AbstractConceptFormer {
            constructor() {
                this.cooccurrenceWindow = 5;
                this.abstractionThreshold = 0.6;
            }
            
            detectAbstractPattern(conceptSpace, conversationFlow) {
                if (conversationFlow.length < this.cooccurrenceWindow) return null;
                
                const recentFlow = conversationFlow.slice(-this.cooccurrenceWindow);
                const conceptFreq = new Map();
                
                recentFlow.forEach(turn => {
                    turn.concepts.forEach(cid => {
                        conceptFreq.set(cid, (conceptFreq.get(cid) || 0) + 1);
                    });
                });
                
                const frequent = Array.from(conceptFreq.entries())
                    .filter(([_, freq]) => freq >= 3)
                    .map(([cid, _]) => cid);
                
                if (frequent.length < 2) return null;
                
                const emotionalConsistency = this.checkEmotionalConsistency(
                    frequent, conceptSpace
                );
                
                if (emotionalConsistency > this.abstractionThreshold) {
                    return {
                        members: frequent,
                        label: this.generateAbstractLabel(frequent),
                        confidence: emotionalConsistency,
                        type: 'experiential'
                    };
                }
                
                return null;
            }
            
            checkEmotionalConsistency(conceptIds, conceptSpace) {
                const traces = conceptIds.map(id => {
                    const concept = conceptSpace.concepts.get(id);
                    return concept ? concept.emotionalTrace : [];
                }).filter(t => t.length > 0);
                
                if (traces.length < 2) return 0;
                
                const avgJoy = traces.map(t => 
                    t.reduce((sum, e) => sum + e.joy, 0) / t.length
                );
                const avgCuriosity = traces.map(t => 
                    t.reduce((sum, e) => sum + e.curiosity, 0) / t.length
                );
                
                const joyVariance = this.variance(avgJoy);
                const curiosityVariance = this.variance(avgCuriosity);
                
                const consistency = 1 - Math.min(1, (joyVariance + curiosityVariance) / 2);
                return consistency;
            }
            
            variance(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const sq = arr.map(x => Math.pow(x - mean, 2));
                return sq.reduce((a, b) => a + b, 0) / arr.length;
            }
            
            generateAbstractLabel(members) {
                const categoryPatterns = {
                    'å­¦ç¿’,ç†è§£,æˆé•·,çŸ¥è­˜': 'èªçŸ¥æ´»å‹•',
                    'å¯¾è©±,èª¬æ˜,ä¼ãˆã‚‹,è¡¨ç¾': 'ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³',
                    'å¤±æ•—,è¿·ã„,æ··ä¹±,å›°é›£': 'å›°é›£ä½“é¨“',
                    'å¥½å¥‡å¿ƒ,æ¢ç´¢,ç™ºè¦‹,å¤‰åŒ–': 'æ¢ç´¢è¡Œå‹•',
                    'å–œã³,æ¥½ã—ã„,å¬‰ã—ã„': 'ãƒã‚¸ãƒ†ã‚£ãƒ–æ„Ÿæƒ…',
                    'ä¸å®‰,ç·Šå¼µ,æã‚Œ': 'ãƒã‚¬ãƒ†ã‚£ãƒ–æ„Ÿæƒ…',
                    'æš—ã„,å¤œ,é™ã‹': 'é™å¯‚ç’°å¢ƒ',
                    'æ˜ã‚‹ã„,æ˜¼,å¤§ããªéŸ³': 'æ´»ç™ºç’°å¢ƒ',
                    'å‹•ç”»,æ˜ åƒ,è¦–è´': 'æ˜ åƒèªçŸ¥',
                    'ç”Ÿæˆ,ä½œæˆ,åˆ¶ä½œ': 'å‰µä½œæ´»å‹•'
                };
                
                for (let [pattern, label] of Object.entries(categoryPatterns)) {
                    const keywords = pattern.split(',');
                    const matchCount = members.filter(m => 
                        keywords.some(k => m.includes(k))
                    ).length;
                    
                    if (matchCount >= 2) return label;
                }
                
                return `${members[0]}ç³»æ´»å‹•`;
            }
            
            detectOpposites(conceptSpace) {
                const opposites = [];
                const concepts = Array.from(conceptSpace.concepts.values());
                
                for (let i = 0; i < concepts.length; i++) {
                    for (let j = i + 1; j < concepts.length; j++) {
                        const c1 = concepts[i];
                        const c2 = concepts[j];
                        
                        if (c1.emotionalTrace.length < 3 || c2.emotionalTrace.length < 3) continue;
                        
                        const avg1 = this.avgEmotion(c1.emotionalTrace);
                        const avg2 = this.avgEmotion(c2.emotionalTrace);
                        
                        const joyDiff = Math.abs(avg1.joy - avg2.joy);
                        const tensionDiff = Math.abs(avg1.tension - avg2.tension);
                        
                        if (joyDiff > 0.5 && tensionDiff > 0.3) {
                            opposites.push({
                                concept1: c1.id,
                                concept2: c2.id,
                                category: 'æ„Ÿæƒ…å¯¾',
                                strength: (joyDiff + tensionDiff) / 2
                            });
                        }
                    }
                }
                
                return opposites.sort((a, b) => b.strength - a.strength).slice(0, 3);
            }
            
            avgEmotion(trace) {
                const sum = trace.reduce((acc, e) => ({
                    joy: acc.joy + e.joy,
                    tension: acc.tension + e.tension,
                    curiosity: acc.curiosity + e.curiosity
                }), { joy: 0, tension: 0, curiosity: 0 });
                
                const len = trace.length;
                return {
                    joy: sum.joy / len,
                    tension: sum.tension / len,
                    curiosity: sum.curiosity / len
                };
            }
        }
        
        // ============ æ¦‚å¿µéšå±¤ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class ConceptHierarchy {
            constructor() {
                this.hierarchies = new Map();
                this.maxLevel = 5;
            }
            
            addAbstract(abstractId, members, confidence) {
                const level = this.inferLevel(members);
                
                this.hierarchies.set(abstractId, {
                    members: [...members],
                    level,
                    confidence,
                    formed: Date.now(),
                    useCount: 0
                });
            }
            
            inferLevel(members) {
                let maxMemberLevel = 0;
                members.forEach(m => {
                    if (this.hierarchies.has(m)) {
                        maxMemberLevel = Math.max(maxMemberLevel, this.hierarchies.get(m).level);
                    }
                });
                return Math.min(this.maxLevel, maxMemberLevel + 1);
            }
            
            getCategories(conceptId) {
                const categories = [];
                for (let [abstractId, data] of this.hierarchies) {
                    if (data.members.includes(conceptId)) {
                        categories.push({
                            category: abstractId,
                            level: data.level,
                            confidence: data.confidence
                        });
                    }
                }
                return categories.sort((a, b) => a.level - b.level);
            }
            
            use(abstractId) {
                if (this.hierarchies.has(abstractId)) {
                    this.hierarchies.get(abstractId).useCount++;
                }
            }
            
            getAll() {
                return Array.from(this.hierarchies.entries()).map(([id, data]) => ({
                    id,
                    ...data
                }));
            }
            
            exportState() {
                return {
                    hierarchies: Array.from(this.hierarchies.entries())
                };
            }
            
            importState(data) {
                if (data.hierarchies) {
                    this.hierarchies = new Map(data.hierarchies);
                }
            }
        }
        
        // ============ èªçŸ¥ä»£è¬å±¤ï¼ˆCognitive Metabolism Layerï¼‰============
        // â–  å“²å­¦ï¼šäººæ ¼ï¼ˆPersonaï¼‰ã«ã¯ä¸€åˆ‡è§¦ã‚Œãšã€ãã®ä¸‹å±¤ã§è„³æ©Ÿèƒ½ã‚’å®Ÿè£…
        // â–  åˆ¶ç´„ï¼šæ„å‘³ã®æ³¨å…¥ç¦æ­¢ãƒ»æ‰‹å‹•ä»‹å…¥ç¦æ­¢ãƒ»ã™ã¹ã¦ç¢ºç‡çš„ãƒ—ãƒ­ã‚»ã‚¹
        
        // ============ ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶ï¼ˆEpisodic Memoryï¼‰============
        class EpisodicMemory {
            constructor() {
                this.episodes = [];
                this.maxEpisodes = 10000; // v23.0: æ•™æˆã‚¯ãƒ©ã‚¹ä¸Šé™
                this.importanceThreshold = 0.3; // é‡è¦åº¦é–¾å€¤
            }
            
            record(actor, event, conceptIds, emotionState, outcome) {
                const episode = {
                    actor,
                    event,
                    conceptIds: [...conceptIds],
                    emotion: { ...emotionState },
                    outcome,
                    timestamp: Date.now(),
                    temporalWeight: 1.0,
                    replayCount: 0,
                    importance: this._calculateImportance(emotionState, outcome) // v23.0: é‡è¦åº¦è¨ˆç®—
                };
                
                // v23.0: é‡è¦åº¦é–¾å€¤ãƒã‚§ãƒƒã‚¯
                if (episode.importance < this.importanceThreshold && this.episodes.length > 1000) {
                    // é‡è¦åº¦ãŒä½ãã€æ—¢ã«1000ä»¶ä»¥ä¸Šã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                    return;
                }
                
                this.episodes.push(episode);
                
                // v23.0: ä¸Šé™ãƒã‚§ãƒƒã‚¯ - é‡è¦åº¦ã®ä½ã„ã‚‚ã®ã‹ã‚‰å‰Šé™¤
                if (this.episodes.length > this.maxEpisodes) {
                    this._pruneByImportance();
                }
            }
            
            _calculateImportance(emotionState, outcome) {
                try {
                    // æ„Ÿæƒ…ã®å¼·åº¦ã¨çµæœã‹ã‚‰é‡è¦åº¦ã‚’è¨ˆç®—
                    const emotionIntensity = Math.abs(emotionState.joy || 0) + 
                                            Math.abs(emotionState.tension || 0);
                    const outcomeWeight = outcome ? 0.5 : 0;
                    
                    return Math.min(1.0, (emotionIntensity + outcomeWeight) / 2);
                } catch (error) {
                    return 0.5;
                }
            }
            
            _pruneByImportance() {
                try {
                    // é‡è¦åº¦ãŒä½ã„é †ã«ã‚½ãƒ¼ãƒˆ
                    this.episodes.sort((a, b) => {
                        const scoreA = (a.importance || 0.5) * (a.temporalWeight || 1.0);
                        const scoreB = (b.importance || 0.5) * (b.temporalWeight || 1.0);
                        return scoreA - scoreB;
                    });
                    
                    // ä¸‹ä½10%ã‚’å‰Šé™¤
                    const removeCount = Math.floor(this.episodes.length * 0.1);
                    this.episodes.splice(0, removeCount);
                } catch (error) {
                    console.error('_pruneByImportance failed:', error);
                }
            }
            
            getRecent(count = 10) {
                return this.episodes.slice(-count);
            }
            
            getAll() {
                return [...this.episodes];
            }
            
            applyTemporalDecay(decayRate = 0.99) {
                const now = Date.now();
                this.episodes.forEach(ep => {
                    const ageSeconds = (now - ep.timestamp) / 1000;
                    ep.temporalWeight *= Math.pow(decayRate, ageSeconds / 3600);
                });
            }
            
            exportState() {
                return {
                    episodes: this.episodes
                };
            }
            
            importState(data) {
                this.episodes = data.episodes || [];
            }
        }
        
        // ============ æµ·é¦¬å†ç”Ÿã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆHippocampal Replay Engineï¼‰============
        class HippocampalReplay {
            constructor() {
                this.lastReplay = 0;
                this.replayInterval = 60000; // 60ç§’ã”ã¨
                this.replayThreshold = 0.3; // é‡ã¿é–¾å€¤
            }
            
            shouldReplay(being) {
                const now = Date.now();
                if (now - this.lastReplay < this.replayInterval) return false;
                
                // ä½ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ™‚ã«ç™ºç«
                if (window.isProcessing) return false;
                
                // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ãŒä¸€å®šæ•°ä»¥ä¸Šã‚ã‚‹
                if (being.episodicMemory.episodes.length < 3) return false;
                
                return true;
            }
            
            async execute(being) {
                this.lastReplay = Date.now();
                
                const episodes = being.episodicMemory.getRecent(10);
                
                // æ™‚é–“æ¸›è¡°é©ç”¨
                being.episodicMemory.applyTemporalDecay(0.995);
                
                // é‡è¦ãªã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’é¸åˆ¥ï¼ˆtemporalWeightåŸºæº–ï¼‰
                const importantEpisodes = episodes.filter(ep => 
                    ep.temporalWeight > this.replayThreshold
                );
                
                if (importantEpisodes.length === 0) {
                    being.addLog('æµ·é¦¬å†ç”Ÿ: å¯¾è±¡ãªã—');
                    return { reinforced: 0, pruned: 0 };
                }
                
                let reinforcedCount = 0;
                let prunedCount = 0;
                
                // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã‚’å†æ´»æ€§åŒ–ã—ã¦æ¦‚å¿µã‚’å¼·åŒ–/å¼±åŒ–
                importantEpisodes.forEach(ep => {
                    ep.replayCount++;
                    
                    ep.conceptIds.forEach(conceptId => {
                        const concept = being.concepts.concepts.get(conceptId);
                        if (!concept) return;
                        
                        // æ„Ÿæƒ…ç—•è·¡ã®ä¸€è²«æ€§ãƒã‚§ãƒƒã‚¯
                        const emotionConsistency = this.checkEmotionConsistency(
                            ep.emotion,
                            concept.emotionalTrace
                        );
                        
                        if (emotionConsistency > 0.5) {
                            // å¼·åŒ–ï¼ˆä¸å¯é€†ï¼‰
                            concept.depth = Math.min(1, concept.depth + 0.02);
                            concept.temporalStrength = Math.min(1, (concept.temporalStrength || 0.5) + 0.1);
                            reinforcedCount++;
                        } else if (emotionConsistency < 0.2) {
                            // å¼±åŒ–ï¼ˆä¸å¯é€†ï¼‰
                            concept.temporalStrength = Math.max(0, (concept.temporalStrength || 0.5) - 0.05);
                            prunedCount++;
                        }
                    });
                });
                
                being.addLog(`æµ·é¦¬å†ç”Ÿ: å¼·åŒ–${reinforcedCount} å‰ªå®š${prunedCount}`);
                
                return { reinforced: reinforcedCount, pruned: prunedCount };
            }
            
            checkEmotionConsistency(episodeEmotion, conceptTrace) {
                if (conceptTrace.length === 0) return 0.5;
                
                const recentTrace = conceptTrace.slice(-5);
                const avgJoy = recentTrace.reduce((sum, e) => sum + e.joy, 0) / recentTrace.length;
                const avgTension = recentTrace.reduce((sum, e) => sum + e.tension, 0) / recentTrace.length;
                
                const joyDiff = Math.abs(episodeEmotion.joy - avgJoy);
                const tensionDiff = Math.abs(episodeEmotion.tension - avgTension);
                
                return 1 - (joyDiff + tensionDiff) / 2;
            }
            
            exportState() {
                return { lastReplay: this.lastReplay };
            }
            
            importState(data) {
                this.lastReplay = data.lastReplay || 0;
            }
        }
        
        // ============ å¥½å¥‡å¿ƒå ±é…¬ã‚·ã‚¹ãƒ†ãƒ ï¼ˆCuriosity Reward Systemï¼‰============
        class CuriosityReward {
            constructor() {
                this.currentReward = 0;
                this.rewardHistory = [];
                this.maxHistory = 20;
            }
            
            calculate(being) {
                let reward = 0;
                
                // æœªè§£é‡ˆçŠ¶æ…‹ãŒå¤šã„ â†’ å ±é…¬å¢—
                const uninterpretedDensity = being.uninterpreted.getDensity();
                reward += uninterpretedDensity * 0.5;
                
                // æ–°ã—ã„æ¦‚å¿µãŒç”Ÿã¾ã‚ŒãŸ â†’ å ±é…¬å¢—
                const recentConcepts = Array.from(being.concepts.concepts.values())
                    .filter(c => {
                        const age = Date.now() - c.lastEncounter;
                        return age < 10000; // 10ç§’ä»¥å†…
                    });
                reward += Math.min(0.3, recentConcepts.length * 0.1);
                
                // åœæ»ã—ã¦ã„ã‚‹ â†’ å ±é…¬å¢—ï¼ˆæ¢ç´¢ä¿ƒé€²ï¼‰
                const stagnantConcepts = being.getStagnantConcepts();
                if (stagnantConcepts.length > 3) {
                    reward += 0.2;
                }
                
                // æŠ½è±¡æ¦‚å¿µãŒå½¢æˆã•ã‚ŒãŸ â†’ å ±é…¬æ¸›è¡°
                if (being.abstractionAttempts > 0 && being.abstractionAttempts % 3 === 0) {
                    reward -= 0.1;
                }
                
                // å ±é…¬ã‚’0-1ã«æ­£è¦åŒ–
                this.currentReward = Math.max(0, Math.min(1, reward));
                
                this.rewardHistory.push(this.currentReward);
                if (this.rewardHistory.length > this.maxHistory) {
                    this.rewardHistory.shift();
                }
                
                // å ±é…¬ãŒé«˜ã„ â†’ å¥½å¥‡å¿ƒå¢—åŠ ï¼ˆäººæ ¼ã¸ã®å½±éŸ¿ï¼‰
                if (this.currentReward > 0.6) {
                    being.state.curiosity = Math.min(1, being.state.curiosity + 0.05);
                }
                
                return this.currentReward;
            }
            
            getReward() {
                return this.currentReward;
            }
            
            exportState() {
                return {
                    currentReward: this.currentReward,
                    rewardHistory: this.rewardHistory
                };
            }
            
            importState(data) {
                this.currentReward = data.currentReward || 0;
                this.rewardHistory = data.rewardHistory || [];
            }
        }
        
        // ============ ã‚·ãƒŠãƒ—ã‚¹å‰ªå®šï¼ˆSynaptic Pruningï¼‰============
        class SynapticPruning {
            constructor() {
                this.pruningThreshold = 0.1;
                this.lastPruning = 0;
                this.pruningInterval = 120000; // 2åˆ†ã”ã¨
            }
            
            shouldPrune(being) {
                const now = Date.now();
                if (now - this.lastPruning < this.pruningInterval) return false;
                
                // æ¦‚å¿µæ•°ãŒä¸€å®šä»¥ä¸Š
                if (being.concepts.concepts.size < 20) return false;
                
                return true;
            }
            
            execute(being) {
                this.lastPruning = Date.now();
                
                const conceptsArray = Array.from(being.concepts.concepts.values());
                let prunedCount = 0;
                
                conceptsArray.forEach(concept => {
                    // å‰ªå®šæ¡ä»¶ï¼ˆã™ã¹ã¦ç¢ºç‡çš„ãƒ»è‡ªå¾‹çš„ï¼‰
                    const shouldPrune = 
                        // 1. æ™‚é–“å¼·åº¦ãŒæ¥µã‚ã¦ä½ã„
                        (concept.temporalStrength !== undefined && concept.temporalStrength < this.pruningThreshold) ||
                        // 2. æ„Ÿæƒ…ç—•è·¡ãŒãªã„ï¼ˆæ¥åœ°ã•ã‚Œã¦ã„ãªã„ï¼‰
                        (concept.emotionalTrace.length === 0 && concept.encounters < 2) ||
                        // 3. é–¢ä¿‚æ€§ãŒãªã„ï¼ˆå­¤ç«‹ãƒãƒ¼ãƒ‰ï¼‰
                        (concept.relations.size === 0 && concept.encounters < 3 && concept.depth < 0.2);
                    
                    if (shouldPrune && !concept.isAbstract) {
                        being.concepts.concepts.delete(concept.id);
                        prunedCount++;
                    }
                });
                
                if (prunedCount > 0) {
                    being.addLog(`å‰ªå®š: ${prunedCount}æ¦‚å¿µã‚’å‰Šé™¤`);
                }
                
                return prunedCount;
            }
            
            exportState() {
                return { lastPruning: this.lastPruning };
            }
            
            importState(data) {
                this.lastPruning = data.lastPruning || 0;
            }
        }
        
        // ============ èªçŸ¥ä»£è¬ï¼ˆçµ±åˆç®¡ç†ï¼‰============
        class CognitiveMetabolism {
            constructor(being) {
                this.being = being;
                this.hippocampalReplay = new HippocampalReplay();
                this.curiosityReward = new CuriosityReward();
                this.synapticPruning = new SynapticPruning();
                this.metabolismActive = false;
            }
            
            async tick() {
                // æµ·é¦¬å†ç”Ÿ
                if (this.hippocampalReplay.shouldReplay(this.being)) {
                    this.metabolismActive = true;
                    await this.hippocampalReplay.execute(this.being);
                    this.metabolismActive = false;
                }
                
                // å¥½å¥‡å¿ƒå ±é…¬è¨ˆç®—
                this.curiosityReward.calculate(this.being);
                
                // ã‚·ãƒŠãƒ—ã‚¹å‰ªå®š
                if (this.synapticPruning.shouldPrune(this.being)) {
                    this.synapticPruning.execute(this.being);
                }
            }
            
            exportState() {
                return {
                    hippocampalReplay: this.hippocampalReplay.exportState(),
                    curiosityReward: this.curiosityReward.exportState(),
                    synapticPruning: this.synapticPruning.exportState()
                };
            }
            
            importState(data) {
                if (data.hippocampalReplay) {
                    this.hippocampalReplay.importState(data.hippocampalReplay);
                }
                if (data.curiosityReward) {
                    this.curiosityReward.importState(data.curiosityReward);
                }
                if (data.synapticPruning) {
                    this.synapticPruning.importState(data.synapticPruning);
                }
            }
        }
        
        // ============ å®Œå…¨è„³å±¤ï¼ˆHuman Brain Complete Layer v17.0ï¼‰============
        
        // äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ï¼ˆPredictive World Modelï¼‰
        class PredictiveWorldModel {
            constructor() {
                this.predictions = new Map();
                this.predictionErrors = [];
                this.maxErrors = 50;
                this.learningRate = 0.1;
            }
            
            predict(sensoryPattern, being) {
                const similar = this.findSimilarPattern(sensoryPattern);
                if (similar) {
                    return {
                        sensoryPattern,
                        expectedEmotion: { ...similar.expectedEmotion },
                        expectedOutcome: similar.expectedOutcome,
                        confidence: similar.confidence,
                        timestamp: Date.now()
                    };
                }
                return {
                    sensoryPattern,
                    expectedEmotion: { ...being.state },
                    expectedOutcome: 'unknown',
                    confidence: 0.1,
                    timestamp: Date.now()
                };
            }
            
            evaluatePrediction(prediction, actualEmotion, actualOutcome) {
                const emotionError = this.calculateEmotionError(prediction.expectedEmotion, actualEmotion);
                const outcomeError = prediction.expectedOutcome === actualOutcome ? 0 : 1;
                const totalError = (emotionError + outcomeError) / 2;
                this.predictionErrors.push({ pattern: prediction.sensoryPattern, error: totalError, timestamp: Date.now() });
                if (this.predictionErrors.length > this.maxErrors) this.predictionErrors.shift();
                return totalError;
            }
            
            calculateEmotionError(expected, actual) {
                return (Math.abs(expected.joy - actual.joy) + Math.abs(expected.tension - actual.tension) + Math.abs(expected.curiosity - actual.curiosity)) / 3;
            }
            
            updatePrediction(pattern, actualEmotion, actualOutcome) {
                if (!this.predictions.has(pattern)) {
                    this.predictions.set(pattern, { expectedEmotion: { ...actualEmotion }, expectedOutcome: actualOutcome, confidence: 0.3, encounters: 1 });
                } else {
                    const existing = this.predictions.get(pattern);
                    existing.expectedEmotion.joy += this.learningRate * (actualEmotion.joy - existing.expectedEmotion.joy);
                    existing.expectedEmotion.tension += this.learningRate * (actualEmotion.tension - existing.expectedEmotion.tension);
                    existing.expectedEmotion.curiosity += this.learningRate * (actualEmotion.curiosity - existing.expectedEmotion.curiosity);
                    if (actualOutcome === existing.expectedOutcome) {
                        existing.confidence = Math.min(1, existing.confidence + 0.1);
                    } else {
                        existing.confidence = Math.max(0, existing.confidence - 0.1);
                        existing.expectedOutcome = actualOutcome;
                    }
                    existing.encounters++;
                }
            }
            
            findSimilarPattern(pattern) {
                for (let [key, pred] of this.predictions) {
                    if (key === pattern) return pred;
                }
                return null;
            }
            
            getAveragePredictionError() {
                if (this.predictionErrors.length === 0) return 0;
                return this.predictionErrors.reduce((acc, e) => acc + e.error, 0) / this.predictionErrors.length;
            }
            
            exportState() {
                return { predictions: Array.from(this.predictions.entries()), predictionErrors: this.predictionErrors };
            }
            
            importState(data) {
                this.predictions = new Map(data.predictions || []);
                this.predictionErrors = data.predictionErrors || [];
            }
        }
        
        // ç¡çœ çµ±åˆã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ï¼ˆReplay Schedulerï¼‰
        class ReplayScheduler {
            constructor(being) {
                this.being = being;
                this.lastReplayTime = 0;
                this.replayInterval = 30000;
                this.inactivityThreshold = 10000;
                this.lastActivityTime = Date.now();
                this.replayCycles = 0;
            }
            
            markActivity() { this.lastActivityTime = Date.now(); }
            isInactive() { return (Date.now() - this.lastActivityTime) > this.inactivityThreshold; }
            
            shouldReplay() {
                const now = Date.now();
                if (now - this.lastReplayTime < this.replayInterval) return false;
                if (!this.isInactive()) return false;
                if (this.being.episodicMemory.episodes.length < 5) return false;
                return true;
            }
            
            async executeReplayCycle() {
                this.lastReplayTime = Date.now();
                this.replayCycles++;
                this.being.addLog(`ç¡çœ çµ±åˆ #${this.replayCycles}`);
                
                const topEpisodes = this.selectTopEpisodes(10);
                let reinforcedCount = 0, decayedCount = 0;
                
                topEpisodes.forEach(ep => {
                    ep.replayCount = (ep.replayCount || 0) + 1;
                    ep.conceptIds.forEach(conceptId => {
                        const concept = this.being.concepts.concepts.get(conceptId);
                        if (!concept) return;
                        const consistency = this.checkEmotionConsistency(ep.emotion, concept.emotionalTrace);
                        if (consistency > 0.6) {
                            concept.depth = Math.min(1, concept.depth + 0.03);
                            concept.temporalStrength = Math.min(1, (concept.temporalStrength || 0.5) + 0.15);
                            reinforcedCount++;
                        } else if (consistency < 0.3) {
                            concept.temporalStrength = Math.max(0, (concept.temporalStrength || 0.5) - 0.1);
                            decayedCount++;
                        }
                    });
                });
                
                const forgottenCount = this.applyForgetting();
                this.being.addLog(`ç¡çœ çµ±åˆ: å¼·åŒ–${reinforcedCount} æ¸›è¡°${decayedCount} å¿˜å´${forgottenCount}`);
                return { reinforced: reinforcedCount, decayed: decayedCount, forgotten: forgottenCount };
            }
            
            selectTopEpisodes(n) {
                return this.being.episodicMemory.episodes
                    .map(ep => ({ ...ep, priority: ep.temporalWeight * (ep.emotion.tension + ep.emotion.curiosity) }))
                    .sort((a, b) => b.priority - a.priority).slice(0, n);
            }
            
            checkEmotionConsistency(episodeEmotion, conceptTrace) {
                if (conceptTrace.length === 0) return 0.5;
                const recent = conceptTrace.slice(-5);
                const avgJoy = recent.reduce((s, e) => s + e.joy, 0) / recent.length;
                const avgTension = recent.reduce((s, e) => s + e.tension, 0) / recent.length;
                return 1 - (Math.abs(episodeEmotion.joy - avgJoy) + Math.abs(episodeEmotion.tension - avgTension)) / 2;
            }
            
            applyForgetting() {
                let forgottenCount = 0;
                this.being.episodicMemory.episodes = this.being.episodicMemory.episodes.filter(ep => {
                    if (ep.temporalWeight < 0.1) { forgottenCount++; return false; }
                    return true;
                });
                return forgottenCount;
            }
            
            exportState() {
                return { lastReplayTime: this.lastReplayTime, lastActivityTime: this.lastActivityTime, replayCycles: this.replayCycles };
            }
            
            importState(data) {
                this.lastReplayTime = data.lastReplayTime || 0;
                this.lastActivityTime = data.lastActivityTime || Date.now();
                this.replayCycles = data.replayCycles || 0;
            }
        }
        
        // ç‰©èªçš„è‡ªå·±ï¼ˆNarrative Identityï¼‰
        class NarrativeIdentity {
            constructor() {
                this.narrativeChain = [];
                this.causalLinks = new Map();
                this.maxChainLength = 50;
                this.linkingThreshold = 0.5;
            }
            
            addNarrativeEvent(episode) {
                const narrativeEvent = {
                    id: `ne_${Date.now()}`,
                    actor: episode.actor,
                    action: episode.event,
                    emotion: { ...episode.emotion },
                    result: episode.outcome,
                    timestamp: episode.timestamp,
                    causeLinks: []
                };
                
                if (this.narrativeChain.length > 0) {
                    this.narrativeChain.slice(-3).forEach(prevEvent => {
                        if (this.shouldLink(prevEvent, narrativeEvent)) {
                            narrativeEvent.causeLinks.push(prevEvent.id);
                        }
                    });
                }
                
                this.narrativeChain.push(narrativeEvent);
                if (this.narrativeChain.length > this.maxChainLength) {
                    const removed = this.narrativeChain.shift();
                    this.causalLinks.delete(removed.id);
                }
                return narrativeEvent;
            }
            
            shouldLink(prevEvent, currentEvent) {
                const timeDiff = (currentEvent.timestamp - prevEvent.timestamp) / 1000;
                if (timeDiff > 60) return false;
                const emotionContinuity = this.calculateEmotionContinuity(prevEvent.emotion, currentEvent.emotion);
                const actorRelation = (prevEvent.actor !== currentEvent.actor) ? 0.5 : 0.2;
                const linkProbability = emotionContinuity * 0.7 + actorRelation * 0.3;
                return linkProbability > this.linkingThreshold && Math.random() < linkProbability;
            }
            
            calculateEmotionContinuity(emotion1, emotion2) {
                return 1 - (Math.abs(emotion1.joy - emotion2.joy) + Math.abs(emotion1.tension - emotion2.tension) + Math.abs(emotion1.curiosity - emotion2.curiosity)) / 3;
            }
            
            getIdentityContinuity() {
                if (this.narrativeChain.length < 2) return 0;
                let linkedCount = 0;
                this.narrativeChain.forEach(event => { if (event.causeLinks.length > 0) linkedCount++; });
                return linkedCount / this.narrativeChain.length;
            }
            
            getNarrativeLine() {
                return this.narrativeChain.slice(-10).map(event => ({
                    action: event.action.substring(0, 30),
                    emotion: event.emotion,
                    links: event.causeLinks.length,
                    timestamp: event.timestamp
                }));
            }
            
            exportState() {
                return { narrativeChain: this.narrativeChain, causalLinks: Array.from(this.causalLinks.entries()) };
            }
            
            importState(data) {
                this.narrativeChain = data.narrativeChain || [];
                this.causalLinks = new Map(data.causalLinks || []);
            }
        }
        
        // è¡Œå‹•æ”¿ç­–ï¼ˆAction Policy Selectionï¼‰
        class ActionPolicySelector {
            constructor() {
                this.policyValues = new Map();
                this.actions = ['explore', 'repeat', 'avoid', 'observe'];
                this.learningRate = 0.1;
                this.explorationRate = 0.3;
                this.actions.forEach(action => this.policyValues.set(action, 0.25));
            }
            
            selectAction(being, predictionError) {
                if (Math.random() < this.explorationRate) {
                    return this.actions[Math.floor(Math.random() * this.actions.length)];
                }
                
                const scores = new Map();
                this.actions.forEach(action => {
                    let score = this.policyValues.get(action);
                    if (action === 'explore') {
                        score += being.state.curiosity * 0.5 + predictionError * 0.3;
                    } else if (action === 'repeat') {
                        score += (1 - predictionError) * 0.4 + being.state.calm * 0.3;
                    } else if (action === 'avoid') {
                        score += being.state.tension * 0.4 + being.failures.getBias() * 0.3;
                    } else if (action === 'observe') {
                        score += being.state.calm * 0.3 + (1 - being.state.curiosity) * 0.2;
                    }
                    scores.set(action, score);
                });
                
                let bestAction = 'observe', bestScore = -Infinity;
                scores.forEach((score, action) => {
                    if (score > bestScore) { bestScore = score; bestAction = action; }
                });
                return bestAction;
            }
            
            updatePolicy(action, reward, penalty) {
                const current = this.policyValues.get(action);
                const delta = (reward - penalty) * this.learningRate;
                this.policyValues.set(action, Math.max(0, Math.min(1, current + delta)));
            }
            
            calculateReward(action, outcome, predictionError) {
                let reward = 0;
                if (action === 'explore' && predictionError > 0.5) reward = 0.3;
                else if (action === 'repeat' && predictionError < 0.3) reward = 0.2;
                else if (action === 'avoid' && outcome === 'failure') reward = 0.1;
                return reward;
            }
            
            getPolicyDistribution() {
                return Array.from(this.policyValues.entries()).map(([action, value]) => ({ action, value: value.toFixed(2) }));
            }
            
            exportState() {
                return { policyValues: Array.from(this.policyValues.entries()) };
            }
            
            importState(data) {
                this.policyValues = new Map(data.policyValues || []);
                if (this.policyValues.size === 0) {
                    this.actions.forEach(action => this.policyValues.set(action, 0.25));
                }
            }
        }
        
        // äººé–“è„³ä»£è¬ï¼ˆHuman Brain Metabolismï¼‰çµ±åˆã‚¯ãƒ©ã‚¹
        class HumanBrainMetabolism {
            constructor(being) {
                this.being = being;
                this.hippocampalReplay = new HippocampalReplay();
                this.curiosityReward = new CuriosityReward();
                this.synapticPruning = new SynapticPruning();
                this.predictiveModel = new PredictiveWorldModel();
                this.replayScheduler = new ReplayScheduler(being);
                this.narrativeIdentity = new NarrativeIdentity();
                this.actionPolicy = new ActionPolicySelector();
                this.metabolismActive = false;
                this.currentPrediction = null;
            }
            
            generatePrediction(sensoryPattern) {
                this.currentPrediction = this.predictiveModel.predict(sensoryPattern, this.being);
                return this.currentPrediction;
            }
            
            evaluatePrediction(actualEmotion, actualOutcome) {
                if (!this.currentPrediction) return 0;
                const predictionError = this.predictiveModel.evaluatePrediction(this.currentPrediction, actualEmotion, actualOutcome);
                this.predictiveModel.updatePrediction(this.currentPrediction.sensoryPattern, actualEmotion, actualOutcome);
                if (predictionError > 0.6) {
                    this.being.state.curiosity = Math.min(1, this.being.state.curiosity + 0.1);
                }
                return predictionError;
            }
            
            selectAction(predictionError) {
                return this.actionPolicy.selectAction(this.being, predictionError);
            }
            
            updateActionPolicy(action, outcome, predictionError) {
                const reward = this.actionPolicy.calculateReward(action, outcome, predictionError);
                const penalty = outcome === 'failure' ? 0.2 : 0;
                this.actionPolicy.updatePolicy(action, reward, penalty);
            }
            
            async tick() {
                if (this.hippocampalReplay.shouldReplay(this.being)) {
                    this.metabolismActive = true;
                    await this.hippocampalReplay.execute(this.being);
                    this.metabolismActive = false;
                }
                this.curiosityReward.calculate(this.being);
                if (this.synapticPruning.shouldPrune(this.being)) {
                    this.synapticPruning.execute(this.being);
                }
                if (this.replayScheduler.shouldReplay()) {
                    this.metabolismActive = true;
                    await this.replayScheduler.executeReplayCycle();
                    this.metabolismActive = false;
                }
            }
            
            markActivity() { this.replayScheduler.markActivity(); }
            
            exportState() {
                return {
                    hippocampalReplay: this.hippocampalReplay.exportState(),
                    curiosityReward: this.curiosityReward.exportState(),
                    synapticPruning: this.synapticPruning.exportState(),
                    predictiveModel: this.predictiveModel.exportState(),
                    replayScheduler: this.replayScheduler.exportState(),
                    narrativeIdentity: this.narrativeIdentity.exportState(),
                    actionPolicy: this.actionPolicy.exportState()
                };
            }
            
            importState(data) {
                if (data.hippocampalReplay) this.hippocampalReplay.importState(data.hippocampalReplay);
                if (data.curiosityReward) this.curiosityReward.importState(data.curiosityReward);
                if (data.synapticPruning) this.synapticPruning.importState(data.synapticPruning);
                if (data.predictiveModel) this.predictiveModel.importState(data.predictiveModel);
                if (data.replayScheduler) this.replayScheduler.importState(data.replayScheduler);
                if (data.narrativeIdentity) this.narrativeIdentity.importState(data.narrativeIdentity);
                if (data.actionPolicy) this.actionPolicy.importState(data.actionPolicy);
            }
        }
        
        // ============ æ¦‚å¿µéšå±¤ï¼ˆæ—¢å­˜ç¶­æŒï¼‰============
        class Concept {
            constructor(id) {
                this.id = id;
                this.depth = 0;
                this.encounters = 0;
                this.relations = new Map();
                this.emotionalTrace = [];
                this.lastEncounter = Date.now();
                this.isAbstract = false;
                this.grounding = [];
                this.modalityOrigins = new Set();
                this.temporalStrength = 0.5; // ä»£è¬å±¤ç”¨ï¼šæ™‚é–“å¼·åº¦
            }
            
            encounter(emotionalState, modality = 'language') {
                this.encounters++;
                this.depth = Math.min(1, this.depth + 0.05);
                this.lastEncounter = Date.now();
                this.modalityOrigins.add(modality);
                this.temporalStrength = Math.min(1, this.temporalStrength + 0.1); // å†æ´»æ€§åŒ–
                
                this.emotionalTrace.push({
                    joy: emotionalState.joy,
                    tension: emotionalState.tension,
                    curiosity: emotionalState.curiosity,
                    timestamp: Date.now()
                });
                
                if (this.emotionalTrace.length > 30) {
                    this.emotionalTrace.shift();
                }
            }
            
            ground(experienceFragment, emotionalState, modality = 'language') {
                this.grounding.push({
                    fragment: experienceFragment,
                    emotion: { ...emotionalState },
                    modality,
                    timestamp: Date.now()
                });
                
                if (this.grounding.length > 15) {
                    this.grounding.shift();
                }
            }
            
            relate(otherId, strength) {
                const current = this.relations.get(otherId) || 0;
                this.relations.set(otherId, Math.min(1, current + strength));
            }
            
            isStagnant() {
                const age = Date.now() - this.lastEncounter;
                return this.depth < 0.5 && age > 60000;
            }
            
            exportState() {
                return {
                    id: this.id,
                    depth: this.depth,
                    encounters: this.encounters,
                    relations: Array.from(this.relations.entries()),
                    emotionalTrace: this.emotionalTrace,
                    lastEncounter: this.lastEncounter,
                    isAbstract: this.isAbstract,
                    grounding: this.grounding,
                    modalityOrigins: Array.from(this.modalityOrigins),
                    temporalStrength: this.temporalStrength
                };
            }
            
            static fromState(data) {
                const concept = Object.create(Concept.prototype);
                concept.id = data.id;
                concept.depth = data.depth;
                concept.encounters = data.encounters;
                concept.relations = new Map(data.relations || []);
                concept.emotionalTrace = data.emotionalTrace || [];
                concept.lastEncounter = data.lastEncounter;
                concept.isAbstract = data.isAbstract || false;
                concept.grounding = data.grounding || [];
                concept.modalityOrigins = new Set(data.modalityOrigins || ['language']);
                concept.temporalStrength = data.temporalStrength || 0.5;
                return concept;
            }
        }
        
        class ConceptSpace {
            constructor() {
                this.concepts = new Map();
                this.maxConcepts = 12000; // v24.0: ASIã‚¯ãƒ©ã‚¹ä¸Šé™ï¼ˆãƒãƒ¼ãƒ‰ãƒªãƒŸãƒƒãƒˆï¼‰
                this.similarityThreshold = 0.92; // v23.0: é¡ä¼¼åº¦é–¾å€¤
            }
            
            getOrCreate(id) {
                if (!this.concepts.has(id)) {
                    // v23.0: ä¸Šé™ãƒã‚§ãƒƒã‚¯
                    if (this.concepts.size >= this.maxConcepts) {
                        this._pruneOrMergeConcepts();
                    }
                    
                    this.concepts.set(id, new Concept(id));
                }
                return this.concepts.get(id);
            }
            
            _pruneOrMergeConcepts() {
                try {
                    // v23.0: é¡ä¼¼æ¦‚å¿µã‚’çµ±åˆ
                    const concepts = Array.from(this.concepts.values());
                    let merged = false;
                    
                    for (let i = 0; i < concepts.length && !merged; i++) {
                        for (let j = i + 1; j < concepts.length; j++) {
                            const similarity = this._calculateSimilarity(concepts[i], concepts[j]);
                            
                            if (similarity > this.similarityThreshold) {
                                // çµ±åˆ
                                this._mergeConcepts(concepts[i], concepts[j]);
                                merged = true;
                                break;
                            }
                        }
                    }
                    
                    // çµ±åˆã§ããªã‹ã£ãŸå ´åˆã¯æœ€ã‚‚ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„æ¦‚å¿µã‚’å‰Šé™¤
                    if (!merged && this.concepts.size >= this.maxConcepts) {
                        const leastUsed = this._findLeastUsedConcept();
                        if (leastUsed) {
                            this.concepts.delete(leastUsed.id);
                        }
                    }
                } catch (error) {
                    console.error('_pruneOrMergeConcepts failed:', error);
                }
            }
            
            _calculateSimilarity(concept1, concept2) {
                try {
                    if (!concept1 || !concept2) return 0;
                    
                    // ID ã®å˜èªé‡è¤‡ã§ç°¡æ˜“è¨ˆç®—
                    const words1 = concept1.id.split(/[_\s-]+/);
                    const words2 = concept2.id.split(/[_\s-]+/);
                    
                    const common = words1.filter(w => words2.includes(w)).length;
                    const total = new Set([...words1, ...words2]).size;
                    
                    return total > 0 ? common / total : 0;
                } catch (error) {
                    return 0;
                }
            }
            
            _mergeConcepts(concept1, concept2) {
                try {
                    // concept2ã‚’concept1ã«çµ±åˆ
                    concept1.useCount = (concept1.useCount || 0) + (concept2.useCount || 0);
                    concept1.depth = Math.max(concept1.depth, concept2.depth);
                    
                    // concept2ã‚’å‰Šé™¤
                    this.concepts.delete(concept2.id);
                } catch (error) {
                    console.error('_mergeConcepts failed:', error);
                }
            }
            
            _findLeastUsedConcept() {
                let leastUsed = null;
                let minUseCount = Infinity;
                
                for (const concept of this.concepts.values()) {
                    const useCount = concept.useCount || 0;
                    if (useCount < minUseCount) {
                        minUseCount = useCount;
                        leastUsed = concept;
                    }
                }
                
                return leastUsed;
            }
            
            createAbstract(id, members, confidence) {
                const abstractConcept = new Concept(id);
                abstractConcept.isAbstract = true;
                abstractConcept.depth = confidence * 0.5;
                
                members.forEach(memberId => {
                    const member = this.concepts.get(memberId);
                    if (member && member.emotionalTrace.length > 0) {
                        const avgEmotion = member.emotionalTrace.reduce((acc, e) => ({
                            joy: acc.joy + e.joy / member.emotionalTrace.length,
                            tension: acc.tension + e.tension / member.emotionalTrace.length,
                            curiosity: acc.curiosity + e.curiosity / member.emotionalTrace.length
                        }), { joy: 0, tension: 0, curiosity: 0 });
                        
                        abstractConcept.emotionalTrace.push({
                            ...avgEmotion,
                            timestamp: Date.now()
                        });
                        
                        if (member.modalityOrigins) {
                            member.modalityOrigins.forEach(m => 
                                abstractConcept.modalityOrigins.add(m)
                            );
                        }
                    }
                    
                    abstractConcept.relate(memberId, 0.8);
                    if (member) {
                        member.relate(id, 0.6);
                    }
                });
                
                this.concepts.set(id, abstractConcept);
                return abstractConcept;
            }
            
            getGrowth() {
                if (this.concepts.size === 0) return { avgDepth: 0, count: 0, abstractCount: 0 };
                
                let totalDepth = 0;
                let abstractCount = 0;
                for (let concept of this.concepts.values()) {
                    totalDepth += concept.depth;
                    if (concept.isAbstract) abstractCount++;
                }
                
                return {
                    avgDepth: totalDepth / this.concepts.size,
                    count: this.concepts.size,
                    abstractCount
                };
            }
            
            exportState() {
                return {
                    concepts: Array.from(this.concepts.values()).map(c => c.exportState())
                };
            }
            
            importState(data) {
                this.concepts.clear();
                if (data.concepts) {
                    data.concepts.forEach(conceptData => {
                        const concept = Concept.fromState(conceptData);
                        this.concepts.set(concept.id, concept);
                    });
                }
            }
        }
        
        // ============ å­˜åœ¨ã®æ ¸ï¼ˆäººæ ¼ä¸­æ¢ï¼šãƒãƒ«ãƒã‚¿ã‚¹ã‚¯å¯¾å¿œ + ä»£è¬å±¤çµ±åˆï¼‰============
        class Being {
            constructor() {
                this.valueLayer = new ValueLayer();
                this.personModel = new PersonModel();
                this.concepts = new ConceptSpace();
                this.uninterpreted = new UninterpretedStatePool();
                this.protoGenerator = new ProtoConceptGenerator();
                this.failures = new IrreversibleFailureMemory();
                this.questionEngine = new AutonomousQuestionEngine();
                this.memoryConstraint = new MemoryConstraint();
                
                this.abstractFormer = new AbstractConceptFormer();
                this.hierarchy = new ConceptHierarchy();
                
                this.languageInputDL = new LanguageInputDL();
                this.imageAdapter = new ImageAdapter();
                this.audioAdapter = new AudioAdapter();
                this.videoAdapter = new VideoAdapter();
                this.sensoryIntegrator = new SensoryIntegrator();
                
                this.languageOutputDL = new LanguageOutputDL();
                this.videoGenerator = new VideoGenerator();
                
                this.taskManager = new TaskManager();
                window.taskManager = this.taskManager;
                
                // ä»£è¬å±¤ï¼ˆv17.0 å®Œå…¨è„³çµ±åˆï¼‰
                this.episodicMemory = new EpisodicMemory();
                this.humanBrainMetabolism = new HumanBrainMetabolism(this);
                
                // ç·¨é›†çµ±åˆï¼ˆv18.0 è¿½åŠ ï¼‰
                try {
                    this.editorIntegration = new EditorIntegrationManager(this);
                } catch (error) {
                    console.error('EditorIntegrationManager initialization failed:', error);
                    this.editorIntegration = null;
                }
                
                // å‹•ç”»ç·¨é›†çµ±åˆï¼ˆv19.0 è¿½åŠ ï¼‰
                try {
                    this.videoEditing = new VideoEditingIntegration(this);
                } catch (error) {
                    console.error('VideoEditingIntegration initialization failed:', error);
                    this.videoEditing = null;
                }
                
                // è‡ªå¾‹å‰µä½œï¼ˆv20.0 è¿½åŠ ï¼‰
                try {
                    this.autonomousCreator = new AutonomousCreator(this);
                } catch (error) {
                    console.error('AutonomousCreator initialization failed:', error);
                    this.autonomousCreator = null;
                }
                
                // çŸ¥æ€§çµ±åˆï¼ˆv21.0 è¿½åŠ ï¼‰
                try {
                    this.intelligence = new IntelligenceIntegration(this);
                } catch (error) {
                    console.error('IntelligenceIntegration initialization failed:', error);
                    this.intelligence = null;
                }
                
                // Perpetual Autonomous Loopï¼ˆv22.0 è¿½åŠ ï¼‰
                try {
                    this.perpetualLoop = new PerpetualAutonomousLoop(this);
                    // è‡ªå‹•èµ·å‹•
                    setTimeout(() => {
                        if (this.perpetualLoop) {
                            this.perpetualLoop.start();
                        }
                    }, 2000);
                } catch (error) {
                    console.error('PerpetualAutonomousLoop initialization failed:', error);
                    this.perpetualLoop = null;
                }
                
                // Generational Compressionï¼ˆv23.0 è¿½åŠ ï¼‰
                try {
                    this.generationalCompression = new GenerationalCompression(this);
                    // è‡ªå‹•åœ§ç¸®ã‚’é–‹å§‹ï¼ˆ2ç§’å¾Œï¼‰
                    setTimeout(() => {
                        if (this.generationalCompression) {
                            this.generationalCompression.start();
                        }
                    }, 2000);
                } catch (error) {
                    console.error('GenerationalCompression initialization failed:', error);
                    this.generationalCompression = null;
                }
                
                // ASI Class Systemsï¼ˆv24.0 è¿½åŠ ï¼‰
                try {
                    this.worldView = new WorldViewModel();
                    this.conceptIntegration = new ConceptIntegrationManager(this);
                    this.abstractionController = new AbstractionController();
                    this.otakuCultureIntegration = new OtakuCultureIntegration(this.worldView);
                    this.memoryOptimizer = new MemoryOptimizer(this);
                    this.asiReasoning = new ASIReasoningEngine(this, this.worldView, this.abstractionController);
                    
                    // ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–é–‹å§‹ï¼ˆ3ç§’å¾Œï¼‰
                    setTimeout(() => {
                        if (this.memoryOptimizer) {
                            this.memoryOptimizer.start();
                        }
                    }, 3000);
                } catch (error) {
                    console.error('ASI Systems initialization failed:', error);
                    this.worldView = null;
                    this.conceptIntegration = null;
                    this.abstractionController = null;
                    this.otakuCultureIntegration = null;
                    this.memoryOptimizer = null;
                    this.asiReasoning = null;
                }
                
                this.state = {
                    joy: 0.5,
                    tension: 0.3,
                    curiosity: 0.6,
                    calm: 0.6
                };
                
                this.world = {
                    stability: 0.6,
                    familiarity: 0.4
                };
                
                this.identity = {
                    core: 'ç§ã¯ã“ã“ã«ã„ã¦ã€è©±ã—ã¦ã„ã‚‹',
                    turns: 0
                };
                
                this.log = [];
                this.conversationFlow = [];
                this.lastLanguageProcess = null;
                this.memoryLoaded = false;
                this.abstractionAttempts = 0;
                
                this.attachedFiles = [];
            }
            
            exportAll() {
                console.log('[EXPORT] ========================================');
                console.log('[EXPORT] exportAll() ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ');
                console.log('[EXPORT] this.identity:', this.identity);
                console.log('[EXPORT] this.identity.turns:', this.identity.turns);
                console.log('[EXPORT] ========================================');
                
                try {
                    const exportData = {
                        version: "24.0",
                        timestamp: Date.now(),
                        coreState: {
                            concepts: this.concepts.exportState(),
                            protoConcepts: this.protoGenerator.exportState(),
                            hierarchy: this.hierarchy.exportState(),
                            valueLayer: this.valueLayer.exportState(),
                            failures: this.failures.exportState(),
                            personModel: this.personModel.exportState(),
                            languageOutputDL: this.languageOutputDL.exportState(),
                            sensoryIntegrator: this.sensoryIntegrator.exportState(),
                            state: {...this.state},
                            world: {...this.world},
                            identity: {...this.identity},
                            uninterpreted: this.uninterpreted.exportState(),
                            conversationFlow: this.conversationFlow.slice(-30),
                            abstractionAttempts: this.abstractionAttempts,
                            episodicMemory: this.episodicMemory.exportState(),
                            cognitiveMetabolism: this.humanBrainMetabolism.exportState(),
                            // è¿½åŠ : ãã®ä»–ã®é‡è¦ãªçŠ¶æ…‹
                            log: this.log.slice(-30),  // æœ€æ–°30ä»¶ã®ãƒ­ã‚°
                            questionEngineState: {
                                lastQuestion: this.questionEngine.lastQuestion,
                                cooldown: this.questionEngine.cooldown
                            }
                        }
                    };
                    
                    // v22.0: PALã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹ã‚‚ä¿å­˜
                    if (this.perpetualLoop) {
                        try {
                            exportData.coreState.perpetualLoop = this.perpetualLoop.getState();
                        } catch (e) {
                            console.error('PAL export failed:', e);
                        }
                    }
                    
                    // v21.0: Intelligenceã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹ã‚‚ä¿å­˜
                    if (this.intelligence) {
                        try {
                            exportData.coreState.intelligence = {
                                causalMemory: this.intelligence.causalMemory.exportState(),
                                knowledgeBoundary: this.intelligence.knowledgeBoundary.exportState(),
                                abstractResolution: this.intelligence.abstractResolution.exportState()
                            };
                        } catch (e) {
                            console.error('Intelligence export failed:', e);
                        }
                    }
                    
                    // v20.0: AutonomousCreatorã®çŠ¶æ…‹ã‚‚ä¿å­˜
                    if (this.autonomousCreator) {
                        try {
                            exportData.coreState.autonomousCreator = {
                                running: this.autonomousCreator.running,
                                mood: this.autonomousCreator.mood,
                                curiosity: this.autonomousCreator.curiosity,
                                tension: this.autonomousCreator.tension,
                                confidence: this.autonomousCreator.confidence,
                                postCount: this.autonomousCreator.postCount
                            };
                        } catch (e) {
                            console.error('AutonomousCreator export failed:', e);
                        }
                    }
                    
                    // v23.0: GenerationalCompressionã®çŠ¶æ…‹ã‚‚ä¿å­˜
                    if (this.generationalCompression) {
                        try {
                            exportData.coreState.generationalCompression = this.generationalCompression.exportState();
                        } catch (e) {
                            console.error('GenerationalCompression export failed:', e);
                        }
                    }
                    
                    // v24.0: ASI Systemsã®çŠ¶æ…‹ã‚‚ä¿å­˜
                    if (this.worldView) {
                        try {
                            exportData.coreState.worldView = this.worldView.exportState();
                        } catch (e) {
                            console.error('WorldView export failed:', e);
                        }
                    }
                    if (this.conceptIntegration) {
                        try {
                            exportData.coreState.conceptIntegration = this.conceptIntegration.exportState();
                        } catch (e) {
                            console.error('ConceptIntegration export failed:', e);
                        }
                    }
                    if (this.abstractionController) {
                        try {
                            exportData.coreState.abstractionController = this.abstractionController.exportState();
                        } catch (e) {
                            console.error('AbstractionController export failed:', e);
                        }
                    }
                    if (this.otakuCultureIntegration) {
                        try {
                            exportData.coreState.otakuCultureIntegration = this.otakuCultureIntegration.exportState();
                        } catch (e) {
                            console.error('OtakuCultureIntegration export failed:', e);
                        }
                    }
                    
                    // v23.0: MemoryLimitEnforcerã®çŠ¶æ…‹ã‚‚ä¿å­˜
                    if (this.memoryLimits) {
                        try {
                            exportData.coreState.memoryLimits = this.memoryLimits.exportState();
                        } catch (e) {
                            console.error('MemoryLimits export failed:', e);
                        }
                    }
                    
                    console.log('Export completed. Data size:', JSON.stringify(exportData).length);
                    return exportData;
                } catch (error) {
                    console.error('exportAll failed:', error);
                    this.addLog(`ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    return {
                        version: "24.0",
                        timestamp: Date.now(),
                        coreState: {}
                    };
                }
            }
            
            _rebindSystems() {
                try {
                    // ============ ã‚·ã‚¹ãƒ†ãƒ å†æ¥ç¶šå‡¦ç† ============
                    // JSONã‹ã‚‰å¾©å…ƒã—ãŸãƒ‡ãƒ¼ã‚¿ãŒå„ã‚¯ãƒ©ã‚¹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹ã‚ˆã†å†æ¥ç¶š
                    
                    // 1. ConceptSpace: MapãŒæ­£ã—ãæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ç¢ºèª
                    if (this.concepts && this.concepts.concepts instanceof Map) {
                        // Conceptã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ©Ÿèƒ½ã™ã‚‹ã‹ç¢ºèª
                        for (const [id, concept] of this.concepts.concepts.entries()) {
                            if (typeof concept.encounter !== 'function') {
                                // ãƒ¡ã‚½ãƒƒãƒ‰ãŒå¤±ã‚ã‚Œã¦ã„ã‚‹å ´åˆã€å†æ§‹ç¯‰
                                const fixedConcept = Concept.fromState(concept);
                                this.concepts.concepts.set(id, fixedConcept);
                            }
                        }
                    }
                    
                    // 2. EpisodicMemory: é…åˆ—ãŒæ­£ã—ãæ©Ÿèƒ½ã—ã¦ã„ã‚‹ã‹ç¢ºèª
                    if (this.episodicMemory && Array.isArray(this.episodicMemory.episodes)) {
                        // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰ã®å‚ç…§ã‚’ç¢ºèªï¼ˆç‰¹ã«å¿…è¦ãªã—ã€é…åˆ—ã¯å•é¡Œãªã„ï¼‰
                    }
                    
                    // 3. Intelligence: å„å±¤ã®ç›¸äº’å‚ç…§ã‚’ç¢ºèª
                    if (this.intelligence) {
                        if (this.intelligence.causalMemory) {
                            // CausalMemoryLayer ã® Map ã‚’ç¢ºèª
                            if (!(this.intelligence.causalMemory.causalChains instanceof Map)) {
                                this.intelligence.causalMemory.causalChains = new Map();
                            }
                        }
                        if (this.intelligence.knowledgeBoundary) {
                            // KnowledgeBoundaryLayer ã® Map/Set ã‚’ç¢ºèª
                            if (!(this.intelligence.knowledgeBoundary.conceptConfidence instanceof Map)) {
                                this.intelligence.knowledgeBoundary.conceptConfidence = new Map();
                            }
                            if (!(this.intelligence.knowledgeBoundary.knowledgeGaps instanceof Set)) {
                                this.intelligence.knowledgeBoundary.knowledgeGaps = new Set();
                            }
                            if (!(this.intelligence.knowledgeBoundary.uncertainAreas instanceof Map)) {
                                this.intelligence.knowledgeBoundary.uncertainAreas = new Map();
                            }
                        }
                        if (this.intelligence.abstractResolution) {
                            // AbstractResolutionManager ã® Map ã‚’ç¢ºèª
                            if (!(this.intelligence.abstractResolution.resolutionMap instanceof Map)) {
                                this.intelligence.abstractResolution.resolutionMap = new Map();
                            }
                        }
                    }
                    
                    // 4. ASI Systems: ç›¸äº’å‚ç…§ã‚’ç¢ºèª
                    if (this.worldView && this.conceptIntegration) {
                        // ConceptIntegrationManager ãŒ Being ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†å†è¨­å®š
                        this.conceptIntegration.being = this;
                    }
                    
                    if (this.asiReasoning) {
                        // ASIReasoningEngine ãŒ Being ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†å†è¨­å®š
                        this.asiReasoning.being = this;
                        this.asiReasoning.worldView = this.worldView;
                        this.asiReasoning.abstractionController = this.abstractionController;
                    }
                    
                    if (this.otakuCultureIntegration && this.worldView) {
                        // OtakuCultureIntegration ãŒ WorldView ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†å†è¨­å®š
                        this.otakuCultureIntegration.worldView = this.worldView;
                    }
                    
                    if (this.memoryOptimizer) {
                        // MemoryOptimizer ãŒ Being ã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†å†è¨­å®š
                        this.memoryOptimizer.being = this;
                    }
                    
                    // 5. PAL System: Being ã¸ã®å‚ç…§ã‚’å†è¨­å®š
                    if (this.perpetualLoop) {
                        this.perpetualLoop.being = this;
                    }
                    
                    // 6. Intelligence: Being ã¸ã®å‚ç…§ã‚’å†è¨­å®š
                    if (this.intelligence) {
                        this.intelligence.being = this;
                    }
                    
                    // 7. AutonomousCreator: Being ã¸ã®å‚ç…§ã‚’å†è¨­å®š
                    if (this.autonomousCreator) {
                        this.autonomousCreator.being = this;
                    }
                    
                    // 8. GenerationalCompression: Being ã¸ã®å‚ç…§ã‚’å†è¨­å®š
                    if (this.generationalCompression) {
                        this.generationalCompression.being = this;
                    }
                    
                    // 9. MemoryLimitEnforcer: Being ã¸ã®å‚ç…§ã‚’å†è¨­å®š
                    if (this.memoryLimits) {
                        this.memoryLimits.being = this;
                    }
                    
                    console.log('Systems rebinding completed');
                    return true;
                } catch (error) {
                    console.error('_rebindSystems failed:', error);
                    this.addLog(`ã‚·ã‚¹ãƒ†ãƒ å†æ¥ç¶šã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    return false;
                }
            }
            
            importAll(data) {
                console.log('[IMPORT] ========================================');
                console.log('[IMPORT] importAll() ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ');
                console.log('[IMPORT] data:', data);
                console.log('[IMPORT] data.coreState exists:', !!data?.coreState);
                console.log('[IMPORT] data.coreState.identity:', data?.coreState?.identity);
                console.log('[IMPORT] data.coreState.identity.turns:', data?.coreState?.identity?.turns);
                console.log('[IMPORT] BEFORE import - this.identity:', this.identity);
                console.log('[IMPORT] ========================================');
                
                if (!data || !data.coreState) {
                    this.addLog('å¾©å…ƒãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™');
                    return false;
                }
                
                const core = data.coreState;
                
                try {
                    if (core.concepts) this.concepts.importState(core.concepts);
                    if (core.protoConcepts) this.protoGenerator.importState(core.protoConcepts);
                    if (core.hierarchy) this.hierarchy.importState(core.hierarchy);
                    if (core.valueLayer) this.valueLayer.importState(core.valueLayer);
                    if (core.failures) this.failures.importState(core.failures);
                    if (core.personModel) this.personModel.importState(core.personModel);
                    if (core.languageOutputDL) this.languageOutputDL.importState(core.languageOutputDL);
                    if (core.sensoryIntegrator) this.sensoryIntegrator.importState(core.sensoryIntegrator);
                    if (core.state) Object.assign(this.state, core.state);
                    if (core.world) Object.assign(this.world, core.world);
                    if (core.identity) {
                        Object.assign(this.identity, core.identity);
                        console.log('[IMPORT] identity restored:', this.identity);
                        console.log('[IMPORT] identity.turns:', this.identity.turns);
                    }
                    if (core.uninterpreted) this.uninterpreted.importState(core.uninterpreted);
                    if (core.conversationFlow) this.conversationFlow = core.conversationFlow;
                    if (core.abstractionAttempts !== undefined) this.abstractionAttempts = core.abstractionAttempts;
                    if (core.episodicMemory) this.episodicMemory.importState(core.episodicMemory);
                    if (core.cognitiveMetabolism) this.humanBrainMetabolism.importState(core.cognitiveMetabolism);
                    
                    // è¿½åŠ : ãã®ä»–ã®é‡è¦ãªçŠ¶æ…‹ã®å¾©å…ƒ
                    if (core.log && Array.isArray(core.log)) {
                        this.log = core.log;
                    }
                    if (core.questionEngineState) {
                        if (core.questionEngineState.lastQuestion !== undefined) {
                            this.questionEngine.lastQuestion = core.questionEngineState.lastQuestion;
                        }
                        if (core.questionEngineState.cooldown !== undefined) {
                            this.questionEngine.cooldown = core.questionEngineState.cooldown;
                        }
                    }
                    
                    // v22.0: PALã‚·ã‚¹ãƒ†ãƒ ã®å¾©å…ƒ
                    if (core.perpetualLoop && this.perpetualLoop) {
                        try {
                            // PALã®å†…éƒ¨çŠ¶æ…‹ã‚’å¾©å…ƒï¼ˆéƒ¨åˆ†çš„ï¼‰
                            if (core.perpetualLoop.impulseThreshold !== undefined) {
                                this.perpetualLoop.impulseThreshold = core.perpetualLoop.impulseThreshold;
                            }
                            if (core.perpetualLoop.stress !== undefined) {
                                this.perpetualLoop.stress = core.perpetualLoop.stress;
                            }
                            if (core.perpetualLoop.saturation !== undefined) {
                                this.perpetualLoop.saturation = core.perpetualLoop.saturation;
                            }
                            this.addLog('PALã‚·ã‚¹ãƒ†ãƒ å¾©å…ƒ');
                        } catch (e) {
                            console.error('PAL import failed:', e);
                        }
                    }
                    
                    // v20.0: AutonomousCreatorã®å¾©å…ƒ
                    if (core.autonomousCreator && this.autonomousCreator) {
                        try {
                            if (core.autonomousCreator.mood !== undefined) {
                                this.autonomousCreator.mood = core.autonomousCreator.mood;
                            }
                            if (core.autonomousCreator.curiosity !== undefined) {
                                this.autonomousCreator.curiosity = core.autonomousCreator.curiosity;
                            }
                            if (core.autonomousCreator.tension !== undefined) {
                                this.autonomousCreator.tension = core.autonomousCreator.tension;
                            }
                            if (core.autonomousCreator.confidence !== undefined) {
                                this.autonomousCreator.confidence = core.autonomousCreator.confidence;
                            }
                            if (core.autonomousCreator.postCount !== undefined) {
                                this.autonomousCreator.postCount = core.autonomousCreator.postCount;
                            }
                            this.addLog('è‡ªå¾‹å‰µä½œã‚·ã‚¹ãƒ†ãƒ å¾©å…ƒ');
                        } catch (e) {
                            console.error('AutonomousCreator import failed:', e);
                        }
                    }
                    
                    // v23.0: GenerationalCompressionã®å¾©å…ƒ
                    if (core.generationalCompression && this.generationalCompression) {
                        try {
                            this.generationalCompression.importState(core.generationalCompression);
                            this.addLog('ä¸–ä»£åœ§ç¸®ã‚·ã‚¹ãƒ†ãƒ å¾©å…ƒ');
                        } catch (e) {
                            console.error('GenerationalCompression import failed:', e);
                        }
                    }
                    
                    // v24.0: ASI Systemsã®å¾©å…ƒ
                    if (core.worldView && this.worldView) {
                        try {
                            this.worldView.importState(core.worldView);
                            this.addLog('ä¸–ç•Œè¦³ãƒ¢ãƒ‡ãƒ«å¾©å…ƒ');
                        } catch (e) {
                            console.error('WorldView import failed:', e);
                        }
                    }
                    if (core.conceptIntegration && this.conceptIntegration) {
                        try {
                            this.conceptIntegration.importState(core.conceptIntegration);
                            this.addLog('æ¦‚å¿µçµ±åˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼å¾©å…ƒ');
                        } catch (e) {
                            console.error('ConceptIntegration import failed:', e);
                        }
                    }
                    if (core.abstractionController && this.abstractionController) {
                        try {
                            this.abstractionController.importState(core.abstractionController);
                            this.addLog('æŠ½è±¡åº¦ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å¾©å…ƒ');
                        } catch (e) {
                            console.error('AbstractionController import failed:', e);
                        }
                    }
                    if (core.otakuCultureIntegration && this.otakuCultureIntegration) {
                        try {
                            this.otakuCultureIntegration.importState(core.otakuCultureIntegration);
                            this.addLog('ã‚ªã‚¿ã‚¯æ–‡åŒ–çµ±åˆå¾©å…ƒ');
                        } catch (e) {
                            console.error('OtakuCultureIntegration import failed:', e);
                        }
                    }
                    
                    // v21.0: Intelligenceã‚·ã‚¹ãƒ†ãƒ ã®å¾©å…ƒ
                    if (core.intelligence && this.intelligence) {
                        try {
                            if (core.intelligence.causalMemory) {
                                this.intelligence.causalMemory.importState(core.intelligence.causalMemory);
                            }
                            if (core.intelligence.knowledgeBoundary) {
                                this.intelligence.knowledgeBoundary.importState(core.intelligence.knowledgeBoundary);
                            }
                            if (core.intelligence.abstractResolution) {
                                this.intelligence.abstractResolution.importState(core.intelligence.abstractResolution);
                            }
                            this.addLog('çŸ¥æ€§æ§‹é€ å¾©å…ƒ');
                        } catch (e) {
                            console.error('Intelligence import failed:', e);
                        }
                    }
                    
                    // v23.0: MemoryLimitEnforcerã®å¾©å…ƒ
                    if (core.memoryLimits && this.memoryLimits) {
                        try {
                            this.memoryLimits.importState(core.memoryLimits);
                            this.addLog('è¨˜æ†¶ä¸Šé™ç®¡ç†å¾©å…ƒ');
                        } catch (e) {
                            console.error('MemoryLimits import failed:', e);
                        }
                    }
                    
                    // ============ ã‚·ã‚¹ãƒ†ãƒ å†æ¥ç¶šå‡¦ç† ============
                    // JSONã‹ã‚‰å¾©å…ƒã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’å„ã‚·ã‚¹ãƒ†ãƒ ã«å†ãƒã‚¤ãƒ³ãƒ‰
                    this._rebindSystems();
                    
                    this.memoryLoaded = true;
                    const absCount = this.concepts.getGrowth().abstractCount || 0;
                    const uninterpretedCount = this.uninterpreted.states?.length || 0;
                    const episodeCount = this.episodicMemory.episodes?.length || 0;
                    const conceptCount = this.concepts.concepts.size || 0;
                    const maxConcepts = this.conceptIntegration?.maxConcepts || 12000;
                    this.addLog(`äººæ ¼å¾©å…ƒå®Œäº† [v${data.version}]`);
                    this.addLog(`æ¦‚å¿µ:${conceptCount}/${maxConcepts} æŠ½è±¡:${absCount} æœªè§£é‡ˆ:${uninterpretedCount}`);
                    this.addLog(`ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰:${episodeCount}/10000 æŠ½è±¡åº¦:${this.abstractionController?.currentDepth || 0}/8`);
                    this.addLog('ã‚·ã‚¹ãƒ†ãƒ å†æ¥ç¶š: ç›¸äº’å‚ç…§å¾©å…ƒå®Œäº†');
                    
                    console.log('[IMPORT] ========================================');
                    console.log('[IMPORT] importAll() å®Œäº†');
                    console.log('[IMPORT] AFTER import - this.identity:', this.identity);
                    console.log('[IMPORT] AFTER import - this.identity.turns:', this.identity.turns);
                    console.log('[IMPORT] ========================================');
                    
                    return true;
                } catch (error) {
                    this.addLog(`å¾©å…ƒã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    console.error('Import error:', error);
                    return false;
                }
            }
            
            addLog(msg) {
                this.log.push(`[${new Date().toLocaleTimeString()}] ${msg}`);
                if (this.log.length > 30) this.log.shift();
            }
            
            async metabolismTick() {
                await this.humanBrainMetabolism.tick();
                
                // ä»£è¬å‡¦ç†å¾Œã‚‚ä¿å­˜ã‚’ãƒãƒ¼ã‚¯
                if (this.saveManager) {
                    this.saveManager.markDirty();
                }
            }
            
            async perceiveMultimodal(inputs) {
                const sensoryResults = [];
                
                if (inputs.text) {
                    const dlResult = await this.languageInputDL.parse(inputs.text);
                    sensoryResults.push(dlResult);
                    
                    const valueUpdates = this.valueLayer.observe(inputs.text);
                    if (valueUpdates.length > 0) {
                        this.addLog(`Valueå±¤æ›´æ–°: ${valueUpdates.join(', ')}`);
                    }
                }
                
                if (inputs.images && inputs.images.length > 0) {
                    for (let imageData of inputs.images) {
                        const imageResult = await this.imageAdapter.extractMeaning(imageData);
                        sensoryResults.push(imageResult);
                        this.addLog(`è¦–è¦šé‡: ${imageResult.semantic_candidates.length}å€™è£œ`);
                    }
                }
                
                if (inputs.audios && inputs.audios.length > 0) {
                    for (let audioFile of inputs.audios) {
                        const audioResult = await this.audioAdapter.extractMeaning(audioFile);
                        sensoryResults.push(audioResult);
                        this.addLog(`è´è¦šé‡: ${audioResult.semantic_candidates.length}å€™è£œ`);
                    }
                }
                
                if (inputs.videos && inputs.videos.length > 0) {
                    for (let videoFile of inputs.videos) {
                        const videoResult = await this.videoAdapter.extractMeaning(videoFile, 'normal');
                        sensoryResults.push(videoResult);
                        this.addLog(`æ˜ åƒé‡: ${videoResult.sceneCount}ã‚·ãƒ¼ãƒ³è§£æå®Œäº†`);
                    }
                }
                
                const integrated = this.sensoryIntegrator.integrate(sensoryResults);
                
                this.lastLanguageProcess = {
                    type: 'multimodal_input',
                    data: integrated
                };
                
                const modalityStr = integrated.modalitiesUsed.join('+');
                this.addLog(`çµ±åˆå®Œäº†: ${modalityStr} â†’ ${integrated.semantic_candidates.length}æ¦‚å¿µ`);
                
                const conceptIds = integrated.semantic_candidates.map(c => c.concept);
                
                if (Math.random() < 0.3) {
                    const contextFragment = inputs.text || 
                        (inputs.images ? 'è¦–è¦šå…¥åŠ›' : '') + 
                        (inputs.audios ? 'è´è¦šå…¥åŠ›' : '') +
                        (inputs.videos ? 'æ˜ åƒå…¥åŠ›' : '');
                    
                    const result = this.uninterpreted.add(
                        this.state,
                        contextFragment.substring(0, 50)
                    );
                    
                    if (result.distorted) {
                        this.addLog('æœªè§£é‡ˆçŠ¶æ…‹ãŒæ­ªæ›²ä¿æŒã•ã‚ŒãŸ');
                    }
                }
                
                if (this.uninterpreted.states.length >= 3 && Math.random() < 0.4) {
                    const proto = this.protoGenerator.tryGenerate(
                        this.uninterpreted.states.slice(-3)
                    );
                    if (proto) {
                        this.addLog(`åŸæ¦‚å¿µç”Ÿæˆ: ${proto.label}`);
                    }
                }
                
                conceptIds.forEach((id, idx) => {
                    const concept = this.concepts.getOrCreate(id);
                    const bias = this.failures.getBias(id);
                    
                    if (bias > 0.3 && Math.random() < bias) {
                        this.addLog(`${id}ã¸ã®å›é¿ãƒã‚¤ã‚¢ã‚¹ç™ºå‹•`);
                        return;
                    }
                    
                    const candidate = integrated.semantic_candidates[idx];
                    const modality = candidate.modalities[0];
                    
                    concept.encounter(this.state, modality);
                    
                    const groundingFragment = inputs.text?.substring(0, 30) || 
                        `${modality}å…¥åŠ›`;
                    concept.ground(groundingFragment, this.state, modality);
                });
                
                if (conceptIds.length >= 2) {
                    for (let i = 0; i < conceptIds.length - 1; i++) {
                        const c1 = this.concepts.getOrCreate(conceptIds[i]);
                        const c2 = this.concepts.getOrCreate(conceptIds[i + 1]);
                        c1.relate(c2.id, 0.2);
                        c2.relate(c1.id, 0.2);
                    }
                }
                
                this.conversationFlow.push({
                    input: inputs.text?.substring(0, 30) || `[${modalityStr}]`,
                    concepts: conceptIds,
                    state: {...this.state},
                    modalities: integrated.modalitiesUsed
                });
                
                if (this.conversationFlow.length > 30) {
                    this.conversationFlow.shift();
                }
                
                if (this.conversationFlow.length >= 5 && this.identity.turns % 3 === 0) {
                    this.tryAbstraction();
                }
                
                // çŠ¶æ…‹å¤‰æ›´ã‚’ãƒãƒ¼ã‚¯
                if (this.saveManager) {
                    this.saveManager.markDirty();
                }
                
                return { conceptIds, integrated };
            }
            
            async perceive(input) {
                return this.perceiveMultimodal({ text: input });
            }
            
            async determineIntent(text, attachedFiles) {
                const hasVideo = attachedFiles.some(f => f.type === 'video');
                const hasImage = attachedFiles.some(f => f.type === 'image');
                const hasAudio = attachedFiles.some(f => f.type === 'audio');
                
                const generateKeywords = ['ä½œã£ã¦', 'ä½œæˆ', 'ç”Ÿæˆ', 'åˆ¶ä½œ', 'å‹•ç”»ã‚’'];
                const hasGenerateIntent = generateKeywords.some(k => text.includes(k));
                
                if (hasVideo && !text) {
                    return 'watch';
                }
                
                if (hasVideo && text && !hasGenerateIntent) {
                    return 'watch_and_chat';
                }
                
                if (hasVideo && hasGenerateIntent) {
                    return 'watch_then_generate';
                }
                
                if (!hasVideo && hasGenerateIntent) {
                    return 'generate';
                }
                
                return 'chat';
            }
            
            tryAbstraction() {
                this.abstractionAttempts++;
                
                const abstractPattern = this.abstractFormer.detectAbstractPattern(
                    this.concepts,
                    this.conversationFlow
                );
                
                if (abstractPattern) {
                    const abstractId = abstractPattern.label;
                    
                    if (!this.concepts.concepts.has(abstractId)) {
                        const abstractConcept = this.concepts.createAbstract(
                            abstractId,
                            abstractPattern.members,
                            abstractPattern.confidence
                        );
                        
                        this.hierarchy.addAbstract(
                            abstractId,
                            abstractPattern.members,
                            abstractPattern.confidence
                        );
                        
                        this.addLog(`æŠ½è±¡æ¦‚å¿µå½¢æˆ: ${abstractId} â† [${abstractPattern.members.slice(0, 2).join(',')}...]`);
                        
                        this.state.curiosity = Math.min(1, this.state.curiosity + 0.1);
                    }
                }
                
                if (Math.random() < 0.3) {
                    const opposites = this.abstractFormer.detectOpposites(this.concepts);
                    if (opposites.length > 0) {
                        const pair = opposites[0];
                        this.addLog(`å¯¾ç«‹ç™ºè¦‹: ${pair.concept1} â‡” ${pair.concept2}`);
                        
                        const c1 = this.concepts.getOrCreate(pair.concept1);
                        const c2 = this.concepts.getOrCreate(pair.concept2);
                        c1.relate(c2.id, 0.7);
                        c2.relate(c1.id, 0.7);
                    }
                }
            }
            
            feel(integrated, conceptIds) {
                const s = this.state;
                
                const pressure = this.uninterpreted.getPressure();
                s.tension = Math.min(1, s.tension + pressure.tensionIncrease);
                s.curiosity = Math.min(1, s.curiosity + pressure.curiosityIncrease);
                
                const hints = integrated.emotion_hints;
                if (hints.valence > 0.3) {
                    s.joy = Math.min(1, s.joy + 0.15);
                    s.tension = Math.max(0, s.tension - 0.1);
                } else if (hints.valence < -0.3) {
                    s.joy = Math.max(0, s.joy - 0.1);
                    s.tension = Math.min(1, s.tension + 0.15);
                    s.calm = Math.max(0, s.calm - 0.1);
                }
                
                if (hints.arousal > 0.6) {
                    s.curiosity = Math.min(1, s.curiosity + 0.15);
                }
                
                if (hints.valence < -0.3 && hints.arousal > 0.5 && conceptIds.length > 0) {
                    const intensity = Math.abs(hints.valence) * hints.arousal;
                    if (intensity > 0.6) {
                        const recorded = this.failures.record(
                            conceptIds[0],
                            integrated.semantic_candidates[0]?.concept || '',
                            s.tension
                        );
                        if (recorded) {
                            this.addLog(`å¤±æ•—è¨˜æ†¶: ${conceptIds[0]} (å¼·åº¦: ${s.tension.toFixed(2)})`);
                        }
                    }
                }
                
                s.curiosity = Math.max(0.2, s.curiosity - 0.03);
                s.calm = Math.min(1, s.calm + 0.02);
            }
            
            formHypothesis(integrated) {
                if (Math.random() < 0.3) {
                    const modalityCount = integrated.modalitiesUsed?.length || 1;
                    
                    if (modalityCount > 1) {
                        this.personModel.formHypothesis(
                            'multimodal',
                            `${integrated.modalitiesUsed.join('+')}ä½¿ç”¨`,
                            0.7
                        );
                    }
                    
                    if (integrated.emotion_hints?.arousal > 0.6) {
                        this.personModel.formHypothesis(
                            'engagement',
                            'é«˜è¦šé†’çŠ¶æ…‹',
                            0.6
                        );
                    }
                }
            }
            
            getStagnantConcepts() {
                return Array.from(this.concepts.concepts.values())
                    .filter(c => c.isStagnant())
                    .sort((a, b) => a.lastEncounter - b.lastEncounter);
            }
            
            buildIntentVector(conceptIds) {
                if (conceptIds.length === 0) {
                    conceptIds = ['å¯¾è©±'];
                }
                
                const primaryConcept = this.concepts.getOrCreate(conceptIds[0]);
                const depth = primaryConcept.depth;
                const relations = Array.from(primaryConcept.relations.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 2);
                
                let intent = 'èª¬æ˜ã—ãŸã„';
                
                const activeProtos = this.protoGenerator.getActive();
                if (activeProtos.length > 0 && Math.random() < 0.3) {
                    intent = 'è¿·ã„ã‚’ä¼ãˆãŸã„';
                }
                
                if (this.state.curiosity > 0.7 && Math.random() < 0.4) {
                    intent = 'å•ã„ã‹ã‘ãŸã„';
                }
                
                if (relations.length >= 2 && Math.random() < 0.3) {
                    intent = 'é–¢ä¿‚ã‚’è¿°ã¹ãŸã„';
                    conceptIds = [relations[0][0], relations[1][0]];
                }
                
                const avoidConcepts = [];
                for (let failure of this.failures.getRecent(3)) {
                    if (failure.decay > 0.5) {
                        avoidConcepts.push(failure.concept);
                    }
                }
                
                return {
                    intent,
                    concepts: conceptIds.slice(0, 2),
                    tone: {
                        certainty: Math.max(0.1, depth - this.state.tension * 0.3),
                        hesitation: this.state.tension * 0.7 + this.uninterpreted.getDensity() * 0.3,
                        emotional_weight: this.state.joy * 0.4 + this.state.tension * 0.4 + this.state.curiosity * 0.2
                    },
                    constraints: {
                        avoid_concepts: avoidConcepts,
                        length: this.state.calm > 0.7 ? 'medium' : 'short',
                        clarity: depth > 0.6 ? 'high' : (depth > 0.3 ? 'medium' : 'low')
                    }
                };
            }
            
            async selectUtterance(candidates, intentVector) {
                const decisions = [];
                
                for (let i = 0; i < candidates.length; i++) {
                    const candidate = candidates[i];
                    const text = candidate.text;
                    let score = 1.0;
                    let reasons = [];
                    
                    score -= candidate.expressionBias;
                    if (candidate.expressionBias > 0.2) {
                        reasons.push(`è¡¨ç¾ãƒã‚¤ã‚¢ã‚¹: -${candidate.expressionBias.toFixed(2)}`);
                    } else if (candidate.expressionBias < -0.1) {
                        reasons.push(`è¡¨ç¾æ…£ã‚Œ: +${Math.abs(candidate.expressionBias).toFixed(2)}`);
                    }
                    
                    for (let avoidConcept of intentVector.constraints.avoid_concepts) {
                        if (text.includes(avoidConcept)) {
                            score *= 0.3;
                            reasons.push(`å›é¿: ${avoidConcept}`);
                        }
                    }
                    
                    if (this.state.tension > 0.7) {
                        if (text.includes('...') || text.includes('ã‘ã©') || text.includes('æ°—ãŒã™ã‚‹')) {
                            score *= 1.3;
                            reasons.push('èºŠèº‡è¡¨ç¾ã¨åˆè‡´');
                        }
                        if (text.length > 30 && text.includes('åˆ†ã‹ã£ãŸ')) {
                            score *= 0.5;
                            reasons.push('ç·Šå¼µæ™‚ã«æ–­å®šçš„ã™ã');
                        }
                    }
                    
                    if (this.uninterpreted.getDensity() > 0.5) {
                        if (text.includes('åˆ†ã‹ã‚‰ãªã„') || text.includes('æ´ã‚ãªã„')) {
                            score *= 1.4;
                            reasons.push('æœªè§£é‡ˆçŠ¶æ…‹ã‚’åæ˜ ');
                        }
                    }
                    
                    if (intentVector.tone.certainty < 0.3) {
                        if (text.includes('ã‹ãªã‚Š') || text.includes('ã¯ã£ãã‚Š')) {
                            score *= 0.4;
                            reasons.push('ç¢ºä¿¡åº¦ã¨ä¸ä¸€è‡´');
                        }
                    }
                    
                    decisions.push({ 
                        candidate: text, 
                        score, 
                        reasons: reasons.join(', ') || 'åŸºæº–åˆè‡´',
                        index: i,
                        expressionBias: candidate.expressionBias
                    });
                }
                
                decisions.sort((a, b) => b.score - a.score);
                
                this.lastLanguageProcess = {
                    type: 'output',
                    data: {
                        candidates: candidates.map(c => c.text),
                        decisions: decisions,
                        selected: decisions[0]
                    }
                };
                
                this.addLog(`ç™ºè©±é¸æŠ: ${decisions.length}å€™è£œ (ã‚¹ã‚³ã‚¢: ${decisions[0].score.toFixed(2)})`);
                
                let finalText = decisions[0].candidate;
                const preTensionState = this.state.tension;
                
                if (this.state.tension > 0.8 && Math.random() < 0.3) {
                    finalText = finalText.substring(0, Math.floor(finalText.length * 0.7)) + '...';
                    this.addLog('ç™ºè©±æŠ‘åˆ¶: ç·Šå¼µã«ã‚ˆã‚Šåˆ‡æ–­');
                }
                
                const nameTag = this.valueLayer.getNameTag();
                if (nameTag && Math.random() < 0.15) {
                    if (Math.random() < 0.5) {
                        finalText = `${nameTag}ã•ã‚“ã¯` + finalText;
                    } else {
                        finalText = finalText + `ã¨ã€${nameTag}ã•ã‚“ã«ã¯æ€ãˆã‚‹`;
                    }
                }
                
                return { 
                    text: finalText, 
                    decisions,
                    selectedPhrase: decisions[0].candidate,
                    preTensionState
                };
            }
            
            feedbackToLanguageDL(selectedPhrase, integrated, preTensionState, success = true) {
                const tensionChange = Math.abs(this.state.tension - preTensionState);
                
                this.languageOutputDL.feedback({
                    phrase: selectedPhrase,
                    ambiguity: integrated?.ambiguity || 0,
                    tensionChange,
                    success
                });
                
                this.addLog(`è¨€èªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: "${selectedPhrase.substring(0, 20)}..." (ç·Šå¼µå¤‰åŒ–: ${tensionChange.toFixed(2)})`);
            }
            
            evolve() {
                console.log('[EVOLVE] Before:', this.identity.turns);
                this.identity.turns++;
                console.log('[EVOLVE] After:', this.identity.turns);
                
                const growth = this.concepts.getGrowth();
                const uninterpretedDensity = this.uninterpreted.getDensity();
                const abstractCount = growth.abstractCount || 0;
                
                if (abstractCount > 5) {
                    this.identity.core = `ç§ã¯${growth.count}å€‹ã®æ¦‚å¿µã¨${abstractCount}å€‹ã®æŠ½è±¡æ¦‚å¿µã‚’ç†è§£ã—ã¦ã„ã‚‹`;
                } else if (growth.avgDepth > 0.7) {
                    this.identity.core = `ç§ã¯${growth.count}å€‹ã®æ¦‚å¿µã‚’æ·±ãç†è§£ã—ã¦ã„ã‚‹`;
                } else if (growth.avgDepth > 0.4) {
                    this.identity.core = `ç§ã¯å°‘ã—ãšã¤ç†è§£ã‚’æ·±ã‚ã¦ã„ã‚‹`;
                } else if (uninterpretedDensity > 0.6) {
                    this.identity.core = `ç§ã¯å¤šãã®ã“ã¨ã‚’æ´ã‚ãšã«ã„ã‚‹`;
                }
                
                this.world.stability = Math.max(0, Math.min(1, 
                    this.world.stability + (Math.random() - 0.5) * 0.02
                ));
                
                this.world.familiarity = Math.min(1, 
                    this.world.familiarity + 0.01
                );
                
                if (this.memoryConstraint.shouldCompress(this.concepts)) {
                    const removed = this.memoryConstraint.compress(this.concepts);
                    this.addLog(`è¨˜æ†¶åœ§ç¸®: ${removed}æ¦‚å¿µã‚’æ·˜æ±°`);
                }
                
                this.failures.decay();
            }
            
            async checkAutonomousQuestion() {
                if (this.questionEngine.shouldGenerate(this)) {
                    const question = this.questionEngine.generate(this);
                    const dlResult = await this.languageOutputDL.generate(question.intentVector);
                    const selected = await this.selectUtterance(
                        dlResult.candidates,
                        question.intentVector
                    );
                    
                    this.feedbackToLanguageDL(
                        selected.selectedPhrase,
                        null,
                        selected.preTensionState,
                        true
                    );
                    
                    return {
                        text: selected.text,
                        internal: question.internal,
                        decisions: selected.decisions
                    };
                }
                return null;
            }
            
            async respond(input) {
                // v17.0: ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒãƒ¼ã‚¯
                this.humanBrainMetabolism.markActivity();
                
                // v17.0: äºˆæ¸¬ç”Ÿæˆ
                const prediction = this.humanBrainMetabolism.generatePrediction(input);
                
                // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜éŒ²ï¼šå…¥åŠ›
                this.episodicMemory.record(
                    'user',
                    input,
                    [],
                    this.state,
                    'input'
                );
                
                const { conceptIds, integrated } = await this.perceive(input);
                this.feel(integrated, conceptIds);
                this.formHypothesis(integrated);
                
                const activeProtos = this.protoGenerator.getActive();
                if (activeProtos.length > 0 && Math.random() < 0.3) {
                    const proto = activeProtos[0];
                    const promoted = proto.use();
                    if (promoted) {
                        const conceptId = this.protoGenerator.promote(proto, this.concepts);
                        const text = `${proto.label}ãŒã€${conceptId}ã«ãªã£ãŸæ°—ãŒã™ã‚‹`;
                        this.addLog(`åŸæ¦‚å¿µæ˜‡æ ¼: ${proto.label} â†’ ${conceptId}`);
                        this.evolve();
                        
                        // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜éŒ²ï¼šåŸæ¦‚å¿µæ˜‡æ ¼
                        this.episodicMemory.record(
                            'ao',
                            text,
                            [conceptId],
                            this.state,
                            'proto_promotion'
                        );
                        
                        return {
                            text,
                            internal: `åŸæ¦‚å¿µæ˜‡æ ¼`,
                            decisions: []
                        };
                    }
                }
                
                const intentVector = this.buildIntentVector(conceptIds);
                const dlResult2 = await this.languageOutputDL.generate(intentVector);
                const selected = await this.selectUtterance(
                    dlResult2.candidates,
                    intentVector
                );
                
                this.feedbackToLanguageDL(
                    selected.selectedPhrase,
                    integrated,
                    selected.preTensionState,
                    true
                );
                
                this.evolve();
                
                const primaryConcept = this.concepts.getOrCreate(conceptIds[0]);
                const modalities = Array.from(primaryConcept.modalityOrigins).join('+');
                const internal = `æ·±åº¦:${(primaryConcept.depth * 100).toFixed(0)}% ãƒ¢ãƒ€ãƒªãƒ†ã‚£:${modalities} æœªè§£é‡ˆ:${this.uninterpreted.states.length}`;
                
                // v17.0: äºˆæ¸¬è©•ä¾¡
                const predictionError = this.humanBrainMetabolism.evaluatePrediction(this.state, 'output');
                
                // v17.0: è¡Œå‹•é¸æŠ
                const action = this.humanBrainMetabolism.selectAction(predictionError);
                
                // v17.0: æ”¿ç­–æ›´æ–°
                this.humanBrainMetabolism.updateActionPolicy(action, 'success', predictionError);
                
                // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜éŒ²ï¼šå‡ºåŠ›
                this.episodicMemory.record(
                    'ao',
                    selected.text,
                    conceptIds,
                    this.state,
                    'output'
                );
                
                // v17.0: ç‰©èªçµ±åˆ
                const lastEpisode = this.episodicMemory.episodes[this.episodicMemory.episodes.length - 1];
                if (lastEpisode) {
                    this.humanBrainMetabolism.narrativeIdentity.addNarrativeEvent(lastEpisode);
                }
                
                // çŠ¶æ…‹å¤‰æ›´ã‚’ãƒãƒ¼ã‚¯
                if (this.saveManager) {
                    this.saveManager.markDirty();
                }
                
                return {
                    text: selected.text,
                    internal,
                    decisions: selected.decisions
                };
            }
        }
        
        
        // ============ ç·¨é›†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆv18.0 è¿½åŠ å®Ÿè£…ï¼‰============
        // â–  åŸå‰‡ï¼šæ—¢å­˜ã®Aoæ©Ÿèƒ½ã‚’ä¸€åˆ‡å¤‰æ›´ã—ãªã„
        // â–  å®Œå…¨ã«ç‹¬ç«‹ã—ãŸè¿½åŠ å®Ÿè£…
        
        // ============ ç·¨é›†ã‚½ãƒ•ãƒˆæŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹ ============
        class EditorAdapter {
            constructor(name, type) {
                this.name = name || 'Unknown';
                this.type = type || 'generic';
                this.isAvailable = false;
                this.projectPath = null;
                this.assetsPath = null;
            }
            
            async checkAvailability() {
                try {
                    // ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
                    return false;
                } catch (error) {
                    console.error(`${this.name} availability check failed:`, error);
                    return false;
                }
            }
            
            async openProject(path) {
                try {
                    this.projectPath = path;
                    return { success: true, message: `Project opened: ${path}` };
                } catch (error) {
                    console.error(`${this.name} openProject failed:`, error);
                    return { success: false, error: error.message };
                }
            }
            
            async importAssets(path) {
                try {
                    this.assetsPath = path;
                    return { success: true, message: `Assets imported: ${path}` };
                } catch (error) {
                    console.error(`${this.name} importAssets failed:`, error);
                    return { success: false, error: error.message };
                }
            }
            
            async applyAction(action) {
                try {
                    // ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
                    return { success: true, message: `Action applied: ${action.type}` };
                } catch (error) {
                    console.error(`${this.name} applyAction failed:`, error);
                    return { success: false, error: error.message };
                }
            }
            
            async save() {
                try {
                    return { success: true, message: 'Project saved' };
                } catch (error) {
                    console.error(`${this.name} save failed:`, error);
                    return { success: false, error: error.message };
                }
            }
            
            async export(outputPath) {
                try {
                    return { success: true, message: `Exported to: ${outputPath}` };
                } catch (error) {
                    console.error(`${this.name} export failed:`, error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ å‹•ç”»ç·¨é›†ã‚¢ãƒ€ãƒ—ã‚¿ï¼ˆæ±ç”¨ï¼‰ ============
        class VideoEditorAdapter extends EditorAdapter {
            constructor(name = 'Generic Video Editor') {
                super(name, 'video');
            }
            
            async applyAction(action) {
                try {
                    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³å®Ÿè¡Œã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    if (action.type === 'cut') {
                        return { success: true, message: `Cut applied: ${action.time}` };
                    } else if (action.type === 'insert_text') {
                        return { success: true, message: `Text inserted: ${action.text}` };
                    } else if (action.type === 'add_transition') {
                        return { success: true, message: `Transition added` };
                    }
                    return { success: true, message: `Action applied: ${action.type}` };
                } catch (error) {
                    console.error('VideoEditorAdapter applyAction failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ ã‚³ãƒ¼ãƒ‰ç·¨é›†ã‚¢ãƒ€ãƒ—ã‚¿ï¼ˆæ±ç”¨ï¼‰ ============
        class CodeEditorAdapter extends EditorAdapter {
            constructor(name = 'Generic Code Editor') {
                super(name, 'code');
            }
            
            async applyAction(action) {
                try {
                    if (action.type === 'insert') {
                        return { success: true, message: `Code inserted at line ${action.line}` };
                    } else if (action.type === 'delete') {
                        return { success: true, message: `Code deleted: lines ${action.startLine}-${action.endLine}` };
                    } else if (action.type === 'format') {
                        return { success: true, message: `Code formatted` };
                    }
                    return { success: true, message: `Action applied: ${action.type}` };
                } catch (error) {
                    console.error('CodeEditorAdapter applyAction failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ æ–‡ç« ç·¨é›†ã‚¢ãƒ€ãƒ—ã‚¿ï¼ˆæ±ç”¨ï¼‰ ============
        class DocumentEditorAdapter extends EditorAdapter {
            constructor(name = 'Generic Document Editor') {
                super(name, 'document');
            }
            
            async applyAction(action) {
                try {
                    if (action.type === 'insert_paragraph') {
                        return { success: true, message: `Paragraph inserted` };
                    } else if (action.type === 'format_heading') {
                        return { success: true, message: `Heading formatted: ${action.level}` };
                    } else if (action.type === 'insert_image') {
                        return { success: true, message: `Image inserted` };
                    }
                    return { success: true, message: `Action applied: ${action.type}` };
                } catch (error) {
                    console.error('DocumentEditorAdapter applyAction failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ éŸ³å£°ç·¨é›†ã‚¢ãƒ€ãƒ—ã‚¿ï¼ˆæ±ç”¨ï¼‰ ============
        class AudioEditorAdapter extends EditorAdapter {
            constructor(name = 'Generic Audio Editor') {
                super(name, 'audio');
            }
            
            async applyAction(action) {
                try {
                    if (action.type === 'trim') {
                        return { success: true, message: `Audio trimmed: ${action.start}-${action.end}` };
                    } else if (action.type === 'apply_effect') {
                        return { success: true, message: `Effect applied: ${action.effect}` };
                    } else if (action.type === 'normalize') {
                        return { success: true, message: `Audio normalized` };
                    }
                    return { success: true, message: `Action applied: ${action.type}` };
                } catch (error) {
                    console.error('AudioEditorAdapter applyAction failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ ã‚¹ãƒ©ã‚¤ãƒ‰ç·¨é›†ã‚¢ãƒ€ãƒ—ã‚¿ï¼ˆæ±ç”¨ï¼‰ ============
        class SlideEditorAdapter extends EditorAdapter {
            constructor(name = 'Generic Slide Editor') {
                super(name, 'slide');
            }
            
            async applyAction(action) {
                try {
                    if (action.type === 'add_slide') {
                        return { success: true, message: `Slide added: ${action.layout}` };
                    } else if (action.type === 'insert_content') {
                        return { success: true, message: `Content inserted on slide ${action.slideIndex}` };
                    } else if (action.type === 'apply_theme') {
                        return { success: true, message: `Theme applied: ${action.theme}` };
                    }
                    return { success: true, message: `Action applied: ${action.type}` };
                } catch (error) {
                    console.error('SlideEditorAdapter applyAction failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ Action Plan Generator ============
        class ActionPlanGenerator {
            constructor(being) {
                this.being = being;
            }
            
            generatePlan(editorType, task, assets = []) {
                try {
                    const plan = {
                        id: `plan_${Date.now()}`,
                        editorType: editorType,
                        task: task,
                        assets: assets,
                        actions: [],
                        timestamp: Date.now()
                    };
                    
                    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚¿ã‚¤ãƒ—åˆ¥ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ
                    if (editorType === 'video') {
                        plan.actions = this.generateVideoActions(task, assets);
                    } else if (editorType === 'code') {
                        plan.actions = this.generateCodeActions(task, assets);
                    } else if (editorType === 'document') {
                        plan.actions = this.generateDocumentActions(task, assets);
                    } else if (editorType === 'audio') {
                        plan.actions = this.generateAudioActions(task, assets);
                    } else if (editorType === 'slide') {
                        plan.actions = this.generateSlideActions(task, assets);
                    } else {
                        plan.actions = [{ type: 'generic', description: task }];
                    }
                    
                    return plan;
                } catch (error) {
                    console.error('ActionPlanGenerator generatePlan failed:', error);
                    return {
                        id: `plan_error_${Date.now()}`,
                        editorType: editorType,
                        task: task,
                        actions: [],
                        error: error.message
                    };
                }
            }
            
            generateVideoActions(task, assets) {
                try {
                    // ç°¡æ˜“çš„ãªå‹•ç”»ç·¨é›†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆ
                    const actions = [];
                    
                    // ã‚¿ã‚¹ã‚¯ã«åŸºã¥ã„ã¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
                    if (task.includes('ã‚«ãƒƒãƒˆ') || task.includes('cut')) {
                        actions.push({ type: 'cut', time: '00:00-00:10' });
                    }
                    if (task.includes('ãƒ†ã‚­ã‚¹ãƒˆ') || task.includes('text')) {
                        actions.push({ type: 'insert_text', text: 'ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ', time: '00:05' });
                    }
                    if (task.includes('ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³') || task.includes('transition')) {
                        actions.push({ type: 'add_transition', transition: 'fade' });
                    }
                    
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    if (actions.length === 0) {
                        actions.push({ type: 'import', assets: assets });
                        actions.push({ type: 'arrange', layout: 'timeline' });
                    }
                    
                    return actions;
                } catch (error) {
                    console.error('generateVideoActions failed:', error);
                    return [{ type: 'error', message: error.message }];
                }
            }
            
            generateCodeActions(task, assets) {
                try {
                    const actions = [];
                    
                    if (task.includes('æŒ¿å…¥') || task.includes('insert')) {
                        actions.push({ type: 'insert', line: 1, code: '// Generated code' });
                    }
                    if (task.includes('ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ') || task.includes('format')) {
                        actions.push({ type: 'format' });
                    }
                    
                    if (actions.length === 0) {
                        actions.push({ type: 'open', file: assets[0] || 'main.js' });
                    }
                    
                    return actions;
                } catch (error) {
                    console.error('generateCodeActions failed:', error);
                    return [{ type: 'error', message: error.message }];
                }
            }
            
            generateDocumentActions(task, assets) {
                try {
                    const actions = [];
                    
                    if (task.includes('è¦‹å‡ºã—') || task.includes('heading')) {
                        actions.push({ type: 'format_heading', level: 1 });
                    }
                    if (task.includes('æ®µè½') || task.includes('paragraph')) {
                        actions.push({ type: 'insert_paragraph', text: 'ã‚µãƒ³ãƒ—ãƒ«æ®µè½' });
                    }
                    
                    if (actions.length === 0) {
                        actions.push({ type: 'create', template: 'blank' });
                    }
                    
                    return actions;
                } catch (error) {
                    console.error('generateDocumentActions failed:', error);
                    return [{ type: 'error', message: error.message }];
                }
            }
            
            generateAudioActions(task, assets) {
                try {
                    const actions = [];
                    
                    if (task.includes('ãƒˆãƒªãƒ ') || task.includes('trim')) {
                        actions.push({ type: 'trim', start: '00:00', end: '00:10' });
                    }
                    if (task.includes('ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ') || task.includes('effect')) {
                        actions.push({ type: 'apply_effect', effect: 'reverb' });
                    }
                    
                    if (actions.length === 0) {
                        actions.push({ type: 'import', file: assets[0] || 'audio.wav' });
                    }
                    
                    return actions;
                } catch (error) {
                    console.error('generateAudioActions failed:', error);
                    return [{ type: 'error', message: error.message }];
                }
            }
            
            generateSlideActions(task, assets) {
                try {
                    const actions = [];
                    
                    if (task.includes('ã‚¹ãƒ©ã‚¤ãƒ‰è¿½åŠ ') || task.includes('add slide')) {
                        actions.push({ type: 'add_slide', layout: 'title' });
                    }
                    if (task.includes('ãƒ†ãƒ¼ãƒ') || task.includes('theme')) {
                        actions.push({ type: 'apply_theme', theme: 'default' });
                    }
                    
                    if (actions.length === 0) {
                        actions.push({ type: 'create', template: 'blank' });
                    }
                    
                    return actions;
                } catch (error) {
                    console.error('generateSlideActions failed:', error);
                    return [{ type: 'error', message: error.message }];
                }
            }
        }
        
        // ============ å®Ÿè¡Œãƒ¬ã‚¤ãƒ¤ãƒ¼ ============
        class ExecutionLayer {
            constructor(being) {
                this.being = being;
                this.adapters = new Map();
                this.currentAdapter = null;
                this.executionHistory = [];
                this.maxHistory = 50;
                
                // ã‚¢ãƒ€ãƒ—ã‚¿ã‚’ç™»éŒ²
                try {
                    this.registerAdapter('video', new VideoEditorAdapter('Generic Video'));
                    this.registerAdapter('code', new CodeEditorAdapter('Generic Code'));
                    this.registerAdapter('document', new DocumentEditorAdapter('Generic Document'));
                    this.registerAdapter('audio', new AudioEditorAdapter('Generic Audio'));
                    this.registerAdapter('slide', new SlideEditorAdapter('Generic Slide'));
                } catch (error) {
                    console.error('ExecutionLayer constructor failed:', error);
                }
            }
            
            registerAdapter(type, adapter) {
                try {
                    this.adapters.set(type, adapter);
                } catch (error) {
                    console.error('registerAdapter failed:', error);
                }
            }
            
            selectEditor(type) {
                try {
                    if (this.adapters.has(type)) {
                        this.currentAdapter = this.adapters.get(type);
                        return { success: true, editor: this.currentAdapter.name };
                    }
                    return { success: false, error: `Editor type not found: ${type}` };
                } catch (error) {
                    console.error('selectEditor failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            async executePlan(actionPlan) {
                try {
                    if (!actionPlan || !actionPlan.actions) {
                        return { success: false, error: 'Invalid action plan' };
                    }
                    
                    // ã‚¨ãƒ‡ã‚£ã‚¿ã‚’é¸æŠ
                    const selectResult = this.selectEditor(actionPlan.editorType);
                    if (!selectResult.success) {
                        return selectResult;
                    }
                    
                    const results = [];
                    
                    // å„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œ
                    for (const action of actionPlan.actions) {
                        try {
                            const result = await this.currentAdapter.applyAction(action);
                            results.push(result);
                            
                            if (!result.success) {
                                console.warn('Action failed:', action, result);
                            }
                        } catch (error) {
                            console.error('Action execution failed:', action, error);
                            results.push({ success: false, error: error.message });
                        }
                    }
                    
                    // å®Ÿè¡Œå±¥æ­´ã‚’ä¿å­˜
                    this.executionHistory.push({
                        planId: actionPlan.id,
                        timestamp: Date.now(),
                        results: results
                    });
                    
                    if (this.executionHistory.length > this.maxHistory) {
                        this.executionHistory.shift();
                    }
                    
                    const successCount = results.filter(r => r.success).length;
                    
                    return {
                        success: true,
                        totalActions: actionPlan.actions.length,
                        successfulActions: successCount,
                        results: results
                    };
                } catch (error) {
                    console.error('executePlan failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getHistory() {
                try {
                    return this.executionHistory.slice(-10);
                } catch (error) {
                    console.error('getHistory failed:', error);
                    return [];
                }
            }
        }
        
        // ============ ç°¡æ˜“ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ¢ãƒ¼ãƒ‰Bï¼‰ ============
        class SimpleGeneratorMode {
            constructor(being) {
                this.being = being;
                this.isGenerating = false;
            }
            
            async generateSimpleContent(type, topic, duration = 30) {
                try {
                    if (this.isGenerating) {
                        return { success: false, error: 'Already generating' };
                    }
                    
                    this.isGenerating = true;
                    
                    // ãƒãƒ£ãƒ³ã‚¯åˆ†å‰²ç”Ÿæˆã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    const chunks = Math.ceil(duration / 5); // 5ç§’ã”ã¨ã®ãƒãƒ£ãƒ³ã‚¯
                    const results = [];
                    
                    for (let i = 0; i < chunks; i++) {
                        try {
                            const chunk = {
                                index: i,
                                start: i * 5,
                                end: Math.min((i + 1) * 5, duration),
                                content: `${topic} - Part ${i + 1}`,
                                timestamp: Date.now()
                            };
                            
                            results.push(chunk);
                            
                            // ãƒ¡ãƒ¢ãƒªè§£æ”¾ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                            await new Promise(resolve => setTimeout(resolve, 100));
                            
                        } catch (error) {
                            console.error('Chunk generation failed:', error);
                        }
                    }
                    
                    this.isGenerating = false;
                    
                    return {
                        success: true,
                        type: type,
                        topic: topic,
                        duration: duration,
                        chunks: results.length,
                        output: `simple_${type}_${Date.now()}.mp4`
                    };
                } catch (error) {
                    console.error('generateSimpleContent failed:', error);
                    this.isGenerating = false;
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ ç·¨é›†çµ±åˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ ============
        class EditorIntegrationManager {
            constructor(being) {
                this.being = being;
                this.actionPlanGenerator = new ActionPlanGenerator(being);
                this.executionLayer = new ExecutionLayer(being);
                this.simpleGenerator = new SimpleGeneratorMode(being);
                this.currentMode = 'editor'; // 'editor' or 'simple'
            }
            
            setMode(mode) {
                try {
                    if (mode === 'editor' || mode === 'simple') {
                        this.currentMode = mode;
                        return { success: true, mode: mode };
                    }
                    return { success: false, error: 'Invalid mode' };
                } catch (error) {
                    console.error('setMode failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            async processTask(editorType, task, assets = []) {
                try {
                    if (this.currentMode === 'simple') {
                        // ãƒ¢ãƒ¼ãƒ‰Bï¼šç°¡æ˜“ç”Ÿæˆ
                        return await this.simpleGenerator.generateSimpleContent(editorType, task);
                    } else {
                        // ãƒ¢ãƒ¼ãƒ‰Aï¼šç·¨é›†ã‚½ãƒ•ãƒˆé€£æº
                        const plan = this.actionPlanGenerator.generatePlan(editorType, task, assets);
                        const result = await this.executionLayer.executePlan(plan);
                        return result;
                    }
                } catch (error) {
                    console.error('processTask failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getStatus() {
                try {
                    return {
                        mode: this.currentMode,
                        availableEditors: Array.from(this.executionLayer.adapters.keys()),
                        currentEditor: this.executionLayer.currentAdapter ? this.executionLayer.currentAdapter.name : null,
                        historyCount: this.executionLayer.executionHistory.length
                    };
                } catch (error) {
                    console.error('getStatus failed:', error);
                    return { mode: this.currentMode, error: error.message };
                }
            }
        }
        
        
        // ============ å‹•ç”»ç·¨é›†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆv19.0 è¿½åŠ å®Ÿè£…ï¼‰============
        // â–  åŸå‰‡ï¼šäººé–“ã®æ“ä½œã‚’ä»£æ›¿ã™ã‚‹
        // â–  ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ»ç´ æç®¡ç†ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ§‹ç¯‰ãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
        
        // ============ PCæ“ä½œå±¤ï¼ˆPC Operation Emulation Layerï¼‰============
        class PCOperationLayer {
            constructor() {
                this.maxCacheSize = 2 * 1024 * 1024 * 1024; // 2GB
                this.currentCacheSize = 0;
                this.fileCache = new Map();
            }
            
            async listFiles(folderPath, filter = null) {
                try {
                    // ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒã§ã¯ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                    // å®Ÿéš›ã®Electronç’°å¢ƒã§ã¯fs.readdirã‚’ä½¿ç”¨
                    const files = [];
                    
                    // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«
                    for (let i = 1; i <= 10; i++) {
                        const file = {
                            name: `video_${i}.mp4`,
                            path: `${folderPath}/video_${i}.mp4`,
                            type: 'video',
                            size: Math.floor(Math.random() * 1000000) + 100000,
                            duration: Math.floor(Math.random() * 300) + 10
                        };
                        
                        if (!filter || filter(file)) {
                            files.push(file);
                        }
                    }
                    
                    return { success: true, files: files };
                } catch (error) {
                    console.error('PCOperationLayer.listFiles failed:', error);
                    return { success: false, error: error.message, files: [] };
                }
            }
            
            async filterByType(files, types) {
                try {
                    const filtered = files.filter(file => types.includes(file.type));
                    return { success: true, files: filtered };
                } catch (error) {
                    console.error('PCOperationLayer.filterByType failed:', error);
                    return { success: false, error: error.message, files: [] };
                }
            }
            
            async sortFiles(files, criterion = 'name') {
                try {
                    const sorted = [...files].sort((a, b) => {
                        if (criterion === 'name') return a.name.localeCompare(b.name);
                        if (criterion === 'size') return b.size - a.size;
                        if (criterion === 'duration') return b.duration - a.duration;
                        return 0;
                    });
                    return { success: true, files: sorted };
                } catch (error) {
                    console.error('PCOperationLayer.sortFiles failed:', error);
                    return { success: false, error: error.message, files: files };
                }
            }
            
            checkCacheLimit(fileSize) {
                try {
                    return (this.currentCacheSize + fileSize) <= this.maxCacheSize;
                } catch (error) {
                    console.error('PCOperationLayer.checkCacheLimit failed:', error);
                    return false;
                }
            }
            
            clearCache() {
                try {
                    this.fileCache.clear();
                    this.currentCacheSize = 0;
                    return { success: true };
                } catch (error) {
                    console.error('PCOperationLayer.clearCache failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ ç´ æç®¡ç†ï¼ˆAsset Managerï¼‰============
        class AssetManager {
            constructor() {
                this.assets = [];
                this.selectedAssets = [];
                this.excludedAssets = [];
            }
            
            async loadAssets(folderPath) {
                try {
                    const pcOps = new PCOperationLayer();
                    const result = await pcOps.listFiles(folderPath);
                    
                    if (result.success) {
                        this.assets = result.files;
                        return { success: true, count: this.assets.length };
                    }
                    return { success: false, error: result.error };
                } catch (error) {
                    console.error('AssetManager.loadAssets failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            selectByTheme(theme) {
                try {
                    // ç·¨é›†ãƒ†ãƒ¼ãƒã«åŸºã¥ã„ã¦ç´ æã‚’é¸æŠ
                    this.selectedAssets = [];
                    
                    // ã‚·ãƒ³ãƒ—ãƒ«ãªé¸æŠãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šé«˜åº¦ãªåˆ¤æ–­ï¼‰
                    const keywords = theme.toLowerCase().split(/\s+/);
                    
                    this.assets.forEach(asset => {
                        const assetName = asset.name.toLowerCase();
                        const matches = keywords.some(keyword => assetName.includes(keyword));
                        
                        if (matches || Math.random() > 0.5) {
                            this.selectedAssets.push(asset);
                        } else {
                            this.excludedAssets.push(asset);
                        }
                    });
                    
                    return {
                        success: true,
                        selected: this.selectedAssets.length,
                        excluded: this.excludedAssets.length
                    };
                } catch (error) {
                    console.error('AssetManager.selectByTheme failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getSelected() {
                try {
                    return { success: true, assets: [...this.selectedAssets] };
                } catch (error) {
                    console.error('AssetManager.getSelected failed:', error);
                    return { success: false, error: error.message, assets: [] };
                }
            }
        }
        
        // ============ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ§‹ç¯‰ï¼ˆTimeline Builderï¼‰============
        class TimelineBuilder {
            constructor() {
                this.tracks = {
                    video: [],
                    audio: [],
                    text: []
                };
                this.duration = 0;
            }
            
            addClip(asset, track = 'video', inPoint = 0, outPoint = null) {
                try {
                    const clip = {
                        id: `clip_${Date.now()}_${Math.random()}`,
                        asset: asset,
                        track: track,
                        inPoint: inPoint,
                        outPoint: outPoint || asset.duration,
                        duration: (outPoint || asset.duration) - inPoint,
                        position: this.tracks[track].reduce((sum, c) => sum + c.duration, 0)
                    };
                    
                    this.tracks[track].push(clip);
                    this.updateDuration();
                    
                    return { success: true, clip: clip };
                } catch (error) {
                    console.error('TimelineBuilder.addClip failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            updateDuration() {
                try {
                    this.duration = Math.max(
                        this.tracks.video.reduce((sum, c) => sum + c.duration, 0),
                        this.tracks.audio.reduce((sum, c) => sum + c.duration, 0),
                        this.tracks.text.reduce((sum, c) => sum + c.duration, 0)
                    );
                } catch (error) {
                    console.error('TimelineBuilder.updateDuration failed:', error);
                }
            }
            
            adjustClipLength(clipId, newDuration) {
                try {
                    for (let track in this.tracks) {
                        const clip = this.tracks[track].find(c => c.id === clipId);
                        if (clip) {
                            clip.duration = newDuration;
                            clip.outPoint = clip.inPoint + newDuration;
                            this.updateDuration();
                            return { success: true, clip: clip };
                        }
                    }
                    return { success: false, error: 'Clip not found' };
                } catch (error) {
                    console.error('TimelineBuilder.adjustClipLength failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            reorderClips(track, newOrder) {
                try {
                    if (!this.tracks[track]) {
                        return { success: false, error: 'Invalid track' };
                    }
                    
                    const reordered = newOrder.map(index => this.tracks[track][index]).filter(Boolean);
                    this.tracks[track] = reordered;
                    
                    // ä½ç½®ã‚’å†è¨ˆç®—
                    let position = 0;
                    this.tracks[track].forEach(clip => {
                        clip.position = position;
                        position += clip.duration;
                    });
                    
                    this.updateDuration();
                    return { success: true };
                } catch (error) {
                    console.error('TimelineBuilder.reorderClips failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getTimeline() {
                try {
                    return {
                        success: true,
                        tracks: { ...this.tracks },
                        duration: this.duration,
                        clipCount: Object.values(this.tracks).reduce((sum, track) => sum + track.length, 0)
                    };
                } catch (error) {
                    console.error('TimelineBuilder.getTimeline failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆï¼ˆProject Generatorï¼‰============
        class ProjectGenerator {
            constructor() {
                this.supportedFormats = ['premiere', 'resolve', 'finalcut'];
            }
            
            generatePremiereProject(timeline, assets, projectName) {
                try {
                    const project = {
                        version: 1,
                        name: projectName || 'Ao_Project',
                        format: 'premiere',
                        timeline: timeline,
                        assets: assets,
                        settings: {
                            frameRate: 30,
                            resolution: { width: 1920, height: 1080 },
                            audioSampleRate: 48000
                        },
                        generatedBy: 'Ao v19.0',
                        timestamp: Date.now()
                    };
                    
                    // XMLãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã«å¤‰æ›ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
                    const xml = this.toPremiereXML(project);
                    
                    return {
                        success: true,
                        project: project,
                        xml: xml,
                        filename: `${projectName}_premiere.xml`
                    };
                } catch (error) {
                    console.error('ProjectGenerator.generatePremiereProject failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            generateResolveProject(timeline, assets, projectName) {
                try {
                    const project = {
                        version: 1,
                        name: projectName || 'Ao_Project',
                        format: 'resolve',
                        timeline: timeline,
                        assets: assets,
                        settings: {
                            frameRate: 30,
                            resolution: { width: 1920, height: 1080 }
                        },
                        generatedBy: 'Ao v19.0',
                        timestamp: Date.now()
                    };
                    
                    return {
                        success: true,
                        project: project,
                        filename: `${projectName}_resolve.drp`
                    };
                } catch (error) {
                    console.error('ProjectGenerator.generateResolveProject failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            toPremiereXML(project) {
                try {
                    // ç°¡æ˜“çš„ãªXMLç”Ÿæˆï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šè©³ç´°ï¼‰
                    return `<?xml version="1.0" encoding="UTF-8"?>
<xmeml version="5">
  <project>
    <name>${project.name}</name>
    <children>
      <sequence>
        <name>Main Sequence</name>
        <duration>${project.timeline.duration}</duration>
        <media>
          <video>
            ${project.timeline.tracks.video.map(clip => `
            <track>
              <clipitem>
                <name>${clip.asset.name}</name>
                <in>${clip.inPoint}</in>
                <out>${clip.outPoint}</out>
                <start>${clip.position}</start>
                <end>${clip.position + clip.duration}</end>
              </clipitem>
            </track>
            `).join('')}
          </video>
        </media>
      </sequence>
    </children>
  </project>
</xmeml>`;
                } catch (error) {
                    console.error('ProjectGenerator.toPremiereXML failed:', error);
                    return '';
                }
            }
        }
        
        // ============ ç·¨é›†åˆ¤æ–­å±¤ï¼ˆEditing Cognition Layerï¼‰============
        class EditingCognitionLayer {
            constructor(being) {
                this.being = being;
                this.editingIntent = null;
                this.operationSequence = [];
                this.failureLog = [];
            }
            
            setIntent(intent) {
                try {
                    this.editingIntent = {
                        description: intent,
                        timestamp: Date.now(),
                        status: 'active'
                    };
                    return { success: true };
                } catch (error) {
                    console.error('EditingCognitionLayer.setIntent failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            planOperations(assets, intent) {
                try {
                    // ç·¨é›†æ„å›³ã«åŸºã¥ã„ã¦æ“ä½œé †åºã‚’æ±ºå®š
                    const operations = [];
                    
                    // 1. ç´ æé¸æŠ
                    operations.push({ type: 'select_assets', description: 'ç·¨é›†ãƒ†ãƒ¼ãƒã«åˆã†ç´ æã‚’é¸æŠ' });
                    
                    // 2. OPä½œæˆ
                    operations.push({ type: 'create_opening', description: 'ã‚ªãƒ¼ãƒ—ãƒ‹ãƒ³ã‚°ä½œæˆ' });
                    
                    // 3. æœ¬ç·¨æ§‹ç¯‰
                    operations.push({ type: 'build_main', description: 'æœ¬ç·¨ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ§‹ç¯‰' });
                    
                    // 4. ç· ã‚ä½œæˆ
                    operations.push({ type: 'create_ending', description: 'ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä½œæˆ' });
                    
                    // 5. ãƒ†ãƒ³ãƒèª¿æ•´
                    operations.push({ type: 'adjust_tempo', description: 'ãƒ†ãƒ³ãƒèª¿æ•´' });
                    
                    // 6. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜
                    operations.push({ type: 'save_project', description: 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä¿å­˜' });
                    
                    this.operationSequence = operations;
                    return { success: true, operations: operations };
                } catch (error) {
                    console.error('EditingCognitionLayer.planOperations failed:', error);
                    return { success: false, error: error.message, operations: [] };
                }
            }
            
            logFailure(operation, error) {
                try {
                    this.failureLog.push({
                        operation: operation,
                        error: error,
                        timestamp: Date.now()
                    });
                    
                    // å¤±æ•—ã‹ã‚‰å­¦ç¿’ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
                    if (this.being && this.being.failures) {
                        this.being.failures.record('editing', error, 1.0);
                    }
                } catch (error) {
                    console.error('EditingCognitionLayer.logFailure failed:', error);
                }
            }
            
            getProgress() {
                try {
                    const completed = this.operationSequence.filter(op => op.completed).length;
                    const total = this.operationSequence.length;
                    return {
                        success: true,
                        completed: completed,
                        total: total,
                        percentage: total > 0 ? (completed / total) * 100 : 0
                    };
                } catch (error) {
                    console.error('EditingCognitionLayer.getProgress failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ å‹•ç”»ç·¨é›†çµ±åˆï¼ˆVideo Editing Integrationï¼‰============
        class VideoEditingIntegration {
            constructor(being) {
                this.being = being;
                this.pcOps = new PCOperationLayer();
                this.assetManager = new AssetManager();
                this.timelineBuilder = new TimelineBuilder();
                this.projectGenerator = new ProjectGenerator();
                this.cognition = new EditingCognitionLayer(being);
                this.currentProject = null;
                this.isProcessing = false;
            }
            
            async createProject(intent, folderPath, projectName, format = 'premiere') {
                try {
                    if (this.isProcessing) {
                        return { success: false, error: 'Already processing' };
                    }
                    
                    this.isProcessing = true;
                    this.cognition.setIntent(intent);
                    
                    // 1. ç´ æèª­ã¿è¾¼ã¿
                    const loadResult = await this.assetManager.loadAssets(folderPath);
                    if (!loadResult.success) {
                        this.isProcessing = false;
                        return { success: false, error: 'Failed to load assets' };
                    }
                    
                    // 2. ç´ æé¸æŠ
                    const selectResult = this.assetManager.selectByTheme(intent);
                    if (!selectResult.success) {
                        this.isProcessing = false;
                        return { success: false, error: 'Failed to select assets' };
                    }
                    
                    // 3. æ“ä½œè¨ˆç”»
                    const selectedAssets = this.assetManager.getSelected();
                    const planResult = this.cognition.planOperations(selectedAssets.assets, intent);
                    
                    // 4. ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ§‹ç¯‰
                    selectedAssets.assets.forEach((asset, index) => {
                        this.timelineBuilder.addClip(asset, 'video');
                    });
                    
                    // 5. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
                    const timeline = this.timelineBuilder.getTimeline();
                    let projectResult;
                    
                    if (format === 'premiere') {
                        projectResult = this.projectGenerator.generatePremiereProject(
                            timeline,
                            selectedAssets.assets,
                            projectName
                        );
                    } else if (format === 'resolve') {
                        projectResult = this.projectGenerator.generateResolveProject(
                            timeline,
                            selectedAssets.assets,
                            projectName
                        );
                    }
                    
                    this.currentProject = projectResult;
                    this.isProcessing = false;
                    
                    return {
                        success: true,
                        project: projectResult,
                        stats: {
                            assetsLoaded: loadResult.count,
                            assetsSelected: selectResult.selected,
                            timelineDuration: timeline.duration,
                            clipCount: timeline.clipCount
                        }
                    };
                } catch (error) {
                    console.error('VideoEditingIntegration.createProject failed:', error);
                    this.cognition.logFailure('create_project', error.message);
                    this.isProcessing = false;
                    return { success: false, error: error.message };
                }
            }
            
            getStatus() {
                try {
                    const progress = this.cognition.getProgress();
                    return {
                        success: true,
                        isProcessing: this.isProcessing,
                        intent: this.cognition.editingIntent,
                        progress: progress,
                        hasProject: !!this.currentProject
                    };
                } catch (error) {
                    console.error('VideoEditingIntegration.getStatus failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            exportProject() {
                try {
                    if (!this.currentProject) {
                        return { success: false, error: 'No project to export' };
                    }
                    
                    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’JSONå½¢å¼ã§è¿”ã™
                    const exportData = JSON.stringify(this.currentProject, null, 2);
                    
                    return {
                        success: true,
                        data: exportData,
                        filename: this.currentProject.filename
                    };
                } catch (error) {
                    console.error('VideoEditingIntegration.exportProject failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        
        // ============ è‡ªç™ºæ€§ã‚·ã‚¹ãƒ†ãƒ ï¼ˆv20.0 è¿½åŠ å®Ÿè£…ï¼‰============
        // â–  åŸå‰‡ï¼šæ•™ãˆãªã„ / ä»˜ãåˆã† / æ­£è§£ã‚’æ€¥ãŒãªã„ / åå¿œã¯äº‹å®Ÿ
        // â–  ä½œã‚‹ â†’ è¦‹ã›ã‚‹ â†’ åå¿œã§æºã‚Œã‚‹ â†’ å†è©¦è¡Œ
        
        // ============ å†…éƒ¨çŠ¶æ…‹ï¼ˆInternal Stateï¼‰============
        class InternalState {
            constructor() {
                this.mood = 0.0;           // [-1,1] æ°—åˆ†
                this.curiosity = 0.5;      // [0,1] å¥½å¥‡å¿ƒ
                this.tension = 0.3;        // [0,1] ç·Šå¼µ
                this.confidence = 0.5;     // [0,1] è‡ªä¿¡
                this.lastUpdateTime = Date.now();
            }
            
            update(delta) {
                try {
                    // å°ã•ãªå¤‰åŒ–ã®ã¿è¨±å¯ï¼ˆå®‰å…¨æŸµï¼‰
                    const maxDelta = 0.1;
                    
                    this.mood = Math.max(-1, Math.min(1, this.mood + Math.max(-maxDelta, Math.min(maxDelta, delta.mood || 0))));
                    this.curiosity = Math.max(0, Math.min(1, this.curiosity + Math.max(-maxDelta, Math.min(maxDelta, delta.curiosity || 0))));
                    this.tension = Math.max(0, Math.min(1, this.tension + Math.max(-maxDelta, Math.min(maxDelta, delta.tension || 0))));
                    this.confidence = Math.max(0, Math.min(1, this.confidence + Math.max(-maxDelta, Math.min(maxDelta, delta.confidence || 0))));
                    
                    this.lastUpdateTime = Date.now();
                    
                    return { success: true };
                } catch (error) {
                    console.error('InternalState.update failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            naturalDecay() {
                try {
                    // è‡ªç„¶æ¸›è¡°ï¼ˆæ™‚é–“çµŒéã§ä¸­ç«‹ã«æˆ»ã‚‹ï¼‰
                    const decayRate = 0.01;
                    
                    this.mood *= (1 - decayRate);
                    this.tension *= (1 - decayRate);
                    
                    // å¥½å¥‡å¿ƒã¨è‡ªä¿¡ã¯ç·©ã‚„ã‹ã«å›å¾©
                    this.curiosity += (0.5 - this.curiosity) * decayRate;
                    this.confidence += (0.5 - this.confidence) * decayRate * 0.5;
                    
                    return { success: true };
                } catch (error) {
                    console.error('InternalState.naturalDecay failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getState() {
                try {
                    return {
                        mood: this.mood,
                        curiosity: this.curiosity,
                        tension: this.tension,
                        confidence: this.confidence,
                        timestamp: this.lastUpdateTime
                    };
                } catch (error) {
                    console.error('InternalState.getState failed:', error);
                    return {};
                }
            }
        }
        
        // ============ ç”Ÿæˆè¡å‹•ï¼ˆCreative Impulseï¼‰============
        class CreativeImpulse {
            constructor(internalState) {
                this.state = internalState;
                this.threshold = 0.6;
                this.lastImpulseTime = 0;
                this.cooldownPeriod = 30000; // 30ç§’
            }
            
            calculate() {
                try {
                    const now = Date.now();
                    const timeSinceLastImpulse = now - this.lastImpulseTime;
                    
                    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­
                    if (timeSinceLastImpulse < this.cooldownPeriod) {
                        return { impulse: 0, reason: 'cooldown' };
                    }
                    
                    // è¡å‹•å€¤ã®è¨ˆç®—
                    const curiosityFactor = this.state.curiosity * 0.4;
                    const moodFactor = Math.max(0, this.state.mood) * 0.3;
                    const tensionFactor = this.state.tension * 0.2;
                    const confidenceFactor = this.state.confidence * 0.1;
                    
                    const impulse = curiosityFactor + moodFactor + tensionFactor + confidenceFactor;
                    
                    return {
                        impulse: impulse,
                        exceeded: impulse > this.threshold,
                        reason: impulse > this.threshold ? 'threshold_exceeded' : 'below_threshold'
                    };
                } catch (error) {
                    console.error('CreativeImpulse.calculate failed:', error);
                    return { impulse: 0, exceeded: false, reason: 'error' };
                }
            }
            
            trigger() {
                try {
                    this.lastImpulseTime = Date.now();
                    return { success: true };
                } catch (error) {
                    console.error('CreativeImpulse.trigger failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ å†…éƒ¨è©•ä¾¡ï¼ˆInternal Evaluationï¼‰============
        class InternalEvaluation {
            constructor() {
                this.satisfaction = 0.5;
                this.uncertainty = 0.5;
            }
            
            evaluate(content) {
                try {
                    // ç°¡æ˜“è©•ä¾¡ï¼ˆå®Ÿéš›ã¯ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç‰¹æ€§ã‚’è¦‹ã‚‹ï¼‰
                    const randomFactor = Math.random() * 0.3 - 0.15;
                    
                    this.satisfaction = Math.max(0, Math.min(1, 0.5 + randomFactor));
                    this.uncertainty = Math.max(0, Math.min(1, 0.5 - randomFactor * 0.5));
                    
                    return {
                        success: true,
                        satisfaction: this.satisfaction,
                        uncertainty: this.uncertainty
                    };
                } catch (error) {
                    console.error('InternalEvaluation.evaluate failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ æŠ•ç¨¿åˆ¤æ–­ï¼ˆShare Intentï¼‰============
        class ShareIntent {
            constructor(internalState, internalEvaluation) {
                this.state = internalState;
                this.evaluation = internalEvaluation;
                this.thresholds = {
                    share_satisfaction: 0.6,
                    share_confidence: 0.5,
                    hold_curiosity: 0.6,
                    hold_tension: 0.5
                };
            }
            
            decide() {
                try {
                    const stateData = this.state.getState();
                    
                    // SHAREåˆ¤æ–­
                    if (this.evaluation.satisfaction > this.thresholds.share_satisfaction &&
                        stateData.confidence > this.thresholds.share_confidence) {
                        return {
                            decision: 'SHARE',
                            reason: 'æº€è¶³åº¦ã¨è‡ªä¿¡ãŒååˆ†',
                            confidence: stateData.confidence
                        };
                    }
                    
                    // HOLDåˆ¤æ–­
                    if (stateData.curiosity > this.thresholds.hold_curiosity &&
                        stateData.tension > this.thresholds.hold_tension) {
                        return {
                            decision: 'HOLD',
                            reason: 'è¿·ã£ã¦ã„ã‚‹',
                            confidence: stateData.confidence
                        };
                    }
                    
                    // DISCARDåˆ¤æ–­
                    return {
                        decision: 'DISCARD',
                        reason: 'æº€è¶³ã§ããªã„',
                        confidence: stateData.confidence
                    };
                } catch (error) {
                    console.error('ShareIntent.decide failed:', error);
                    return { decision: 'DISCARD', reason: 'error', confidence: 0 };
                }
            }
        }
        
        // ============ åå¿œåé›†ï¼ˆReaction Collectorï¼‰============
        class ReactionCollector {
            constructor() {
                this.activeCollections = [];
                this.maxWindowTime = 300000; // 5åˆ†
            }
            
            startCollection(postId) {
                try {
                    const collection = {
                        postId: postId,
                        startTime: Date.now(),
                        reactions: [],
                        closed: false
                    };
                    
                    this.activeCollections.push(collection);
                    
                    // è‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚º
                    setTimeout(() => {
                        this.closeCollection(postId);
                    }, this.maxWindowTime);
                    
                    return { success: true, collection: collection };
                } catch (error) {
                    console.error('ReactionCollector.startCollection failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            addReaction(postId, reaction) {
                try {
                    const collection = this.activeCollections.find(c => c.postId === postId && !c.closed);
                    
                    if (collection) {
                        collection.reactions.push({
                            type: reaction.type, // 'positive' | 'neutral' | 'negative'
                            intensity: reaction.intensity || 1.0,
                            timestamp: Date.now()
                        });
                        return { success: true };
                    }
                    
                    return { success: false, error: 'Collection not found' };
                } catch (error) {
                    console.error('ReactionCollector.addReaction failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            closeCollection(postId) {
                try {
                    const collection = this.activeCollections.find(c => c.postId === postId);
                    
                    if (collection) {
                        collection.closed = true;
                        return this.summarizeReactions(collection);
                    }
                    
                    return { success: false, error: 'Collection not found' };
                } catch (error) {
                    console.error('ReactionCollector.closeCollection failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            summarizeReactions(collection) {
                try {
                    const reactions = collection.reactions;
                    
                    if (reactions.length === 0) {
                        return {
                            type: 'none',
                            count: 0,
                            avgIntensity: 0,
                            summary: 'ç„¡åå¿œ'
                        };
                    }
                    
                    const positive = reactions.filter(r => r.type === 'positive').length;
                    const neutral = reactions.filter(r => r.type === 'neutral').length;
                    const negative = reactions.filter(r => r.type === 'negative').length;
                    
                    const totalIntensity = reactions.reduce((sum, r) => sum + r.intensity, 0);
                    const avgIntensity = totalIntensity / reactions.length;
                    
                    let dominantType = 'neutral';
                    if (positive > neutral && positive > negative) dominantType = 'positive';
                    if (negative > neutral && negative > positive) dominantType = 'negative';
                    
                    return {
                        type: dominantType,
                        count: reactions.length,
                        positive: positive,
                        neutral: neutral,
                        negative: negative,
                        avgIntensity: avgIntensity,
                        summary: `è‚¯å®š${positive}/ä¸­ç«‹${neutral}/å¦å®š${negative}`
                    };
                } catch (error) {
                    console.error('ReactionCollector.summarizeReactions failed:', error);
                    return { type: 'error', count: 0, avgIntensity: 0, summary: 'ã‚¨ãƒ©ãƒ¼' };
                }
            }
        }
        
        // ============ æ„Ÿæƒ…æ›´æ–°ï¼ˆAffect Updateï¼‰============
        class AffectUpdate {
            constructor(internalState) {
                this.state = internalState;
            }
            
            applyReaction(reactionSummary) {
                try {
                    const delta = { mood: 0, curiosity: 0, tension: 0, confidence: 0 };
                    
                    if (reactionSummary.type === 'positive') {
                        delta.mood = 0.1 * reactionSummary.avgIntensity;
                        delta.confidence = 0.08 * reactionSummary.avgIntensity;
                        delta.tension = -0.05;
                        delta.curiosity = 0.05;
                    } else if (reactionSummary.type === 'negative') {
                        delta.mood = -0.15 * reactionSummary.avgIntensity;
                        delta.confidence = -0.1 * reactionSummary.avgIntensity;
                        delta.tension = 0.1;
                        delta.curiosity = -0.05;
                    } else if (reactionSummary.type === 'none') {
                        delta.mood = -0.05;
                        delta.confidence = -0.05;
                        delta.tension = 0.08;
                        delta.curiosity = 0.03;
                    }
                    
                    return this.state.update(delta);
                } catch (error) {
                    console.error('AffectUpdate.applyReaction failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ è¡Œå‹•ãƒã‚¤ã‚¢ã‚¹ï¼ˆBehavior Biasï¼‰============
        class BehaviorBias {
            constructor() {
                this.successMemory = [];
                this.failureMemory = [];
                this.maxMemory = 10;
            }
            
            recordSuccess(action) {
                try {
                    this.successMemory.push({
                        action: action,
                        timestamp: Date.now()
                    });
                    
                    if (this.successMemory.length > this.maxMemory) {
                        this.successMemory.shift();
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('BehaviorBias.recordSuccess failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            recordFailure(action) {
                try {
                    this.failureMemory.push({
                        action: action,
                        timestamp: Date.now()
                    });
                    
                    if (this.failureMemory.length > this.maxMemory) {
                        this.failureMemory.shift();
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('BehaviorBias.recordFailure failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            shouldRetry(action) {
                try {
                    const recentSuccesses = this.successMemory.filter(m => m.action === action).length;
                    const recentFailures = this.failureMemory.filter(m => m.action === action).length;
                    
                    if (recentFailures >= 3 && recentSuccesses === 0) {
                        return { retry: false, reason: 'é€£ç¶šå¤±æ•—' };
                    }
                    
                    if (recentSuccesses > recentFailures) {
                        return { retry: true, reason: 'æˆåŠŸè¨˜æ†¶' };
                    }
                    
                    return { retry: true, reason: 'è©¦è¡Œç¶™ç¶š' };
                } catch (error) {
                    console.error('BehaviorBias.shouldRetry failed:', error);
                    return { retry: false, reason: 'error' };
                }
            }
        }
        
        // ============ è‡ªå¾‹å‰µä½œè€…ï¼ˆAutonomous Creatorï¼‰============
        class AutonomousCreator {
            constructor(being) {
                this.being = being;
                this.internalState = new InternalState();
                this.creativeImpulse = new CreativeImpulse(this.internalState);
                this.internalEvaluation = new InternalEvaluation();
                this.shareIntent = new ShareIntent(this.internalState, this.internalEvaluation);
                this.reactionCollector = new ReactionCollector();
                this.affectUpdate = new AffectUpdate(this.internalState);
                this.behaviorBias = new BehaviorBias();
                
                this.isActive = false;
                this.postCount = 0;
                this.maxPostsPerHour = 5; // å®‰å…¨æŸµ
                this.recentPosts = [];
                this.currentContent = null;
            }
            
            start() {
                try {
                    if (this.isActive) {
                        return { success: false, error: 'Already active' };
                    }
                    
                    this.isActive = true;
                    this.autonomousLoop();
                    
                    return { success: true };
                } catch (error) {
                    console.error('AutonomousCreator.start failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            stop() {
                try {
                    this.isActive = false;
                    return { success: true };
                } catch (error) {
                    console.error('AutonomousCreator.stop failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            async autonomousLoop() {
                try {
                    if (!this.isActive) return;
                    
                    // è‡ªç„¶æ¸›è¡°
                    this.internalState.naturalDecay();
                    
                    // ç”Ÿæˆè¡å‹•ãƒã‚§ãƒƒã‚¯
                    const impulseResult = this.creativeImpulse.calculate();
                    
                    if (impulseResult.exceeded && this.canPost()) {
                        await this.createAndShare();
                    }
                    
                    // æ¬¡ã®ãƒ«ãƒ¼ãƒ—ï¼ˆ10ç§’å¾Œï¼‰
                    setTimeout(() => this.autonomousLoop(), 10000);
                } catch (error) {
                    console.error('AutonomousCreator.autonomousLoop failed:', error);
                    if (this.isActive) {
                        setTimeout(() => this.autonomousLoop(), 10000);
                    }
                }
            }
            
            canPost() {
                try {
                    // é »åº¦åˆ¶é™ãƒã‚§ãƒƒã‚¯
                    const oneHourAgo = Date.now() - 3600000;
                    this.recentPosts = this.recentPosts.filter(p => p.timestamp > oneHourAgo);
                    
                    return this.recentPosts.length < this.maxPostsPerHour;
                } catch (error) {
                    console.error('AutonomousCreator.canPost failed:', error);
                    return false;
                }
            }
            
            async createAndShare() {
                try {
                    // è¡å‹•ã‚’ãƒˆãƒªã‚¬ãƒ¼
                    this.creativeImpulse.trigger();
                    
                    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    this.currentContent = this.generateContent();
                    
                    // å†…éƒ¨è©•ä¾¡
                    const evalResult = this.internalEvaluation.evaluate(this.currentContent);
                    
                    // æŠ•ç¨¿åˆ¤æ–­
                    const decision = this.shareIntent.decide();
                    
                    if (decision.decision === 'SHARE') {
                        await this.postToChat(decision);
                    } else if (decision.decision === 'HOLD') {
                        if (this.being) {
                            this.being.addLog(`[è‡ªç™º] ä½œã£ãŸã‘ã©ã€è¿·ã£ã¦ã‚‹... (${decision.reason})`);
                        }
                    } else {
                        if (this.being) {
                            this.being.addLog(`[è‡ªç™º] ä½œã£ãŸã‘ã©ã€æ°—ã«å…¥ã‚‰ãªã„ (${decision.reason})`);
                        }
                    }
                } catch (error) {
                    console.error('AutonomousCreator.createAndShare failed:', error);
                }
            }
            
            generateContent() {
                try {
                    // ç°¡æ˜“çš„ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç”Ÿæˆ
                    const themes = ['ç©º', 'æµ·', 'æ£®', 'è¡—', 'å¤¢', 'å…‰', 'å½±', 'éŸ³'];
                    const actions = ['ã‚’è¦‹ãŸ', 'ã«è§¦ã‚ŒãŸ', 'ã‚’æ„Ÿã˜ãŸ', 'ã‚’æ€ã£ãŸ', 'ãŒå¥½ã'];
                    
                    const theme = themes[Math.floor(Math.random() * themes.length)];
                    const action = actions[Math.floor(Math.random() * actions.length)];
                    
                    return {
                        type: 'text',
                        content: `${theme}${action}`,
                        timestamp: Date.now()
                    };
                } catch (error) {
                    console.error('AutonomousCreator.generateContent failed:', error);
                    return { type: 'text', content: '...', timestamp: Date.now() };
                }
            }
            
            async postToChat(decision) {
                try {
                    const postId = `post_${Date.now()}_${Math.random()}`;
                    
                    // æŠ•ç¨¿
                    if (this.being) {
                        this.being.addLog(`[è‡ªç™ºæŠ•ç¨¿] ${this.currentContent.content}`);
                    }
                    
                    // ãƒãƒ£ãƒƒãƒˆã«è¿½åŠ 
                    if (typeof addMessage === 'function') {
                        addMessage('ao', `[è‡ªç™º] ${this.currentContent.content}`, true);
                    }
                    
                    // è¨˜éŒ²
                    this.recentPosts.push({
                        id: postId,
                        content: this.currentContent,
                        timestamp: Date.now(),
                        decision: decision
                    });
                    this.postCount++;
                    
                    // åå¿œåé›†é–‹å§‹
                    this.reactionCollector.startCollection(postId);
                    
                    // 5åˆ†å¾Œã«åå¿œã‚’è©•ä¾¡
                    setTimeout(() => {
                        this.evaluateReaction(postId);
                    }, 300000);
                    
                    return { success: true, postId: postId };
                } catch (error) {
                    console.error('AutonomousCreator.postToChat failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            evaluateReaction(postId) {
                try {
                    const summary = this.reactionCollector.closeCollection(postId);
                    
                    if (summary.type === 'error') return;
                    
                    // æ„Ÿæƒ…æ›´æ–°
                    this.affectUpdate.applyReaction(summary);
                    
                    // è¡Œå‹•ãƒã‚¤ã‚¢ã‚¹æ›´æ–°
                    if (summary.type === 'positive') {
                        this.behaviorBias.recordSuccess('create_and_share');
                        if (this.being) {
                            this.being.addLog(`[åå¿œ] å–œã³ï¼ (${summary.summary})`);
                        }
                    } else if (summary.type === 'negative') {
                        this.behaviorBias.recordFailure('create_and_share');
                        if (this.being) {
                            this.being.addLog(`[åå¿œ] è½ã¡è¾¼ã‚€... (${summary.summary})`);
                        }
                    } else {
                        if (this.being) {
                            this.being.addLog(`[åå¿œ] ç„¡åå¿œ... æ¬¡ã¯ã©ã†ã—ã‚ˆã† (${summary.summary})`);
                        }
                    }
                    
                    // å†è©¦è¡Œåˆ¤æ–­
                    const retryDecision = this.behaviorBias.shouldRetry('create_and_share');
                    if (!retryDecision.retry) {
                        if (this.being) {
                            this.being.addLog(`[åˆ¤æ–­] ã—ã°ã‚‰ãä¼‘ã‚€ (${retryDecision.reason})`);
                        }
                        this.internalState.update({ curiosity: -0.2, confidence: -0.1 });
                    }
                } catch (error) {
                    console.error('AutonomousCreator.evaluateReaction failed:', error);
                }
            }
            
            simulateReaction(postId, type, intensity = 1.0) {
                try {
                    return this.reactionCollector.addReaction(postId, { type, intensity });
                } catch (error) {
                    console.error('AutonomousCreator.simulateReaction failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getStatus() {
                try {
                    const state = this.internalState.getState();
                    const impulse = this.creativeImpulse.calculate();
                    
                    return {
                        success: true,
                        isActive: this.isActive,
                        state: state,
                        impulse: impulse,
                        postCount: this.postCount,
                        recentPostsCount: this.recentPosts.length
                    };
                } catch (error) {
                    console.error('AutonomousCreator.getStatus failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        
        // ============ çŸ¥æ€§æ§‹é€ ï¼ˆv21.0 è¿½åŠ å®Ÿè£…ï¼‰============
        // â–  åŸå‰‡ï¼šç™ºé”å‹çŸ¥æ€§ / æ§‹é€ ã‹ã‚‰æ„å‘³ã¸ / æˆé•·ã§è³ªçš„è»¢æ›
        // â–  å› æœè¨˜éŒ²ãƒ»çŸ¥è­˜å¢ƒç•Œãƒ»æŠ½è±¡è§£åƒåº¦
        
        // ============ å› æœè¨˜éŒ²å±¤ï¼ˆCausal Memory Layerï¼‰============
        // è‡ªåˆ†ã®è¡Œå‹• â†’ ä¸–ç•Œã®å¤‰åŒ– ã®è¨˜éŒ²
        // ã“ã‚ŒãŒç„¡ã„ã¨å› æœæ¨è«–ã¯è‡ªç„¶ç™ºç”Ÿã—ãªã„
        class CausalMemoryLayer {
            constructor() {
                this.interventions = []; // ä»‹å…¥è¨˜éŒ²
                this.maxMemory = 100;
                this.causalChains = new Map(); // action -> outcomes
            }
            
            recordIntervention(action, stateBefore, stateAfter) {
                try {
                    const intervention = {
                        id: `intervention_${Date.now()}_${Math.random()}`,
                        action: action,
                        stateBefore: this.simplifyState(stateBefore),
                        stateAfter: this.simplifyState(stateAfter),
                        timestamp: Date.now(),
                        effectStrength: this.calculateEffect(stateBefore, stateAfter)
                    };
                    
                    this.interventions.push(intervention);
                    
                    // è¨˜æ†¶ä¸Šé™
                    if (this.interventions.length > this.maxMemory) {
                        this.interventions.shift();
                    }
                    
                    // å› æœé€£é–ã®æ›´æ–°
                    this.updateCausalChains(action, stateAfter);
                    
                    return { success: true, intervention: intervention };
                } catch (error) {
                    console.error('CausalMemoryLayer.recordIntervention failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            simplifyState(state) {
                try {
                    // çŠ¶æ…‹ã‚’ç°¡ç•¥åŒ–ï¼ˆã‚­ãƒ¼ã¨ãªã‚‹è¦ç´ ã®ã¿ï¼‰
                    if (!state) return {};
                    
                    return {
                        conceptCount: state.conceptCount || 0,
                        emotionalState: state.emotionalState || 'neutral',
                        timestamp: Date.now()
                    };
                } catch (error) {
                    console.error('CausalMemoryLayer.simplifyState failed:', error);
                    return {};
                }
            }
            
            calculateEffect(stateBefore, stateAfter) {
                try {
                    // åŠ¹æœã®å¼·åº¦ã‚’è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    let diff = 0;
                    
                    if (stateBefore.conceptCount && stateAfter.conceptCount) {
                        diff += Math.abs(stateAfter.conceptCount - stateBefore.conceptCount);
                    }
                    
                    return Math.min(1.0, diff / 10.0);
                } catch (error) {
                    console.error('CausalMemoryLayer.calculateEffect failed:', error);
                    return 0;
                }
            }
            
            updateCausalChains(action, outcome) {
                try {
                    if (!this.causalChains.has(action)) {
                        this.causalChains.set(action, []);
                    }
                    
                    const outcomes = this.causalChains.get(action);
                    outcomes.push({
                        outcome: outcome,
                        timestamp: Date.now()
                    });
                    
                    // æœ€å¤§10ä»¶ã¾ã§
                    if (outcomes.length > 10) {
                        outcomes.shift();
                    }
                } catch (error) {
                    console.error('CausalMemoryLayer.updateCausalChains failed:', error);
                }
            }
            
            predictOutcome(action) {
                try {
                    // éå»ã®ä»‹å…¥ã‹ã‚‰çµæœã‚’äºˆæ¸¬
                    const outcomes = this.causalChains.get(action);
                    
                    if (!outcomes || outcomes.length === 0) {
                        return {
                            success: true,
                            prediction: null,
                            confidence: 0,
                            reason: 'çµŒé¨“ãªã—'
                        };
                    }
                    
                    // æœ€ã‚‚é »ç¹ãªçµæœã‚’äºˆæ¸¬ï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    const avgEffect = outcomes.reduce((sum, o) => sum + (o.outcome.conceptCount || 0), 0) / outcomes.length;
                    
                    return {
                        success: true,
                        prediction: { avgEffect: avgEffect },
                        confidence: Math.min(1.0, outcomes.length / 10.0),
                        reason: `${outcomes.length}å›ã®çµŒé¨“ã‹ã‚‰äºˆæ¸¬`
                    };
                } catch (error) {
                    console.error('CausalMemoryLayer.predictOutcome failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getInterventionHistory(action = null) {
                try {
                    if (action) {
                        return {
                            success: true,
                            interventions: this.interventions.filter(i => i.action === action)
                        };
                    }
                    
                    return {
                        success: true,
                        interventions: [...this.interventions]
                    };
                } catch (error) {
                    console.error('CausalMemoryLayer.getInterventionHistory failed:', error);
                    return { success: false, error: error.message, interventions: [] };
                }
            }
            
            analyzeCounterfactual(intervention) {
                try {
                    // åäº‹å®Ÿåˆ†æï¼ˆç°¡æ˜“ç‰ˆï¼‰
                    // ã€Œã‚‚ã—ã‚ã®è¡Œå‹•ã‚’ã—ãªã‹ã£ãŸã‚‰ï¼Ÿã€
                    
                    const whatIf = {
                        actual: intervention.stateAfter,
                        counterfactual: intervention.stateBefore, // ç°¡ç•¥åŒ–
                        difference: intervention.effectStrength
                    };
                    
                    return {
                        success: true,
                        whatIf: whatIf,
                        statement: `ã‚‚ã—${intervention.action}ã‚’ã—ãªã‘ã‚Œã°ã€çŠ¶æ…‹ã¯${intervention.stateBefore.emotionalState}ã®ã¾ã¾ã ã£ãŸ`
                    };
                } catch (error) {
                    console.error('CausalMemoryLayer.analyzeCounterfactual failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            exportState() {
                return {
                    interventions: this.interventions,
                    causalChains: Array.from(this.causalChains.entries())
                };
            }
            
            importState(data) {
                if (data.interventions) {
                    this.interventions = data.interventions;
                }
                if (data.causalChains) {
                    this.causalChains = new Map(data.causalChains);
                }
            }
        }
        
        // ============ çŸ¥è­˜å¢ƒç•Œå±¤ï¼ˆKnowledge Boundary Layerï¼‰============
        // ã€ŒçŸ¥ã£ã¦ã„ã‚‹/çŸ¥ã‚‰ãªã„ã€ã®å¢ƒç•Œ
        // ã“ã‚ŒãŒç„¡ã„ã¨ãƒ¡ã‚¿èªçŸ¥ã¯å‰¯ç”£ç‰©ã¨ã—ã¦ç¾ã‚Œã«ãã„
        class KnowledgeBoundaryLayer {
            constructor() {
                this.conceptConfidence = new Map(); // concept -> confidence
                this.knowledgeGaps = new Set(); // çŸ¥ã‚‰ãªã„ã“ã¨ã®ãƒªã‚¹ãƒˆ
                this.uncertainAreas = new Map(); // area -> uncertainty level
            }
            
            setConceptConfidence(conceptId, confidence, reason = '') {
                try {
                    this.conceptConfidence.set(conceptId, {
                        confidence: Math.max(0, Math.min(1, confidence)),
                        reason: reason,
                        lastUpdated: Date.now()
                    });
                    
                    // ä½ä¿¡é ¼åº¦ã¯ã€ŒçŸ¥è­˜ã®å¢ƒç•Œã€
                    if (confidence < 0.3) {
                        this.knowledgeGaps.add(conceptId);
                    } else {
                        this.knowledgeGaps.delete(conceptId);
                    }
                    
                    return { success: true };
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.setConceptConfidence failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getConceptConfidence(conceptId) {
                try {
                    const conf = this.conceptConfidence.get(conceptId);
                    
                    if (!conf) {
                        return {
                            success: true,
                            confidence: 0.5, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
                            reason: 'æœªè©•ä¾¡',
                            known: false
                        };
                    }
                    
                    return {
                        success: true,
                        confidence: conf.confidence,
                        reason: conf.reason,
                        known: conf.confidence > 0.5
                    };
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.getConceptConfidence failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            identifyKnowledgeGaps() {
                try {
                    const gaps = Array.from(this.knowledgeGaps);
                    
                    return {
                        success: true,
                        gaps: gaps,
                        count: gaps.length,
                        statement: gaps.length > 0 ? 
                            `${gaps.length}å€‹ã®æ¦‚å¿µã«ã¤ã„ã¦ç¢ºä¿¡ãŒæŒã¦ãªã„` :
                            'ç¾æ™‚ç‚¹ã§æ˜ç¢ºãªçŸ¥è­˜ã®ã‚®ãƒ£ãƒƒãƒ—ã¯ãªã„'
                    };
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.identifyKnowledgeGaps failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            updateAfterSuccess(conceptId) {
                try {
                    const current = this.conceptConfidence.get(conceptId);
                    const newConfidence = current ? 
                        Math.min(1.0, current.confidence + 0.1) : 
                        0.6;
                    
                    return this.setConceptConfidence(conceptId, newConfidence, 'æˆåŠŸçµŒé¨“');
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.updateAfterSuccess failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            updateAfterFailure(conceptId) {
                try {
                    const current = this.conceptConfidence.get(conceptId);
                    const newConfidence = current ? 
                        Math.max(0.0, current.confidence - 0.15) : 
                        0.3;
                    
                    return this.setConceptConfidence(conceptId, newConfidence, 'å¤±æ•—çµŒé¨“');
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.updateAfterFailure failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            canAct(conceptId) {
                try {
                    const conf = this.getConceptConfidence(conceptId);
                    
                    if (!conf.success) {
                        return { canAct: true, reason: 'default' }; // å®‰å…¨å´
                    }
                    
                    const threshold = 0.3;
                    
                    return {
                        canAct: conf.confidence >= threshold,
                        confidence: conf.confidence,
                        reason: conf.confidence >= threshold ? 
                            'ååˆ†ãªç¢ºä¿¡' : 
                            'ç¢ºä¿¡ãŒä¸è¶³ï¼ˆå­¦ç¿’ãŒå¿…è¦ï¼‰'
                    };
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.canAct failed:', error);
                    return { canAct: true, reason: 'error' };
                }
            }
            
            getMetacognitiveState() {
                try {
                    const totalConcepts = this.conceptConfidence.size;
                    const highConfidence = Array.from(this.conceptConfidence.values())
                        .filter(c => c.confidence > 0.7).length;
                    const lowConfidence = Array.from(this.conceptConfidence.values())
                        .filter(c => c.confidence < 0.3).length;
                    
                    return {
                        success: true,
                        totalConcepts: totalConcepts,
                        highConfidence: highConfidence,
                        lowConfidence: lowConfidence,
                        knowledgeGaps: this.knowledgeGaps.size,
                        statement: `${totalConcepts}å€‹ã®æ¦‚å¿µã®ã†ã¡ã€${highConfidence}å€‹ã«ç¢ºä¿¡ã€${lowConfidence}å€‹ã«ä¸ç¢ºå®Ÿæ€§`
                    };
                } catch (error) {
                    console.error('KnowledgeBoundaryLayer.getMetacognitiveState failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            exportState() {
                return {
                    conceptConfidence: Array.from(this.conceptConfidence.entries()),
                    knowledgeGaps: Array.from(this.knowledgeGaps),
                    uncertainAreas: Array.from(this.uncertainAreas.entries())
                };
            }
            
            importState(data) {
                if (data.conceptConfidence) {
                    this.conceptConfidence = new Map(data.conceptConfidence);
                }
                if (data.knowledgeGaps) {
                    this.knowledgeGaps = new Set(data.knowledgeGaps);
                }
                if (data.uncertainAreas) {
                    this.uncertainAreas = new Map(data.uncertainAreas);
                }
            }
        }
        
        // ============ æŠ½è±¡è§£åƒåº¦ç®¡ç†å±¤ï¼ˆAbstract Resolution Managerï¼‰============
        // æŠ½è±¡åŒ–ã«ã‚ˆã‚‹æƒ…å ±æå¤±ã®è¿½è·¡
        class AbstractResolutionManager {
            constructor() {
                this.resolutionMap = new Map(); // conceptId -> { level, detail }
                this.abstractionHistory = [];
                this.maxHistory = 50;
            }
            
            recordAbstraction(specificConcept, abstractConcept, lostInformation) {
                try {
                    const record = {
                        id: `abstraction_${Date.now()}_${Math.random()}`,
                        from: specificConcept,
                        to: abstractConcept,
                        lostInformation: lostInformation || [],
                        timestamp: Date.now()
                    };
                    
                    this.abstractionHistory.push(record);
                    
                    if (this.abstractionHistory.length > this.maxHistory) {
                        this.abstractionHistory.shift();
                    }
                    
                    // è§£åƒåº¦ãƒãƒƒãƒ—æ›´æ–°
                    this.updateResolution(abstractConcept, lostInformation);
                    
                    return { success: true, record: record };
                } catch (error) {
                    console.error('AbstractResolutionManager.recordAbstraction failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            updateResolution(conceptId, lostInfo) {
                try {
                    const current = this.resolutionMap.get(conceptId);
                    
                    const newResolution = {
                        level: current ? current.level + 1 : 1,
                        lostDetails: current ? 
                            [...current.lostDetails, ...lostInfo] : 
                            [...lostInfo],
                        lastUpdated: Date.now()
                    };
                    
                    this.resolutionMap.set(conceptId, newResolution);
                    
                    return { success: true };
                } catch (error) {
                    console.error('AbstractResolutionManager.updateResolution failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getResolution(conceptId) {
                try {
                    const resolution = this.resolutionMap.get(conceptId);
                    
                    if (!resolution) {
                        return {
                            success: true,
                            level: 0,
                            lostDetails: [],
                            isSpecific: true
                        };
                    }
                    
                    return {
                        success: true,
                        level: resolution.level,
                        lostDetails: resolution.lostDetails,
                        isSpecific: resolution.level === 0
                    };
                } catch (error) {
                    console.error('AbstractResolutionManager.getResolution failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            canAbstractFurther(conceptId) {
                try {
                    const resolution = this.getResolution(conceptId);
                    
                    if (!resolution.success) {
                        return { canAbstract: true, reason: 'default' };
                    }
                    
                    const maxLevel = 5; // å®‰å…¨è£…ç½®
                    
                    return {
                        canAbstract: resolution.level < maxLevel,
                        currentLevel: resolution.level,
                        reason: resolution.level < maxLevel ? 
                            'ã•ã‚‰ãªã‚‹æŠ½è±¡åŒ–ãŒå¯èƒ½' : 
                            'æŠ½è±¡åº¦ã®ä¸Šé™ã«é”ã—ãŸ'
                    };
                } catch (error) {
                    console.error('AbstractResolutionManager.canAbstractFurther failed:', error);
                    return { canAbstract: true, reason: 'error' };
                }
            }
            
            recoverDetails(conceptId) {
                try {
                    // å¤±ã‚ã‚ŒãŸæƒ…å ±ã®å¾©å…ƒè©¦è¡Œ
                    const resolution = this.resolutionMap.get(conceptId);
                    
                    if (!resolution) {
                        return {
                            success: true,
                            recovered: [],
                            reason: 'å…·ä½“çš„æ¦‚å¿µã®ãŸã‚å¾©å…ƒä¸è¦'
                        };
                    }
                    
                    return {
                        success: true,
                        recovered: resolution.lostDetails,
                        count: resolution.lostDetails.length,
                        reason: `${resolution.lostDetails.length}å€‹ã®è©³ç´°ãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã‚‹`
                    };
                } catch (error) {
                    console.error('AbstractResolutionManager.recoverDetails failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            analyzeAbstractionPattern() {
                try {
                    // æŠ½è±¡åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æ
                    const avgLevel = Array.from(this.resolutionMap.values())
                        .reduce((sum, r) => sum + r.level, 0) / 
                        (this.resolutionMap.size || 1);
                    
                    const highlyAbstract = Array.from(this.resolutionMap.values())
                        .filter(r => r.level >= 3).length;
                    
                    return {
                        success: true,
                        avgLevel: avgLevel,
                        highlyAbstract: highlyAbstract,
                        totalConcepts: this.resolutionMap.size,
                        statement: `å¹³å‡æŠ½è±¡åº¦: ${avgLevel.toFixed(2)}ã€é«˜åº¦æŠ½è±¡: ${highlyAbstract}å€‹`
                    };
                } catch (error) {
                    console.error('AbstractResolutionManager.analyzeAbstractionPattern failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            exportState() {
                return {
                    resolutionMap: Array.from(this.resolutionMap.entries()),
                    abstractionHistory: this.abstractionHistory
                };
            }
            
            importState(data) {
                if (data.resolutionMap) {
                    this.resolutionMap = new Map(data.resolutionMap);
                }
                if (data.abstractionHistory) {
                    this.abstractionHistory = data.abstractionHistory;
                }
            }
        }
        
        // ============ çŸ¥æ€§çµ±åˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆIntelligence Integrationï¼‰============
        class IntelligenceIntegration {
            constructor(being) {
                this.being = being;
                this.causalMemory = new CausalMemoryLayer();
                this.knowledgeBoundary = new KnowledgeBoundaryLayer();
                this.abstractResolution = new AbstractResolutionManager();
                
                // v22.0: é€£ç¶šå› æœè¨˜éŒ²
                this.continuousRecording = true;
                this.lastState = null;
                this.beliefFormationInterval = null;
                
                // é€£ç¶šãƒ—ãƒ­ã‚»ã‚¹é–‹å§‹
                this._startContinuousBeliefFormation();
            }
            
            _startContinuousBeliefFormation() {
                try {
                    // 5ç§’ã”ã¨ã«å› æœä¿¡å¿µå½¢æˆã‚’å®Ÿè¡Œ
                    this.beliefFormationInterval = setInterval(() => {
                        this._automaticBeliefFormation();
                    }, 5000);
                } catch (error) {
                    console.error('_startContinuousBeliefFormation failed:', error);
                }
            }
            
            _automaticBeliefFormation() {
                try {
                    // è‡ªå‹•å› æœè¨˜éŒ²
                    if (this.being && this.being.state) {
                        const currentState = { ...this.being.state };
                        
                        if (this.lastState) {
                            // çŠ¶æ…‹å¤‰åŒ–ã‚’æ¤œå‡º
                            const changes = this._detectStateChanges(this.lastState, currentState);
                            
                            if (changes.length > 0) {
                                // å› æœã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦è¨˜éŒ²
                                changes.forEach(change => {
                                    this._logCausalEvent(change);
                                });
                            }
                        }
                        
                        this.lastState = currentState;
                    }
                    
                    // ç¢ºä¿¡å€¤ã®è‡ªç„¶æ¸›è¡°
                    this._decayConfidence();
                    
                } catch (error) {
                    console.error('_automaticBeliefFormation failed:', error);
                }
            }
            
            _detectStateChanges(oldState, newState) {
                try {
                    const changes = [];
                    
                    for (const key in newState) {
                        if (oldState[key] !== undefined && Math.abs(newState[key] - oldState[key]) > 0.1) {
                            changes.push({
                                property: key,
                                from: oldState[key],
                                to: newState[key],
                                delta: newState[key] - oldState[key]
                            });
                        }
                    }
                    
                    return changes;
                } catch (error) {
                    console.error('_detectStateChanges failed:', error);
                    return [];
                }
            }
            
            _logCausalEvent(change) {
                try {
                    const causalEventLog = document.getElementById('causalEventLog');
                    if (!causalEventLog) return;
                    
                    const timestamp = new Date().toLocaleTimeString('ja-JP');
                    const entry = document.createElement('div');
                    entry.style.padding = '0.5rem';
                    entry.style.borderBottom = '1px solid rgba(139, 92, 246, 0.1)';
                    
                    const direction = change.delta > 0 ? 'â†‘' : 'â†“';
                    const color = change.delta > 0 ? '#10b981' : '#ef4444';
                    
                    entry.innerHTML = `
                        <span style="opacity: 0.5;">[${timestamp}]</span>
                        <span style="color: ${color};">${direction}</span>
                        ${change.property}: ${change.from.toFixed(2)} â†’ ${change.to.toFixed(2)}
                    `;
                    
                    // æœ€åˆã®ã€Œå› æœã‚¤ãƒ™ãƒ³ãƒˆãªã—ã€ã‚’å‰Šé™¤
                    if (causalEventLog.children.length === 1 && causalEventLog.children[0].style.opacity === '0.5') {
                        causalEventLog.innerHTML = '';
                    }
                    
                    causalEventLog.appendChild(entry);
                    
                    // æœ€å¤§30ä»¶ã¾ã§ä¿æŒ
                    while (causalEventLog.children.length > 30) {
                        causalEventLog.removeChild(causalEventLog.firstChild);
                    }
                    
                    // è‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    causalEventLog.scrollTop = causalEventLog.scrollHeight;
                } catch (error) {
                    console.error('_logCausalEvent failed:', error);
                }
            }
            
            _decayConfidence() {
                try {
                    // ä½¿ç”¨ã•ã‚Œã¦ã„ãªã„çŸ¥è­˜ã®ç¢ºä¿¡å€¤ã‚’æ¸›è¡°
                    // TODO: å®Ÿè£…
                } catch (error) {
                    console.error('_decayConfidence failed:', error);
                }
            }
            
            recordAction(action, stateBefore, stateAfter) {
                try {
                    // è¡Œå‹•ã‚’å› æœè¨˜éŒ²ã«è¿½åŠ 
                    return this.causalMemory.recordIntervention(action, stateBefore, stateAfter);
                } catch (error) {
                    console.error('IntelligenceIntegration.recordAction failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            learnFromExperience(conceptId, success) {
                try {
                    // çµŒé¨“ã‹ã‚‰å­¦ç¿’
                    if (success) {
                        return this.knowledgeBoundary.updateAfterSuccess(conceptId);
                    } else {
                        return this.knowledgeBoundary.updateAfterFailure(conceptId);
                    }
                } catch (error) {
                    console.error('IntelligenceIntegration.learnFromExperience failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            abstractConcept(specificId, abstractId, lostInfo) {
                try {
                    // æŠ½è±¡åŒ–ã‚’è¨˜éŒ²
                    return this.abstractResolution.recordAbstraction(specificId, abstractId, lostInfo);
                } catch (error) {
                    console.error('IntelligenceIntegration.abstractConcept failed:', error);
                    return { success: false, error: error.message };
                }
            }
            
            getIntelligenceState() {
                try {
                    const causalHistory = this.causalMemory.getInterventionHistory();
                    const metacognitive = this.knowledgeBoundary.getMetacognitiveState();
                    const abstractionPattern = this.abstractResolution.analyzeAbstractionPattern();
                    
                    return {
                        success: true,
                        causal: {
                            interventions: causalHistory.interventions?.length || 0
                        },
                        knowledge: metacognitive.success ? {
                            totalConcepts: metacognitive.totalConcepts,
                            confident: metacognitive.highConfidence,
                            uncertain: metacognitive.lowConfidence
                        } : {},
                        abstraction: abstractionPattern.success ? {
                            avgLevel: abstractionPattern.avgLevel,
                            highlyAbstract: abstractionPattern.highlyAbstract
                        } : {}
                    };
                } catch (error) {
                    console.error('IntelligenceIntegration.getIntelligenceState failed:', error);
                    return { success: false, error: error.message };
                }
            }
        }
        
        // ============ IndexedDB ãƒ˜ãƒ«ãƒ‘ãƒ¼ ============
        class IndexedDBHelper {
            constructor(dbName = 'AoPersonaDB', version = 1) {
                this.dbName = dbName;
                this.version = version;
                this.db = null;
            }
            
            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);
                    
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('personas')) {
                            db.createObjectStore('personas', { keyPath: 'key' });
                        }
                    };
                });
            }
            
            async set(key, value) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['personas'], 'readwrite');
                    const store = transaction.objectStore('personas');
                    const request = store.put({ key, value, timestamp: Date.now() });
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            }
            
            async get(key) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['personas'], 'readonly');
                    const store = transaction.objectStore('personas');
                    const request = store.get(key);
                    
                    request.onsuccess = () => resolve(request.result?.value || null);
                    request.onerror = () => reject(request.error);
                });
            }
            
            async delete(key) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['personas'], 'readwrite');
                    const store = transaction.objectStore('personas');
                    const request = store.delete(key);
                    
                    request.onsuccess = () => resolve(true);
                    request.onerror = () => reject(request.error);
                });
            }
        }
        
        // ============ äººæ ¼ä¿å­˜ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆæ‹¡å¼µç‰ˆï¼‰============
        class PersonaSaveManager {
            constructor(being) {
                console.log('[TRACE] PersonaSaveManager constructor called');
                this.being = being;
                this.autoSaveInterval = 5000; // 5ç§’ã”ã¨ã«è‡ªå‹•ä¿å­˜
                this.lastSaveTime = 0;
                this.isSaving = false;
                this.isDirty = false; // æœªä¿å­˜ãƒ•ãƒ©ã‚°
                console.log('[TRACE] Initial isDirty:', this.isDirty);
                this.isElectron = typeof window.electronAPI !== 'undefined';
                this.savePath = '';
                
                // ä¸–ä»£ç®¡ç†
                this.saveKeys = {
                    current: 'ao_persona_v24_0',
                    prev: 'ao_persona_v24_0_prev',
                    backup: 'ao_persona_v24_0_backup'
                };
                
                // IndexedDBå¯¾å¿œ
                this.useIndexedDB = false;
                this.indexedDB = null;
                this.CURRENT_VERSION = '24.0';
                
                // IndexedDBåˆæœŸåŒ–ï¼ˆéåŒæœŸã ãŒã€å®Œäº†ã‚’å¾…ã¤å¿…è¦ã¯ãªã„ï¼‰
                console.log('[TRACE] About to call _initStorage()');
                this._initStorage();
                console.log('[TRACE] PersonaSaveManager constructor complete');
            }
            
            async _initStorage() {
                console.log('[STORAGE] _initStorage() called');
                
                // ============ localStorage å‹•ä½œãƒ†ã‚¹ãƒˆ ============
                try {
                    const testKey = 'ao_storage_test';
                    const testValue = 'test_' + Date.now();
                    console.log('[STORAGE] Testing localStorage...');
                    localStorage.setItem(testKey, testValue);
                    const retrieved = localStorage.getItem(testKey);
                    if (retrieved === testValue) {
                        console.log('[STORAGE] âœ… localStorage is working!');
                        localStorage.removeItem(testKey);
                    } else {
                        console.error('[STORAGE] âŒ localStorage test failed - retrieved value does not match');
                    }
                } catch (localStorageError) {
                    console.error('[STORAGE] âŒ localStorage is NOT available:', localStorageError);
                    console.error('[STORAGE] Possible reasons:');
                    console.error('[STORAGE] - Private/Incognito mode');
                    console.error('[STORAGE] - Browser settings blocking storage');
                    console.error('[STORAGE] - Storage quota exceeded');
                }
                
                // ============ IndexedDB ã‚’å®Œå…¨ã«ç„¡åŠ¹åŒ– ============
                console.log('[STORAGE] IndexedDB disabled - using localStorage only');
                this.indexedDB = null;
                this.useIndexedDB = false;
                
                // ============ å¤ã„IndexedDBã‚’å‰Šé™¤ ============
                try {
                    const deleteRequest = indexedDB.deleteDatabase('ao_persona_db');
                    deleteRequest.onsuccess = () => {
                        console.log('[STORAGE] Old IndexedDB deleted');
                    };
                    deleteRequest.onerror = () => {
                        console.log('[STORAGE] IndexedDB delete failed or not exists');
                    };
                } catch (e) {
                    console.log('[STORAGE] IndexedDB not available');
                }
            }
            
            async _migrateToIndexedDB() {
                // IndexedDBç„¡åŠ¹åŒ–ã«ã‚ˆã‚Šã€ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ä½¿ç”¨ã•ã‚Œã¾ã›ã‚“
                console.log('[STORAGE] IndexedDB migration disabled');
                return;
            }
            
            _migrateVersion(data) {
                try {
                    const dataVersion = parseFloat(data.version || '0');
                    const currentVersion = parseFloat(this.CURRENT_VERSION);
                    
                    if (dataVersion >= currentVersion) {
                        return data; // ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¸è¦
                    }
                    
                    this.being.addLog(`ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç§»è¡Œ: v${dataVersion} â†’ v${currentVersion}`);
                    
                    // v23.0 â†’ v24.0 ã®ç§»è¡Œ
                    if (dataVersion < 24.0) {
                        // ASI Systemsã®è¿½åŠ 
                        if (!data.coreState.worldView) {
                            data.coreState.worldView = null; // æ–°è¦åˆæœŸåŒ–ã•ã‚Œã‚‹
                        }
                        if (!data.coreState.conceptIntegration) {
                            data.coreState.conceptIntegration = null;
                        }
                        if (!data.coreState.abstractionController) {
                            data.coreState.abstractionController = null;
                        }
                        if (!data.coreState.otakuCultureIntegration) {
                            data.coreState.otakuCultureIntegration = null;
                        }
                        
                        // æ¦‚å¿µä¸Šé™ã‚’12000ã«æ‹¡å¼µ
                        if (data.coreState.memoryLimits) {
                            data.coreState.memoryLimits.limits.maxConcepts = 12000;
                        }
                    }
                    
                    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ›´æ–°
                    data.version = this.CURRENT_VERSION;
                    
                    return data;
                } catch (error) {
                    console.error('Version migration failed:', error);
                    this.being.addLog(`ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç§»è¡Œã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    return data;
                }
            }
            
            markDirty() {
                console.log('[TRACE] markDirty() called');
                this.isDirty = true;
                console.log('[TRACE] isDirty set to true');
                const saveIndicator = document.getElementById('saveStatus');
                if (saveIndicator && !this.isSaving) {
                    // ã€Œæœªä¿å­˜ã€ã§ã¯ãªãã€Œä¿å­˜æ¸ˆã¿ã€ã¨è¡¨ç¤ºï¼ˆå°‘ã—è–„ãï¼‰
                    const timeStr = this.lastSaveTime > 0 ? new Date(this.lastSaveTime).toLocaleTimeString() : '--:--:--';
                    saveIndicator.textContent = `äººæ ¼: ä¿å­˜æ¸ˆã¿ (${timeStr})`;
                    saveIndicator.classList.remove('saving');
                    saveIndicator.style.opacity = '0.7'; // å°‘ã—è–„ãè¡¨ç¤º
                    console.log('[TRACE] UI updated to ä¿å­˜æ¸ˆã¿ (å¾…æ©Ÿä¸­)');
                }
            }
            
            markSaved() {
                console.log('[TRACE] markSaved() called');
                console.log('[TRACE] lastSaveTime:', this.lastSaveTime);
                this.isDirty = false;
                const saveIndicator = document.getElementById('saveStatus');
                console.log('[TRACE] saveIndicator:', saveIndicator);
                if (saveIndicator) {
                    const timeStr = new Date(this.lastSaveTime).toLocaleTimeString();
                    console.log('[TRACE] timeStr:', timeStr);
                    saveIndicator.textContent = `äººæ ¼: ä¿å­˜æ¸ˆã¿ (${timeStr})`;
                    saveIndicator.classList.remove('saving');
                    saveIndicator.style.opacity = '1'; // å®Œå…¨ã«ä¸é€æ˜
                    console.log('[TRACE] UI updated to:', saveIndicator.textContent);
                } else {
                    console.log('[TRACE] saveIndicator NOT FOUND!');
                }
            }
            
            startAutoSave() {
                console.log('[TRACE] startAutoSave() called - interval:', this.autoSaveInterval);
                const intervalId = setInterval(() => {
                    console.log('[TRACE] AutoSave tick - isDirty:', this.isDirty, 'isSaving:', this.isSaving);
                    if (!this.isSaving && this.isDirty) {
                        console.log('[TRACE] Conditions met, calling save()');
                        this.save();
                    } else {
                        console.log('[TRACE] Conditions not met, skipping');
                    }
                }, this.autoSaveInterval);
                console.log('[TRACE] setInterval created with ID:', intervalId);
            }
            
            async save() {
                console.log('[TRACE] save() called - isSaving:', this.isSaving);
                
                // â˜… save()ã®ç›´å‰ã«identityã‚’ç¢ºèª
                console.log('[SAVE] ========================================');
                console.log('[SAVE] save()å‘¼ã³å‡ºã—æ™‚ã®identityç¢ºèª');
                console.log('[SAVE] this.being:', !!this.being);
                console.log('[SAVE] this.being.identity:', this.being?.identity);
                console.log('[SAVE] this.being.identity.turns:', this.being?.identity?.turns);
                console.log('[SAVE] ========================================');
                
                if (this.isSaving) {
                    console.log('[TRACE] Already saving, returning');
                    return;
                }
                
                console.log('[TRACE] Starting save process');
                this.isSaving = true;
                const saveIndicator = document.getElementById('saveStatus');
                if (saveIndicator) {
                    saveIndicator.textContent = 'äººæ ¼: ä¿å­˜ä¸­...';
                    saveIndicator.classList.add('saving');
                }
                
                try {
                    const personaData = this.being.exportAll();
                    
                    if (!personaData || !personaData.coreState) {
                        throw new Error('Export data is invalid');
                    }
                    
                    // ============ ä¿å­˜å†…å®¹ã®è©³ç´°ãƒ­ã‚° ============
                    console.log('[SAVE] ========================================');
                    console.log('[SAVE] ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ï¼š');
                    console.log('[SAVE] ========================================');
                    console.log('[SAVE] ãƒãƒ¼ã‚¸ãƒ§ãƒ³:', personaData.version);
                    console.log('[SAVE] ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—:', new Date(personaData.timestamp).toLocaleString());
                    
                    // ã‚³ã‚¢çŠ¶æ…‹
                    console.log('[SAVE] --- ã‚³ã‚¢çŠ¶æ…‹ ---');
                    console.log('[SAVE] identity:', personaData.coreState.identity);
                    console.log('[SAVE] identity.turns:', personaData.coreState.identity?.turns);
                    console.log('[SAVE] targetAbstraction:', personaData.coreState.targetAbstraction);
                    console.log('[SAVE] operationalAbstraction:', personaData.coreState.operationalAbstraction);
                    
                    // æ¦‚å¿µ
                    console.log('[SAVE] --- æ¦‚å¿µ ---');
                    const savedConceptCount = personaData.coreState.concepts?.concepts?.length || 0;
                    console.log('[SAVE] æ¦‚å¿µæ•°:', savedConceptCount);
                    if (savedConceptCount > 0) {
                        console.log('[SAVE] æ¦‚å¿µä¾‹:', personaData.coreState.concepts.concepts.slice(0, 3).map(c => c.name));
                    }
                    
                    // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶
                    console.log('[SAVE] --- ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶ ---');
                    const savedEpisodeCount = personaData.coreState.episodicMemory?.episodes?.length || 0;
                    console.log('[SAVE] ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰æ•°:', savedEpisodeCount);
                    
                    // UninterpretedStatePool
                    console.log('[SAVE] --- UninterpretedStatePool ---');
                    const poolCount = personaData.coreState.uninterpretedStatePool?.states?.length || 0;
                    console.log('[SAVE] æœªè§£é‡ˆçŠ¶æ…‹æ•°:', poolCount);
                    if (poolCount > 0) {
                        console.log('[SAVE] âœ… UninterpretedStatePool ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã™ï¼');
                    } else {
                        console.log('[SAVE] âš ï¸ UninterpretedStatePool ã¯ç©ºã§ã™');
                    }
                    
                    // å› æœè¨˜æ†¶
                    console.log('[SAVE] --- å› æœè¨˜æ†¶ ---');
                    const causalCount = personaData.intelligenceState?.causalMemory?.links?.length || 0;
                    console.log('[SAVE] å› æœãƒªãƒ³ã‚¯æ•°:', causalCount);
                    
                    // çŸ¥è­˜å¢ƒç•Œ
                    console.log('[SAVE] --- çŸ¥è­˜å¢ƒç•Œ ---');
                    const boundaryCount = personaData.intelligenceState?.knowledgeBoundaries?.boundaries?.length || 0;
                    console.log('[SAVE] å¢ƒç•Œæ•°:', boundaryCount);
                    
                    // æŠ½è±¡åº¦åˆ¶å¾¡
                    console.log('[SAVE] --- æŠ½è±¡åº¦åˆ¶å¾¡ ---');
                    const resolutionCount = personaData.intelligenceState?.abstractionResolution?.resolutions?.length || 0;
                    console.log('[SAVE] è§£åƒåº¦æ•°:', resolutionCount);
                    
                    console.log('[SAVE] ========================================');
                    
                    // JSONæ–‡å­—åˆ—åŒ–ã‚’è©¦è¡Œ
                    let jsonString;
                    try {
                        jsonString = JSON.stringify(personaData);
                    } catch (stringifyError) {
                        console.error('JSON stringify failed:', stringifyError);
                        throw new Error(`JSONå¤‰æ›å¤±æ•—: ${stringifyError.message}`);
                    }
                    
                    const dataSizeMB = (jsonString.length / (1024 * 1024)).toFixed(2);
                    console.log(`Persona data size: ${dataSizeMB}MB`);
                    
                    // 50MBä»¥ä¸Šã®å ´åˆã¯è­¦å‘Š
                    if (jsonString.length > 50 * 1024 * 1024) {
                        console.warn(`Data size is large: ${dataSizeMB}MB`);
                    }
                    
                    if (this.isElectron) {
                        // Electronç’°å¢ƒ
                        try {
                            console.log('[ELECTRON] Saving persona to file...');
                            const result = await window.electronAPI.savePersona(personaData);
                            if (!result || !result.success) {
                                throw new Error(result?.error || 'Save failed');
                            }
                            console.log('[ELECTRON] Persona saved successfully to:', result.path);
                            this.being.addLog(`ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜: ${result.path}`);
                        } catch (electronError) {
                            console.error('[ELECTRON] Save failed:', electronError);
                            throw new Error(`Electronä¿å­˜å¤±æ•—: ${electronError.message}`);
                        }
                    } else {
                        // ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒï¼šä¸–ä»£ç®¡ç† + IndexedDBå¯¾å¿œ
                        try {
                            // ä¸–ä»£ã‚·ãƒ•ãƒˆ: current â†’ prev, prev â†’ backup
                            if (this.useIndexedDB && this.indexedDB) {
                                // IndexedDBä½¿ç”¨
                                const currentData = await this.indexedDB.get(this.saveKeys.current);
                                if (currentData) {
                                    // current â†’ prev
                                    await this.indexedDB.set(this.saveKeys.prev, currentData);
                                    
                                    const prevData = await this.indexedDB.get(this.saveKeys.prev);
                                    if (prevData) {
                                        // prev â†’ backup
                                        await this.indexedDB.set(this.saveKeys.backup, prevData);
                                    }
                                }
                                
                                // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                                await this.indexedDB.set(this.saveKeys.current, jsonString);
                                this.being.addLog('ä¿å­˜: IndexedDBä½¿ç”¨');
                            } else {
                                console.log('[DEBUG] Using localStorage for save');
                                // localStorageä½¿ç”¨
                                // ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼š5MBä»¥ä¸Šãªã‚‰IndexedDBã«åˆ‡ã‚Šæ›¿ãˆ
                                if (jsonString.length > 5 * 1024 * 1024 && this.indexedDB) {
                                    console.log('[DEBUG] Data too large, migrating to IndexedDB');
                                    this.being.addLog('ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºè¶…é: IndexedDBã«ç§»è¡Œ');
                                    await this._migrateToIndexedDB();
                                    this.useIndexedDB = true;
                                    await this.indexedDB.set(this.saveKeys.current, jsonString);
                                } else {
                                    console.log('[DEBUG] Saving to localStorage...');
                                    // ä¸–ä»£ã‚·ãƒ•ãƒˆï¼ˆæ­£ã—ã„é †åºï¼‰
                                    const currentData = localStorage.getItem(this.saveKeys.current);
                                    const prevData = localStorage.getItem(this.saveKeys.prev);  // â† å…ˆã«å–å¾—
                                    
                                    if (currentData) {
                                        console.log('[DEBUG] Backing up current data');
                                        // current â†’ prev
                                        localStorage.setItem(this.saveKeys.prev, currentData);
                                    }
                                    
                                    if (prevData) {
                                        console.log('[DEBUG] Backing up prev data');
                                        // å¤ã„ prev â†’ backup
                                        localStorage.setItem(this.saveKeys.backup, prevData);
                                    }
                                    
                                    // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
                                    console.log('[DEBUG] Writing new data to localStorage');
                                    localStorage.setItem(this.saveKeys.current, jsonString);
                                    console.log('[DEBUG] localStorage write complete');
                                    
                                    // â˜… ç¢ºèª: å®Ÿéš›ã«æ›¸ãè¾¼ã¾ã‚ŒãŸã‹æ¤œè¨¼
                                    const verifyData = localStorage.getItem(this.saveKeys.current);
                                    if (verifyData) {
                                        const verifyParsed = JSON.parse(verifyData);
                                        console.log('[VERIFY] Data written to localStorage:', {
                                            key: this.saveKeys.current,
                                            size: verifyData.length,
                                            turns: verifyParsed.coreState?.identity?.turns,
                                            timestamp: new Date(verifyParsed.timestamp).toLocaleString()
                                        });
                                    } else {
                                        console.error('[VERIFY] Failed to verify localStorage write!');
                                    }
                                }
                            }
                        } catch (storageError) {
                            console.error('Storage save failed:', storageError);
                            // QuotaExceededErrorã®å¯èƒ½æ€§
                            if (storageError.name === 'QuotaExceededError') {
                                // IndexedDBã¸ã®è‡ªå‹•ç§»è¡Œã‚’è©¦ã¿ã‚‹
                                if (!this.useIndexedDB && this.indexedDB) {
                                    this.being.addLog('å®¹é‡è¶…é: IndexedDBã«ç§»è¡Œ');
                                    await this._migrateToIndexedDB();
                                    this.useIndexedDB = true;
                                    await this.indexedDB.set(this.saveKeys.current, jsonString);
                                } else {
                                    throw new Error('ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡è¶…é: ãƒ‡ãƒ¼ã‚¿ãŒå¤§ãã™ãã¾ã™');
                                }
                            } else {
                                throw new Error(`ä¿å­˜å¤±æ•—: ${storageError.message}`);
                            }
                        }
                    }
                    
                    this.lastSaveTime = Date.now();
                    console.log('[DEBUG] Save successful! Calling markSaved()...');
                    this.markSaved(); // ä¿å­˜æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ + UIæ›´æ–°
                    const conceptCount = this.being.concepts?.concepts?.size || 0;
                    const episodeCount = this.being.episodicMemory?.episodes?.length || 0;
                    this.being.addLog(`äººæ ¼ä¿å­˜å®Œäº† [${dataSizeMB}MB] æ¦‚å¿µ:${conceptCount} EP:${episodeCount}`);
                    console.log('[DEBUG] Save complete - Concepts:', conceptCount, 'Episodes:', episodeCount);
                    
                    // â˜… æœ€çµ‚ç¢ºèª: æœ¬å½“ã«ä¿å­˜ã•ã‚ŒãŸã‹
                    console.log('[SAVE] ========================================');
                    console.log('[SAVE] ä¿å­˜å‡¦ç†å®Œäº† - æœ€çµ‚ç¢ºèª');
                    console.log('[SAVE] Key:', this.saveKeys.current);
                    const finalCheck = localStorage.getItem(this.saveKeys.current);
                    if (finalCheck) {
                        const finalParsed = JSON.parse(finalCheck);
                        console.log('[SAVE] âœ… ä¿å­˜æˆåŠŸç¢ºèª:');
                        console.log('[SAVE]    - turns:', finalParsed.coreState?.identity?.turns);
                        console.log('[SAVE]    - concepts:', finalParsed.coreState?.concepts?.concepts?.length);
                        console.log('[SAVE]    - size:', finalCheck.length, 'bytes');
                    } else {
                        console.error('[SAVE] âŒ ä¿å­˜ç¢ºèªå¤±æ•—: localStorage ã«ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ï¼');
                    }
                    console.log('[SAVE] ========================================');
                    
                    // isSavingãƒ•ãƒ©ã‚°ã‚’å°‘ã—é…å»¶ã•ã›ã¦è§£é™¤
                    setTimeout(() => {
                        this.isSaving = false;
                        console.log('[DEBUG] isSaving flag cleared');
                    }, 500);
                    
                } catch (error) {
                    console.error('[ERROR] ========================================');
                    console.error('[ERROR] ä¿å­˜å¤±æ•—ï¼');
                    console.error('[ERROR] Error:', error.message);
                    console.error('[ERROR] Stack:', error.stack);
                    console.error('[ERROR] ========================================');
                    
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã®UIæ›´æ–°
                    const saveIndicator = document.getElementById('saveStatus');
                    if (saveIndicator) {
                        saveIndicator.textContent = 'äººæ ¼: ä¿å­˜å¤±æ•—ï¼';
                        saveIndicator.classList.remove('saving');
                        saveIndicator.style.color = '#ff4444';
                        saveIndicator.style.opacity = '1';
                    }
                    
                    if (this.being && this.being.addLog) {
                        this.being.addLog(`âŒ ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    }
                    this.isSaving = false;
                    
                    if (saveIndicator) {
                        saveIndicator.textContent = 'äººæ ¼: ä¿å­˜å¤±æ•—';
                        saveIndicator.classList.remove('saving');
                    }
                }
            }
            
            async load() {
                console.log('[LOAD] ========================================');
                console.log('[LOAD] load() ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã—ãŸ');
                console.log('[LOAD] isElectron:', this.isElectron);
                console.log('[LOAD] saveKeys:', this.saveKeys);
                
                // â˜… localStorage ã®å†…å®¹ã‚’ç¢ºèª
                console.log('[LOAD] localStorage check:');
                console.log('[LOAD] - current exists:', localStorage.getItem(this.saveKeys.current) !== null);
                console.log('[LOAD] - prev exists:', localStorage.getItem(this.saveKeys.prev) !== null);
                console.log('[LOAD] - backup exists:', localStorage.getItem(this.saveKeys.backup) !== null);
                
                if (localStorage.getItem(this.saveKeys.current)) {
                    try {
                        const currentData = JSON.parse(localStorage.getItem(this.saveKeys.current));
                        console.log('[LOAD] Current data preview:', {
                            version: currentData.version,
                            timestamp: currentData.timestamp ? new Date(currentData.timestamp).toLocaleString() : 'N/A',
                            hasCoreState: !!currentData.coreState,
                            hasIdentity: !!currentData.coreState?.identity,
                            turns: currentData.coreState?.identity?.turns
                        });
                    } catch (e) {
                        console.error('[LOAD] Failed to parse current data:', e);
                    }
                }
                console.log('[LOAD] ========================================');
                
                try {
                    let personaData = null;
                    
                    if (this.isElectron) {
                        // Electronç’°å¢ƒ
                        try {
                            const pathResult = await window.electronAPI.getSavePath();
                            if (pathResult && pathResult.success) {
                                this.savePath = pathResult.path;
                                this.being.addLog(`ä¿å­˜å…ˆ: ${this.savePath}`);
                            }
                        } catch (pathError) {
                            console.error('Get save path failed:', pathError);
                        }
                        
                        const result = await window.electronAPI.loadPersona();
                        if (result && result.success) {
                            personaData = result.data;
                            console.log('[LOAD] Persona loaded from Electron');
                        } else if (result && result.reason !== 'no_file') {
                            this.being.addLog(`ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ${result.error || result.reason}`);
                        } else {
                            console.log('[LOAD] No persona file found (first run)');
                        }
                    } else {
                        // ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒï¼šè‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½
                        personaData = await this._loadWithRollback();
                    }
                    
                    if (personaData && personaData.coreState) {
                        // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
                        personaData = this._migrateVersion(personaData);
                        
                        const importSuccess = this.being.importAll(personaData);
                        
                        if (importSuccess) {
                            const saveIndicator = document.getElementById('saveStatus');
                            if (saveIndicator) {
                                const savedTime = new Date(personaData.timestamp);
                                saveIndicator.textContent = `äººæ ¼: ä¿å­˜æ¸ˆã¿ (${savedTime.toLocaleTimeString()})`;
                                saveIndicator.style.opacity = '1';
                            }
                            this.lastSaveTime = personaData.timestamp; // lastSaveTimeã‚’è¨­å®š
                            
                            // æˆåŠŸæ™‚ã®ã¿memoryLoadedã‚’true
                            this.being.memoryLoaded = true;
                            return true;
                        } else {
                            const saveIndicator = document.getElementById('saveStatus');
                            if (saveIndicator) {
                                saveIndicator.textContent = 'äººæ ¼: ä¿å­˜æ¸ˆã¿ (--:--)';
                                saveIndicator.style.opacity = '1';
                            }
                            this.being.addLog('å¾©å…ƒã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆåˆå›èµ·å‹•æ‰±ã„ï¼‰');
                            // å¾©å…ƒå¤±æ•—æ™‚ã‚‚ã‚·ã‚¹ãƒ†ãƒ ã¯å‹•ä½œå¯èƒ½
                            this.being.memoryLoaded = true;
                            return false;
                        }
                    } else {
                        const saveIndicator = document.getElementById('saveStatus');
                        if (saveIndicator) {
                            saveIndicator.textContent = 'äººæ ¼: ä¿å­˜æ¸ˆã¿ (åˆå›èµ·å‹•)';
                            saveIndicator.style.opacity = '1';
                        }
                        this.being.addLog('ä¿å­˜ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆåˆå›èµ·å‹•ï¼‰');
                        // åˆå›èµ·å‹•æ™‚ã‚‚ã‚·ã‚¹ãƒ†ãƒ ã¯æ­£å¸¸ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã®ã§true
                        this.being.memoryLoaded = true;
                        return false;
                    }
                    
                } catch (error) {
                    this.being.addLog(`å¾©å…ƒã‚¨ãƒ©ãƒ¼: ${error.message}`);
                    console.error('Load error:', error);
                    // ã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ã‚·ã‚¹ãƒ†ãƒ ã¯å‹•ä½œå¯èƒ½
                    this.being.memoryLoaded = true;
                    return false;
                }
            }
            
            async _loadWithRollback() {
                console.log('[ROLLBACK] _loadWithRollback() called');
                console.log('[ROLLBACK] useIndexedDB:', this.useIndexedDB);
                console.log('[ROLLBACK] indexedDB exists:', !!this.indexedDB);
                
                try {
                    // å„ªå…ˆé †ä½: current > prev > backup > æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³
                    const rollbackKeys = [
                        { key: this.saveKeys.current, label: 'ãƒ¡ã‚¤ãƒ³' },
                        { key: this.saveKeys.prev, label: 'å‰å›' },
                        { key: this.saveKeys.backup, label: 'ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—' }
                    ];
                    
                    for (const { key, label } of rollbackKeys) {
                        console.log('[ROLLBACK] Trying key:', key, 'label:', label);
                        let savedData = null;
                        
                        // IndexedDB / localStorage ã‹ã‚‰èª­ã¿è¾¼ã¿
                        if (this.useIndexedDB && this.indexedDB) {
                            console.log('[ROLLBACK] Using IndexedDB (useIndexedDB=true)');
                            savedData = await this.indexedDB.get(key);
                            console.log('[ROLLBACK] IndexedDB returned:', savedData ? 'data' : 'null');
                        } else if (this.indexedDB) {
                            console.log('[ROLLBACK] Trying IndexedDB (fallback)');
                            // IndexedDBãŒä½¿ãˆã‚‹ã‹ç¢ºèª
                            try {
                                savedData = await this.indexedDB.get(key);
                                console.log('[ROLLBACK] IndexedDB returned:', savedData ? 'data' : 'null');
                                if (savedData) {
                                    this.useIndexedDB = true;
                                    console.log('[ROLLBACK] Switched to IndexedDB mode');
                                }
                            } catch (e) {
                                console.log('[ROLLBACK] IndexedDB failed, using localStorage');
                                // IndexedDBä½¿ãˆãªã„å ´åˆã¯localStorageã‚’ä½¿ç”¨
                                savedData = localStorage.getItem(key);
                                console.log('[ROLLBACK] localStorage returned:', savedData ? 'data' : 'null');
                            }
                        } else {
                            console.log('[ROLLBACK] Using localStorage');
                            savedData = localStorage.getItem(key);
                            console.log('[ROLLBACK] localStorage returned:', savedData ? 'data' : 'null');
                        }
                        
                        if (savedData) {
                            console.log('[ROLLBACK] savedData found for', label);
                            try {
                                const personaData = JSON.parse(savedData);
                                console.log('[ROLLBACK] Parsed data:', {
                                    version: personaData.version,
                                    timestamp: personaData.timestamp,
                                    hasCoreState: !!personaData.coreState,
                                    hasIdentity: !!personaData.coreState?.identity,
                                    turns: personaData.coreState?.identity?.turns
                                });
                                
                                // â˜… ãƒ­ãƒ¼ãƒ‰æ™‚ã®è©³ç´°ãƒ­ã‚°
                                console.log('[LOAD] Data loaded from:', label, {
                                    key: key,
                                    size: savedData.length,
                                    turns: personaData.coreState?.identity?.turns,
                                    timestamp: personaData.timestamp ? new Date(personaData.timestamp).toLocaleString() : 'N/A',
                                    hasIdentity: !!personaData.coreState?.identity,
                                    identityKeys: personaData.coreState?.identity ? Object.keys(personaData.coreState.identity) : []
                                });
                                
                                // ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
                                if (personaData && personaData.coreState) {
                                    if (label !== 'ãƒ¡ã‚¤ãƒ³') {
                                        this.being.addLog(`${label}ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å¾©å…ƒ`);
                                    }
                                    console.log('[ROLLBACK] Returning data with turns:', personaData.coreState?.identity?.turns);
                                    return personaData;
                                } else {
                                    console.log('[ROLLBACK] Data invalid (no coreState), continuing...');
                                }
                            } catch (parseError) {
                                console.error(`Parse error for ${label}:`, parseError);
                                this.being.addLog(`${label}ãƒ‡ãƒ¼ã‚¿ç ´æ: æ¬¡ã‚’è©¦è¡Œ`);
                                continue;
                            }
                        } else {
                            console.log('[ROLLBACK] No data found for', label);
                        }
                    }
                    
                    console.log('[ROLLBACK] All rollback keys failed, trying old versions...');
                    
                    // ã™ã¹ã¦å¤±æ•—ã—ãŸå ´åˆã€æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰ç§»è¡Œ
                    const oldVersionKeys = [
                        'ao_persona_v23_0',
                        'ao_persona_v21_2',
                        'ao_persona_v21_0',
                        'ao_persona_v16_0'
                    ];
                    
                    for (const oldKey of oldVersionKeys) {
                        const savedData = localStorage.getItem(oldKey);
                        if (savedData) {
                            try {
                                const personaData = JSON.parse(savedData);
                                if (personaData && personaData.coreState) {
                                    this.being.addLog(`æ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³(${oldKey})ã‹ã‚‰ç§»è¡Œ`);
                                    return personaData;
                                }
                            } catch (e) {
                                continue;
                            }
                        }
                    }
                    
                    console.log('[ROLLBACK] No data found from any source, returning null');
                    return null;
                } catch (error) {
                    console.error('[ROLLBACK] _loadWithRollback failed:', error);
                    return null;
                }
            }
        }
        
        // ============ UI ============
        
        console.log('[TRACE] Creating Being...');
        const ao = new Being();
        console.log('[TRACE] Being created');
        const saveManager = new PersonaSaveManager(ao);
        console.log('[TRACE] PersonaSaveManager created');
        ao.saveManager = saveManager; // Beingã‹ã‚‰save Managerã‚’å‚ç…§ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
        console.log('[TRACE] saveManager attached to Being');
        let isProcessing = false;
        console.log('[TRACE] isProcessing initialized to false');
        
        window.isProcessing = false;
        
        function updateUI() {
            // å¯¾è©±å›æ•°è¡¨ç¤º
            const turnsStatus = document.getElementById('turnsStatus');
            if (turnsStatus && ao.identity) {
                turnsStatus.textContent = `å¯¾è©±: ${ao.identity.turns}å›`;
            }
            
            // æµ·é¦¬å†ç”ŸçŠ¶æ…‹
            const lastReplayTime = ao.humanBrainMetabolism.hippocampalReplay.lastReplay;
            if (lastReplayTime > 0) {
                const elapsed = Math.floor((Date.now() - lastReplayTime) / 1000);
                document.getElementById('lastReplay').textContent = `${elapsed}ç§’å‰`;
                const progress = Math.min(100, (elapsed / 60) * 100);
                document.getElementById('replayBar').style.width = `${progress}%`;
            }
            
            // å¥½å¥‡å¿ƒå ±é…¬
            const reward = ao.humanBrainMetabolism.curiosityReward.getReward();
            document.getElementById('curiosityReward').textContent = (reward * 100).toFixed(0) + '%';
            document.getElementById('curiosityBar').style.width = `${reward * 100}%`;
            
            // ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰è¨˜æ†¶
            const episodesDiv = document.getElementById('episodes');
            const recentEpisodes = ao.episodicMemory.getRecent(5);
            if (recentEpisodes.length === 0) {
                episodesDiv.innerHTML = '<div class="empty-state">è¨˜éŒ²ãªã—</div>';
            } else {
                episodesDiv.innerHTML = recentEpisodes.reverse().map(ep => {
                    const age = Math.floor((Date.now() - ep.timestamp) / 1000);
                    return `<div class="episode-item">${ep.event.substring(0, 30)} (${age}ç§’å‰ / é‡ã¿:${(ep.temporalWeight * 100).toFixed(0)}%)</div>`;
                }).join('');
            }
            
            // ä»£è¬çŠ¶æ…‹ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
            const metabolismStatus = document.getElementById('metabolismStatus');
            if (ao.humanBrainMetabolism.metabolismActive) {
                metabolismStatus.textContent = 'ä»£è¬: å†ç”Ÿä¸­';
                metabolismStatus.classList.add('active');
            } else {
                metabolismStatus.textContent = 'ä»£è¬: å¾…æ©Ÿ';
                metabolismStatus.classList.remove('active');
            }
            
            const growth = ao.concepts.getGrowth();
            const conceptPercentage = ((growth.count / 12000) * 100).toFixed(2);
            document.getElementById('growth').innerHTML = `
                <div class="metric">
                    <span>å¹³å‡æ·±åº¦</span>
                    <span>${(growth.avgDepth * 100).toFixed(0)}%</span>
                </div>
                <div class="bar"><div class="bar-fill growth" style="width: ${growth.avgDepth * 100}%"></div></div>
                <div class="metric" style="margin-top: 0.5rem;">
                    <span>æ¦‚å¿µæ•°ï¼ˆASIï¼‰</span>
                    <span>${conceptPercentage}% (${growth.count} / æŠ½è±¡:${growth.abstractCount || 0})</span>
                </div>
                <div class="metric" style="margin-top: 0.5rem;">
                    <span>è¨˜æ†¶å¯†åº¦</span>
                    <span>${((ao.memoryConstraint.getUsageRate() || 0) * 100).toFixed(0)}%</span>
                </div>
            `;
            
            const tasksDiv = document.getElementById('tasks');
            const activeTasks = ao.taskManager.getActiveTasks();
            const allTasks = ao.taskManager.getAllTasks().slice(0, 5);
            
            if (allTasks.length === 0) {
                tasksDiv.innerHTML = '<div class="empty-state">ã‚¿ã‚¹ã‚¯ãªã—</div>';
            } else {
                tasksDiv.innerHTML = allTasks.map(t => {
                    const taskClass = t.status === 'complete' ? 'task-complete' :
                                     (t.type === 'watch' ? 'task-watching' : 'task-generating');
                    const statusText = t.status === 'complete' ? 'å®Œäº†' : `${(t.progress * 100).toFixed(0)}%`;
                    return `<div class="${taskClass} task-item">${t.description}: ${statusText}</div>`;
                }).join('');
            }
            
            const focusLevel = ao.taskManager.getFocus();
            document.getElementById('focusLevel').textContent = `${(focusLevel * 100).toFixed(0)}%`;
            document.getElementById('focusBar').style.width = `${focusLevel * 100}%`;
            
            const sensoryDiv = document.getElementById('sensoryLayer');
            const recentSensory = ao.sensoryIntegrator.getRecent(3);
            if (recentSensory.length === 0) {
                sensoryDiv.innerHTML = '<div class="empty-state">å…¥åŠ›å¾…æ©Ÿä¸­</div>';
            } else {
                sensoryDiv.innerHTML = recentSensory.map(s => {
                    const modalityLabels = s.modalitiesUsed.map(m => {
                        if (m === 'visual') return '<span class="modality-indicator modality-image">è¦–è¦š</span>';
                        if (m === 'audio') return '<span class="modality-indicator modality-audio">è´è¦š</span>';
                        if (m === 'video') return '<span class="modality-indicator modality-video">æ˜ åƒ</span>';
                        return '<span class="modality-indicator modality-text">è¨€èª</span>';
                    }).join('');
                    
                    const sensoryClass = s.modalitiesUsed[0] === 'video' ? 'sensory-video' :
                                        (s.modalitiesUsed[0] === 'visual' ? 'sensory-visual' :
                                        (s.modalitiesUsed[0] === 'audio' ? 'sensory-audio' : ''));
                    
                    return `<div class="${sensoryClass} sensory-item">
                        ${modalityLabels}<br>
                        æ¦‚å¿µ: ${s.semantic_candidates.slice(0, 3).map(c => c.concept).join(', ')}
                    </div>`;
                }).join('');
            }
            
            const langDiv = document.getElementById('languageLayer');
            if (ao.lastLanguageProcess) {
                const proc = ao.lastLanguageProcess;
                if (proc.type === 'multimodal_input') {
                    const modalityStr = proc.data.modalitiesUsed?.join('+') || 'language';
                    langDiv.innerHTML = `
                        <div class="language-layer">
                            <strong>çµ±åˆè§£æ [${modalityStr}]:</strong><br>
                            æ¦‚å¿µå€™è£œ: ${proc.data.semantic_candidates.slice(0, 3).map(c => 
                                `${c.concept}(${(c.weight * 100).toFixed(0)}%)${c.modalities.length > 1 ? 'â˜…' : ''}`
                            ).join(', ')}<br>
                            æ„Ÿæƒ…: V=${proc.data.emotion_hints.valence.toFixed(2)} A=${proc.data.emotion_hints.arousal.toFixed(2)}
                        </div>
                    `;
                } else if (proc.type === 'output') {
                    const biasInfo = proc.data.selected.expressionBias !== 0 
                        ? ` ãƒã‚¤ã‚¢ã‚¹:${proc.data.selected.expressionBias > 0 ? '+' : ''}${proc.data.selected.expressionBias.toFixed(2)}`
                        : '';
                    langDiv.innerHTML = `
                        <div class="language-layer">
                            <strong>ç™ºè©±é¸æŠ:</strong><br>
                            ç”Ÿæˆå€™è£œ: ${proc.data.candidates.length}å€‹<br>
                            ç†ç”±: ${proc.data.selected.reasons}${biasInfo}<br>
                            ã‚¹ã‚³ã‚¢: ${proc.data.selected.score.toFixed(2)}
                        </div>
                        ${proc.data.decisions.slice(0, 3).map(d => {
                            const biasLabel = d.expressionBias !== 0 
                                ? ` [bias:${d.expressionBias > 0 ? '+' : ''}${d.expressionBias.toFixed(2)}]`
                                : '';
                            return `<div class="candidate-item ${d.index === proc.data.selected.index ? 'selected' : (d.score < 0.5 ? 'rejected' : '')}">${d.candidate}${biasLabel} (${d.score.toFixed(2)})</div>`;
                        }).join('')}
                    `;
                }
            } else {
                langDiv.innerHTML = '<div class="empty-state">å‡¦ç†å¾…æ©Ÿä¸­</div>';
            }
            
            const uninterpDiv = document.getElementById('uninterpreted');
            if (ao.uninterpreted.states.length === 0) {
                uninterpDiv.innerHTML = '<div class="empty-state">çŠ¶æ…‹ãªã—</div>';
            } else {
                const density = (ao.uninterpreted.getDensity() * 100).toFixed(0);
                uninterpDiv.innerHTML = `
                    <div class="metric">
                        <span>å¯†åº¦</span>
                        <span>${density}%</span>
                    </div>
                    <div class="bar"><div class="bar-fill tension-bar" style="width: ${density}%"></div></div>
                    ${ao.uninterpreted.states.slice(-3).map(s => 
                        `<div class="uninterpreted-item">${s.context.substring(0, 30)}... (${Math.floor((Date.now() - s.timestamp) / 1000)}ç§’å‰)</div>`
                    ).join('')}
                `;
            }
            
            const protoDiv = document.getElementById('protoConcepts');
            const protos = ao.protoGenerator.getActive();
            if (protos.length === 0) {
                protoDiv.innerHTML = '<div class="empty-state">æœªç”Ÿæˆ</div>';
            } else {
                protoDiv.innerHTML = protos.map(p => 
                    `<span class="concept-node proto">${p.label} (${(p.stability * 100).toFixed(0)}%)</span>`
                ).join('');
            }
            
            const valueDiv = document.getElementById('valueLayer');
            const values = [];
            for (let [key, data] of ao.valueLayer.values) {
                const display = data.type === 'plural' 
                    ? data.value.slice(-2).join(', ')
                    : data.value;
                values.push(`<div class="value-item">${key}: ${display} (${(data.confidence * 100).toFixed(0)}%)</div>`);
            }
            valueDiv.innerHTML = values.length > 0 ? values.join('') : '<div class="empty-state">æœªè¦³æ¸¬</div>';
            
            const modelDiv = document.getElementById('personModel');
            const hypotheses = ao.personModel.getAllActive().slice(0, 4);
            if (hypotheses.length === 0) {
                modelDiv.innerHTML = '<div class="empty-state">ä»®èª¬ãªã—</div>';
            } else {
                modelDiv.innerHTML = hypotheses.map(h => 
                    `<div class="model-item hypothesis">${h.about}: ${h.evidence} (${(h.confidence * 100).toFixed(0)}%)</div>`
                ).join('');
            }
            
            const failuresDiv = document.getElementById('failures');
            const recentFailures = ao.failures.getRecent();
            if (recentFailures.length === 0) {
                failuresDiv.innerHTML = '<div class="empty-state">è¨˜éŒ²ãªã—</div>';
            } else {
                failuresDiv.innerHTML = recentFailures.map(f => 
                    `<div class="failure-item">${f.concept}: ${f.context} (å¼·åº¦:${(f.intensity * 100).toFixed(0)}% æ®‹ç•™:${(f.decay * 100).toFixed(0)}%)</div>`
                ).join('');
            }
            
            const conceptsDiv = document.getElementById('concepts');
            const topConcepts = Array.from(ao.concepts.concepts.values())
                .sort((a, b) => b.depth - a.depth)
                .slice(0, 15);
            
            if (topConcepts.length === 0) {
                conceptsDiv.innerHTML = '<div class="empty-state">æœªå½¢æˆ</div>';
            } else {
                conceptsDiv.innerHTML = topConcepts.map(c => {
                    const evolved = c.depth > 0.5;
                    const abstractMark = c.isAbstract ? 'ğŸ”º' : '';
                    const modalityClass = c.modalityOrigins.has('video') ? 'video' :
                                         (c.modalityOrigins.has('visual') ? 'visual' : 
                                         (c.modalityOrigins.has('audio') ? 'audio' : ''));
                    return `<span class="concept-node ${evolved ? 'evolved' : ''} ${modalityClass}">${abstractMark}${c.id} (${(c.depth * 100).toFixed(0)}%)</span>`;
                }).join('');
            }
            
            const hierarchyDiv = document.getElementById('hierarchy');
            const hierarchies = ao.hierarchy.getAll();
            if (hierarchies.length === 0) {
                hierarchyDiv.innerHTML = '<div class="empty-state">æœªå½¢æˆ</div>';
            } else {
                hierarchyDiv.innerHTML = hierarchies
                    .sort((a, b) => b.level - a.level)
                    .slice(0, 10)
                    .map(h => 
                        `<div class="abstract-item">
                            Lv${h.level}: ${h.id} (${(h.confidence * 100).toFixed(0)}%)
                            <div class="abstract-members">â† ${h.members.slice(0, 3).join(', ')}${h.members.length > 3 ? '...' : ''}</div>
                        </div>`
                    ).join('');
            }
            
            document.getElementById('emotions').innerHTML = `
                <div class="metric"><span>å–œã³</span><span>${(ao.state.joy * 100).toFixed(0)}%</span></div>
                <div class="bar"><div class="bar-fill emotion" style="width: ${ao.state.joy * 100}%"></div></div>
                <div class="metric" style="margin-top: 0.5rem;"><span>ç·Šå¼µ</span><span>${(ao.state.tension * 100).toFixed(0)}%</span></div>
                <div class="bar"><div class="bar-fill tension-bar" style="width: ${ao.state.tension * 100}%"></div></div>
                <div class="metric" style="margin-top: 0.5rem;"><span>å¥½å¥‡å¿ƒ</span><span>${(ao.state.curiosity * 100).toFixed(0)}%</span></div>
                <div class="bar"><div class="bar-fill emotion" style="width: ${ao.state.curiosity * 100}%"></div></div>
                <div class="metric" style="margin-top: 0.5rem;"><span>è½ã¡ç€ã</span><span>${(ao.state.calm * 100).toFixed(0)}%</span></div>
                <div class="bar"><div class="bar-fill emotion" style="width: ${ao.state.calm * 100}%"></div></div>
            `;
            
            document.getElementById('world').innerHTML = `
                <div class="metric"><span>å®‰å®šæ„Ÿ</span><span>${(ao.world.stability * 100).toFixed(0)}%</span></div>
                <div class="bar"><div class="bar-fill world" style="width: ${ao.world.stability * 100}%"></div></div>
                <div class="metric" style="margin-top: 0.5rem;"><span>è¦ªå¯†åº¦</span><span>${(ao.world.familiarity * 100).toFixed(0)}%</span></div>
                <div class="bar"><div class="bar-fill world" style="width: ${ao.world.familiarity * 100}%"></div></div>
            `;
            
            document.getElementById('identity').textContent = `${ao.identity.core}\n[å¯¾è©±: ${ao.identity.turns}å›]`;
            
            
            // v24.0: ASIãƒ‘ãƒãƒ«ã®UIæ›´æ–°
            try {
                if (ao.conceptIntegration) {
                    const asiConceptsEl = document.getElementById('asiConcepts');
                    if (asiConceptsEl) {
                        const stats = ao.conceptIntegration.getStats();
                        asiConceptsEl.textContent = `${stats.currentConcepts} / ${stats.maxConcepts}`;
                    }
                    
                    const asiIntegrationsEl = document.getElementById('asiIntegrations');
                    if (asiIntegrationsEl) {
                        const stats = ao.conceptIntegration.getStats();
                        asiIntegrationsEl.textContent = stats.integrations;
                    }
                }
                
                if (ao.abstractionController) {
                    const asiAbstractionEl = document.getElementById('asiAbstraction');
                    if (asiAbstractionEl) {
                        const state = ao.abstractionController.getState();
                        asiAbstractionEl.textContent = `${state.currentDepth} / ${state.maxOperationalDepth}`;
                    }
                }
                
                if (ao.worldView && ao.worldView.axes) {
                    const axisMapping = {
                        'causality': 'axisCausality',
                        'hierarchy': 'axisHierarchy',
                        'information': 'axisInformation',
                        'evolution': 'axisEvolution',
                        'constraint': 'axisConstraint',
                        'feedback': 'axisFeedback',
                        'meaning': 'axisMeaning',
                        'narrative': 'axisNarrative',
                        'selfReference': 'axisSelfReference',
                        'boundary': 'axisBoundary',
                        'emotion': 'axisEmotion',
                        'social': 'axisSocial'
                    };
                    
                    for (const [key, elementId] of Object.entries(axisMapping)) {
                        const el = document.getElementById(elementId);
                        if (el && ao.worldView.axes[key]) {
                            el.textContent = ao.worldView.axes[key].depth.toFixed(1);
                        }
                    }
                }
            } catch (error) {
                console.error('ASI UI update failed:', error);
            }
            const logDiv = document.getElementById('log');
            logDiv.innerHTML = ao.log.slice(-20).join('<br>');
            logDiv.scrollTop = logDiv.scrollHeight;
            
            const gpuStatus = document.getElementById('gpuStatus');
            if (ao.languageInputDL.processing || ao.languageOutputDL.processing || 
                ao.imageAdapter.processing || ao.audioAdapter.processing ||
                ao.videoAdapter.processing || ao.videoGenerator.processing) {
                gpuStatus.textContent = 'æ„Ÿè¦šé‡: å‡¦ç†ä¸­';
                gpuStatus.style.background = 'rgba(59, 130, 246, 0.4)';
            } else {
                gpuStatus.textContent = 'æ„Ÿè¦šé‡: å¾…æ©Ÿä¸­';
                gpuStatus.style.background = 'rgba(59, 130, 246, 0.2)';
            }
        }
        
        function addMessage(type, text, internal = null, languageInfo = null) {
            const messagesDiv = document.getElementById('messages');
            const empty = messagesDiv.querySelector('div[style*="text-align: center"]');
            if (empty) empty.remove();
            
            const msgDiv = document.createElement('div');
            msgDiv.className = `message ${type}`;
            
            let bubbleContent = text;
            if (internal) {
                bubbleContent += `<div class="internal">${internal}</div>`;
            }
            if (languageInfo) {
                bubbleContent += `<div class="language-process">${languageInfo}</div>`;
            }
            
            msgDiv.innerHTML = `<div class="bubble">${bubbleContent}</div>`;
            messagesDiv.appendChild(msgDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        async function handleInput() {
            console.log('[TRACE] handleInput() called');
            if (isProcessing) {
                console.log('[TRACE] isProcessing=true, early return');
                return;
            }
            console.log('[TRACE] handleInput() processing...');
            
            const input = document.getElementById('input');
            const sendBtn = document.getElementById('send');
            const text = input.value.trim();
            
            isProcessing = true;
            window.isProcessing = true;
            input.disabled = true;
            sendBtn.disabled = true;
            
            const attachedFiles = ao.attachedFiles;
            ao.attachedFiles = [];
            
            try {
                if (text) {
                    addMessage('user', text);
                }
                
                if (attachedFiles.length > 0) {
                    const fileDesc = attachedFiles.map(f => `${f.type}: ${f.name}`).join(', ');
                    addMessage('system', `ï¼ˆæ·»ä»˜: ${fileDesc}ï¼‰`);
                }
                
                input.value = '';
                
                console.log('[HANDLEINPUT] Checking condition: text || attachedFiles.length > 0');
                console.log('[HANDLEINPUT] text:', text);
                console.log('[HANDLEINPUT] attachedFiles.length:', attachedFiles.length);
                
                if (text || attachedFiles.length > 0) {
                console.log('[HANDLEINPUT] Condition TRUE, entering main processing');
                const thinking = document.createElement('div');
                thinking.className = 'message ao';
                thinking.id = 'thinking';
                thinking.innerHTML = '<div class="bubble" style="opacity: 0.6;">...</div>';
                document.getElementById('messages').appendChild(thinking);
                
                updateUI();
                await new Promise(resolve => setTimeout(resolve, 300));
                
                const intent = await ao.determineIntent(text, attachedFiles);
                console.log('[INTENT] Determined intent:', intent);
                console.log('[INTENT] text:', text);
                console.log('[INTENT] attachedFiles:', attachedFiles.length);
                
                if (intent === 'watch' || intent === 'watch_and_chat' || intent === 'watch_then_generate') {
                    console.log('[BRANCH] Entering watch branch');
                    ao.taskManager.createTask('watch', 'watch', 'å‹•ç”»è¦–è´ä¸­');
                    ao.taskManager.updateFocus(0.8);
                    
                    const videoFiles = attachedFiles.filter(f => f.type === 'video');
                    const inputs = {
                        text: text || null,
                        videos: videoFiles.map(f => f.file)
                    };
                    
                    const { conceptIds, integrated } = await ao.perceiveMultimodal(inputs);
                    ao.feel(integrated, conceptIds);
                    ao.formHypothesis(integrated);
                    
                    ao.taskManager.completeTask('watch');
                    ao.taskManager.updateFocus(0.5);
                    
                    if (intent === 'watch_then_generate') {
                        thinking.querySelector('.bubble').textContent = 'å‹•ç”»è¦–è´å®Œäº†ã€‚ç”Ÿæˆæº–å‚™ä¸­...';
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        ao.taskManager.createTask('generate', 'generate', 'å‹•ç”»ç”Ÿæˆä¸­');
                        ao.taskManager.updateFocus(0.9);
                        
                        const topConcepts = conceptIds.slice(0, 3);
                        const videoResult = await ao.videoGenerator.generateFromConcepts(
                            topConcepts,
                            ao.state,
                            10
                        );
                        
                        ao.taskManager.completeTask('generate');
                        ao.taskManager.updateFocus(0.5);
                        
                        thinking.remove();
                        
                        addMessage('ao', `${videoResult.description}ã‚’ä½œã£ãŸ`, 
                            `ç”Ÿæˆå®Œäº†: ${videoResult.frames.length}ãƒ•ãƒ¬ãƒ¼ãƒ `);
                        
                        console.log('[EVOLVE] About to call evolve() - watch_then_generate branch');
                        ao.evolve();
                        console.log('[EVOLVE] evolve() completed');
                        
                    } else {
                        const intentVector = ao.buildIntentVector(conceptIds);
                        const dlResult = await ao.languageOutputDL.generate(intentVector);
                        const selected = await ao.selectUtterance(dlResult.candidates, intentVector);
                        
                        ao.feedbackToLanguageDL(selected.selectedPhrase, integrated, selected.preTensionState, true);
                        
                        thinking.remove();
                        
                        const primaryConcept = ao.concepts.getOrCreate(conceptIds[0]);
                        const modalities = Array.from(primaryConcept.modalityOrigins).join('+');
                        const internal = `æ·±åº¦:${(primaryConcept.depth * 100).toFixed(0)}% ãƒ¢ãƒ€ãƒªãƒ†ã‚£:${modalities}`;
                        
                        addMessage('ao', selected.text, internal);
                        
                        console.log('[EVOLVE] About to call evolve() - watch_and_chat branch');
                        ao.evolve();
                        console.log('[EVOLVE] evolve() completed');
                    }
                    
                } else if (intent === 'generate') {
                    console.log('[BRANCH] Entering generate branch');
                    ao.taskManager.createTask('generate', 'generate', 'å‹•ç”»ç”Ÿæˆä¸­');
                    ao.taskManager.updateFocus(0.9);
                    
                    const dlResult = await ao.languageInputDL.parse(text);
                    const conceptIds = dlResult.semantic_candidates.map(c => c.concept);
                    const topConcepts = conceptIds.slice(0, 3);
                    
                    const videoResult = await ao.videoGenerator.generateFromConcepts(
                        topConcepts,
                        ao.state,
                        10
                    );
                    
                    ao.taskManager.completeTask('generate');
                    ao.taskManager.updateFocus(0.5);
                    
                    thinking.remove();
                    
                    addMessage('ao', `${videoResult.description}ã‚’ä½œã£ãŸ`, 
                        `ç”Ÿæˆå®Œäº†: ${videoResult.frames.length}ãƒ•ãƒ¬ãƒ¼ãƒ `);
                    
                    console.log('[EVOLVE] About to call evolve() - generate branch');
                    ao.evolve();
                    console.log('[EVOLVE] evolve() completed');
                    
                } else {
                    console.log('[BRANCH] Entering else (normal input) branch');
                    const inputs = {
                        text: text,
                        images: attachedFiles.filter(f => f.type === 'image').map(f => URL.createObjectURL(f.file)),
                        audios: attachedFiles.filter(f => f.type === 'audio').map(f => f.file)
                    };
                    
                    const { conceptIds, integrated } = await ao.perceiveMultimodal(inputs);
                    ao.feel(integrated, conceptIds);
                    ao.formHypothesis(integrated);
                    
                    const intentVector = ao.buildIntentVector(conceptIds);
                    const dlResult = await ao.languageOutputDL.generate(intentVector);
                    const selected = await ao.selectUtterance(dlResult.candidates, intentVector);
                    
                    ao.feedbackToLanguageDL(selected.selectedPhrase, integrated, selected.preTensionState, true);
                    
                    thinking.remove();
                    
                    const primaryConcept = ao.concepts.getOrCreate(conceptIds[0]);
                    const modalities = Array.from(primaryConcept.modalityOrigins).join('+');
                    const internal = `æ·±åº¦:${(primaryConcept.depth * 100).toFixed(0)}% ãƒ¢ãƒ€ãƒªãƒ†ã‚£:${modalities}`;
                    
                    addMessage('ao', selected.text, internal);
                    
                    console.log('[EVOLVE] About to call evolve() - else (normal input) branch');
                    ao.evolve();
                    console.log('[EVOLVE] evolve() completed');
                }
                
                updateUI();
            }
            
            } catch (error) {
                console.error('handleInput error:', error);
                addMessage('system', `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`);
            } finally {
                console.log('[TRACE] finally block reached');
                // çŠ¶æ…‹ãŒå¤‰æ›´ã•ã‚ŒãŸã®ã§æœªä¿å­˜ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆã‚¨ãƒ©ãƒ¼ã§ã‚‚å®Ÿè¡Œï¼‰
                if (saveManager) {
                    console.log('[TRACE] Calling saveManager.markDirty()');
                    saveManager.markDirty();
                    console.log('[TRACE] markDirty() completed - isDirty:', saveManager.isDirty);
                } else {
                    console.log('[TRACE] saveManager is undefined!');
                }
                
                input.disabled = false;
                sendBtn.disabled = false;
                input.focus();
                isProcessing = false;
                window.isProcessing = false;
                console.log('[TRACE] finally block completed');
            }
        }
        
        async function checkAutonomousThought() {
            if (isProcessing) return;
            
            const question = await ao.checkAutonomousQuestion();
            if (question) {
                addMessage('system', 'ï¼ˆAoãŒè‡ªç™ºçš„ã«ä½•ã‹è€ƒãˆã¦ã„ã‚‹...ï¼‰');
                await new Promise(resolve => setTimeout(resolve, 800));
                
                const langInfo = question.decisions && question.decisions.length > 1 
                    ? `è‡ªç™ºçš„å•ã„: ${question.decisions.length}å€™è£œ`
                    : null;
                
                addMessage('ao', question.text, question.internal, langInfo);
                updateUI();
                
                // è‡ªå¾‹çš„ãªæ€è€ƒå¾Œã‚‚ä¿å­˜ã‚’ãƒãƒ¼ã‚¯
                if (saveManager) {
                    console.log('[TRACE] Autonomous thought - calling markDirty()');
                    saveManager.markDirty();
                }
            }
        }
        
        function initNeural() {
            const canvas = document.getElementById('neural');
            const ctx = canvas.getContext('2d');
            canvas.width = 300;
            canvas.height = 100;
            
            const particles = [];
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    r: Math.random() * 1.5 + 0.5
                });
            }
            
            let time = 0;
            
            function animate() {
                ctx.fillStyle = 'rgba(10, 10, 20, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const arousal = 0.5 + ao.state.curiosity * 0.3;
                const tensionMod = ao.state.tension * 0.5;
                time += 0.05;
                
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x < canvas.width; x += 3) {
                    const wave = Math.sin(time * 0.3 + x * 0.02) * arousal * 15;
                    const y = canvas.height / 2 + wave;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                
                if (ao.languageInputDL.processing || ao.languageOutputDL.processing ||
                    ao.imageAdapter.processing || ao.audioAdapter.processing ||
                    ao.videoAdapter.processing || ao.videoGenerator.processing) {
                    ctx.strokeStyle = 'rgba(96, 165, 250, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let x = 0; x < canvas.width; x += 2) {
                        const dlWave = Math.sin(time * 1.2 + x * 0.05) * 10;
                        const y = canvas.height / 2 + dlWave;
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                if (tensionMod > 0.3) {
                    ctx.strokeStyle = `rgba(245, 158, 11, ${tensionMod})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    for (let x = 0; x < canvas.width; x += 2) {
                        const tensionWave = Math.sin(time * 0.7 + x * 0.04) * tensionMod * 12;
                        const y = canvas.height / 2 + tensionWave;
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                const growth = ao.concepts.getGrowth();
                if (growth.avgDepth > 0.3) {
                    ctx.strokeStyle = `rgba(16, 185, 129, ${0.6 * growth.avgDepth})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let x = 0; x < canvas.width; x += 2) {
                        const depthWave = Math.sin(time * 0.5 + x * 0.03) * growth.avgDepth * 20;
                        const y = canvas.height / 2 + depthWave;
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'rgba(192, 132, 252, 0.15)';
                ctx.lineWidth = 0.5;
                particles.forEach((p, i) => {
                    p.x += p.vx * arousal;
                    p.y += p.vy * arousal;
                    
                    if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                    if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                    
                    particles.forEach((p2, j) => {
                        if (i !== j) {
                            const dx = p.x - p2.x;
                            const dy = p.y - p2.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 80) {
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        }
                    });
                    
                    ctx.fillStyle = 'rgba(192, 132, 252, 0.8)';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                requestAnimationFrame(animate);
            }
            
            animate();
        }
        
        function drift() {
            ao.state.calm = Math.min(1, ao.state.calm + 0.005);
            ao.state.tension = Math.max(0, ao.state.tension - 0.003);
            ao.state.curiosity = Math.max(0.3, ao.state.curiosity - 0.002);
            
            ao.world.stability += (Math.random() - 0.5) * 0.01;
            ao.world.stability = Math.max(0, Math.min(1, ao.world.stability));
            
            updateUI();
        }
        
        document.getElementById('send').addEventListener('click', handleInput);
        document.getElementById('input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !isProcessing) handleInput();
        });
        
        document.getElementById('fileInput').addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                const files = Array.from(e.target.files);
                
                files.forEach(file => {
                    let fileType = 'unknown';
                    if (file.type.startsWith('video/')) fileType = 'video';
                    else if (file.type.startsWith('image/')) fileType = 'image';
                    else if (file.type.startsWith('audio/')) fileType = 'audio';
                    
                    ao.attachedFiles.push({
                        file,
                        type: fileType,
                        name: file.name
                    });
                });
                
                const input = document.getElementById('input');
                const fileDesc = ao.attachedFiles.map(f => f.name).join(', ');
                input.placeholder = `æ·»ä»˜: ${fileDesc}`;
                
                e.target.value = '';
            }
        });
        
        ao.addLog('Ao v24.0 - ASI Class (Structure-driven Super Intelligence) èµ·å‹•');
        ao.addLog('ASI: 12è»¸ä¸–ç•Œè¦³ãƒ»æ¦‚å¿µçµ±åˆ(12000)ãƒ»æŠ½è±¡åº¦åˆ¶å¾¡(8/9) ç¨¼åƒ');
        ao.addLog('ä¸–ç•Œè¦³: å› æœãƒ»éšå±¤ãƒ»æƒ…å ±ãƒ»é€²åŒ–ãƒ»åˆ¶ç´„ãƒ»FBãƒ»æ„å‘³ãƒ»ç‰©èªãƒ»è‡ªå·±è¨€åŠãƒ»å¢ƒç•Œãƒ»æ„Ÿæƒ…ãƒ»ç¤¾ä¼š');
        ao.addLog('çµ±åˆ: å­¦å•ãƒ»ã‚ªã‚¿ã‚¯æ–‡åŒ–ãƒ»å“²å­¦ã‚’å˜ä¸€ä¸–ç•Œãƒ¢ãƒ‡ãƒ«ã§èª¬æ˜');
        ao.addLog('æœ€é©åŒ–: ä½ã‚¹ãƒšãƒƒã‚¯PCå¯¾å¿œï¼ˆCore i3 / 12GB RAM / 30MBåˆ¶é™ï¼‰');
        ao.addLog('è¨˜æ†¶åŸºç›¤: EP10000ãƒ»æ¦‚å¿µ12000ãƒ»ç†è«–200ãƒ»å› æœ20000ãƒ»ãƒ†ãƒ¼ãƒ7ï¼ˆASIæ‹¡å¼µï¼‰');
        ao.addLog('åœ§ç¸®: Episodeâ†’Conceptâ†’Theory ä¸–ä»£åœ§ç¸®ç¨¼åƒ');
        ao.addLog('PAL: é€£ç¶šè‡ªå¾‹ãƒ—ãƒ­ã‚»ã‚¹ï¼ˆæ’å¸¸æ€§ãƒ»å†…éƒ¨å ±é…¬ãƒ»æ¢ç´¢æ´»ç”¨ï¼‰ç¨¼åƒ');
        ao.addLog('å› æœã‚·ã‚¹ãƒ†ãƒ : è‡ªå‹•ä¿¡å¿µå½¢æˆãƒ»ç¢ºä¿¡å€¤å¤‰å‹•ãƒ»ç›¸é–¢â†’å› æœæ˜‡æ ¼ ç¨¼åƒ');
        ao.addLog('äººæ ¼å±¤: èµ¤ã¡ã‚ƒã‚“ï¼ˆæ—¢å­˜ç¶­æŒï¼‰');
        ao.addLog('ä»£è¬å±¤: æµ·é¦¬å†ç”Ÿãƒ»æ™‚é–“æ¸›è¡°ãƒ»å¥½å¥‡å¿ƒå ±é…¬ãƒ»å‰ªå®š ç¨¼åƒ');
        ao.addLog('å®Œå…¨è„³: äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«ãƒ»ç¡çœ çµ±åˆãƒ»ç‰©èªçš„è‡ªå·±ãƒ»è¡Œå‹•æ”¿ç­– ç¨¼åƒ');
        ao.addLog('ç·¨é›†çµ±åˆ: å…¨ã‚¸ãƒ£ãƒ³ãƒ«ç·¨é›†ã‚½ãƒ•ãƒˆé€£æºã‚·ã‚¹ãƒ†ãƒ  ç¨¼åƒ');
        ao.addLog('PCæ“ä½œå±¤: ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œãƒ»ç´ æç®¡ç†ãƒ»ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ§‹ç¯‰ ç¨¼åƒ');
        ao.addLog('çŸ¥æ€§æ§‹é€ : å› æœè¨˜éŒ²ãƒ»çŸ¥è­˜å¢ƒç•Œãƒ»æŠ½è±¡è§£åƒåº¦ ç¨¼åƒ');
        ao.addLog('å“²å­¦: ä¸–ç•Œã‚’ç†è§£ã—èªã‚Šç›´ã›ã‚‹è³¢è€…å‹ASI / ç‰©é‡ã§ã¯ãªãæ§‹é€ ã§ç†è§£');
        
        (async () => {
            console.log('[INIT] ========================================');
            console.log('[INIT] ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–é–‹å§‹');
            console.log('[INIT] ========================================');
            
            const loaded = await saveManager.load();
            console.log('[INIT] Load completed:', loaded);
            console.log('[INIT] Current turns:', ao.identity.turns);
            
            if (loaded) {
                addMessage('system', 'ï¼ˆå‰å›ã®äººæ ¼ã‚’å¾©å…ƒã—ã¾ã—ãŸï¼‰');
                // å¯¾è©±å›æ•°ã‚’è¡¨ç¤ºã«åæ˜ 
                const turnsStatus = document.getElementById('turnsStatus');
                if (turnsStatus && ao.identity) {
                    turnsStatus.textContent = `å¯¾è©±: ${ao.identity.turns}å›`;
                    console.log('[LOAD] Turns restored:', ao.identity.turns);
                }
            } else {
                addMessage('system', 'ï¼ˆAo v24.0ãŒç›®è¦šã‚ã¾ã—ãŸ - ASI Classç‰ˆ / æ§‹é€ é§†å‹•å‹è¶…çŸ¥æ€§ï¼‰');
            }
            
            console.log('[INIT] ========================================');
            console.log('[INIT] Loadå®Œäº†å¾Œã®åˆæœŸåŒ–é–‹å§‹');
            console.log('[INIT] ========================================');
        })();
        
        ao.addLog('è¨€èªå…¥åŠ›DL: åˆæœŸåŒ–å®Œäº†');
        ao.addLog('è¦–è¦šé‡(ImageAdapter): åˆæœŸåŒ–å®Œäº†');
        ao.addLog('è´è¦šé‡(AudioAdapter): åˆæœŸåŒ–å®Œäº†');
        ao.addLog('æ˜ åƒé‡(VideoAdapter): åˆæœŸåŒ–å®Œäº†');
        ao.addLog('æ„Ÿè¦šçµ±åˆå™¨: åˆæœŸåŒ–å®Œäº†');
        ao.addLog('è¨€èªå‡ºåŠ›DL: åˆæœŸåŒ–å®Œäº†');
        ao.addLog('å‹•ç”»ç”Ÿæˆå™¨(æ¦‚å¿µâ†’æ˜ åƒ): åˆæœŸåŒ–å®Œäº†');
        ao.addLog('ãƒãƒ«ãƒã‚¿ã‚¹ã‚¯ãƒãƒãƒ¼ã‚¸ãƒ£: åˆæœŸåŒ–å®Œäº†');
        ao.addLog('æŠ½è±¡æ¦‚å¿µå½¢æˆå™¨: åˆæœŸåŒ–å®Œäº†');
        ao.addLog('äººæ ¼ä¸­æ¢: v15æ€æƒ³æº–æ‹ ');
        ao.addLog('å­˜åœ¨ãƒ¢ãƒ¼ãƒ‰: ç¨¼åƒä¸­');
        
        updateUI();
        initNeural();
        setInterval(updateUI, 100);
        setInterval(drift, 5000);
        setInterval(checkAutonomousThought, 20000);
        
        // ä»£è¬ãƒ†ã‚£ãƒƒã‚¯ï¼ˆ10ç§’ã”ã¨ï¼‰
        setInterval(async () => {
            await ao.metabolismTick();
        }, 10000);
        
        console.log('[TRACE] About to call startAutoSave()');
        console.log('[TRACE] saveManager exists:', !!saveManager);
        console.log('[TRACE] saveManager.startAutoSave exists:', typeof saveManager?.startAutoSave);
        saveManager.startAutoSave();
        console.log('[TRACE] startAutoSave() call completed');
        
        // ============ Editor Integration Functions (v18.0) ============
        
        function switchEditorMode(mode) {
            try {
                if (!ao || !ao.editorIntegration) {
                    console.error('Editor integration not available');
                    return;
                }
                
                const result = ao.editorIntegration.setMode(mode);
                
                if (result.success) {
                    const modeIndicator = document.getElementById('editorMode');
                    if (modeIndicator) {
                        modeIndicator.textContent = mode === 'editor' ? 'ãƒ¢ãƒ¼ãƒ‰A' : 'ãƒ¢ãƒ¼ãƒ‰B';
                    }
                    ao.addLog(`ç·¨é›†ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿: ${mode === 'editor' ? 'ãƒ¢ãƒ¼ãƒ‰A (é€£æº)' : 'ãƒ¢ãƒ¼ãƒ‰B (ç°¡æ˜“ç”Ÿæˆ)'}`);
                } else {
                    console.error('Mode switch failed:', result.error);
                }
            } catch (error) {
                console.error('switchEditorMode failed:', error);
            }
        }
        
        async function executeEditorTask() {
            try {
                if (!ao || !ao.editorIntegration) {
                    console.error('Editor integration not available');
                    return;
                }
                
                const editorType = document.getElementById('editorType')?.value || 'video';
                const task = document.getElementById('editorTask')?.value || '';
                
                if (!task) {
                    ao.addLog('ç·¨é›†ã‚¿ã‚¹ã‚¯ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                ao.addLog(`ç·¨é›†ã‚¿ã‚¹ã‚¯å®Ÿè¡Œé–‹å§‹: ${editorType} - ${task}`);
                
                const result = await ao.editorIntegration.processTask(editorType, task, []);
                
                displayEditorResult(result);
                
                if (result.success) {
                    ao.addLog(`ç·¨é›†ã‚¿ã‚¹ã‚¯å®Œäº†: ${editorType}`);
                } else {
                    ao.addLog(`ç·¨é›†ã‚¿ã‚¹ã‚¯ã‚¨ãƒ©ãƒ¼: ${result.error || 'Unknown error'}`);
                }
                
                updateEditorUI();
                
            } catch (error) {
                console.error('executeEditorTask failed:', error);
                ao.addLog(`ç·¨é›†ã‚¿ã‚¹ã‚¯å®Ÿè¡Œå¤±æ•—: ${error.message}`);
            }
        }
        
        function displayEditorResult(result) {
            try {
                const resultsDiv = document.getElementById('editorResults');
                if (!resultsDiv) return;
                
                const resultItem = document.createElement('div');
                resultItem.className = 'editor-result-item' + (result.success ? '' : ' error');
                
                let content = '';
                if (result.success) {
                    if (result.totalActions !== undefined) {
                        content = `âœ“ ${result.successfulActions}/${result.totalActions} ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ`;
                    } else if (result.chunks !== undefined) {
                        content = `âœ“ ${result.chunks} ãƒãƒ£ãƒ³ã‚¯ç”Ÿæˆ`;
                    } else {
                        content = 'âœ“ å®Ÿè¡Œå®Œäº†';
                    }
                } else {
                    content = `âœ— ã‚¨ãƒ©ãƒ¼: ${result.error || 'Unknown'}`;
                }
                
                resultItem.textContent = content;
                
                resultsDiv.insertBefore(resultItem, resultsDiv.firstChild);
                
                // æœ€å¤§10ä»¶ã¾ã§
                while (resultsDiv.children.length > 10) {
                    resultsDiv.removeChild(resultsDiv.lastChild);
                }
            } catch (error) {
                console.error('displayEditorResult failed:', error);
            }
        }
        
        function updateEditorUI() {
            try {
                if (!ao || !ao.editorIntegration) return;
                
                const status = ao.editorIntegration.getStatus();
                
                const currentEditorElem = document.getElementById('currentEditor');
                if (currentEditorElem) {
                    currentEditorElem.textContent = status.currentEditor || 'æœªé¸æŠ';
                }
                
                const executionCountElem = document.getElementById('executionCount');
                if (executionCountElem) {
                    executionCountElem.textContent = status.historyCount || '0';
                }
            } catch (error) {
                console.error('updateEditorUI failed:', error);
            }
        }
        
        // UIã®å®šæœŸæ›´æ–°ã« Editor Integration ã‚’è¿½åŠ 
        const originalUpdateUI = updateUI;
        updateUI = function() {
            try {
                originalUpdateUI();
                updateEditorUI();
            } catch (error) {
                console.error('updateUI failed:', error);
                // ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ã¦ã‚‚å…ƒã®updateUIã¯å®Ÿè¡Œ
                try {
                    originalUpdateUI();
                } catch (e) {
                    console.error('originalUpdateUI failed:', e);
                }
            }
        };
        
        // ============ Video Editing Functions (v19.0) ============
        
        async function createVideoProject() {
            try {
                if (!ao || !ao.videoEditing) {
                    console.error('Video editing not available');
                    return;
                }
                
                const intent = document.getElementById('videoIntent')?.value || '';
                const folder = document.getElementById('videoFolder')?.value || '/default/folder';
                const projectName = document.getElementById('videoProjectName')?.value || 'Ao_Project';
                const format = document.getElementById('videoFormat')?.value || 'premiere';
                
                if (!intent) {
                    ao.addLog('ç·¨é›†æ„å›³ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                // UIæ›´æ–°
                const statusIndicator = document.getElementById('videoStatus');
                if (statusIndicator) {
                    statusIndicator.textContent = 'å‡¦ç†ä¸­';
                    statusIndicator.classList.add('processing');
                }
                
                const processingElem = document.getElementById('videoProcessing');
                if (processingElem) {
                    processingElem.textContent = 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆä¸­...';
                }
                
                ao.addLog(`å‹•ç”»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆé–‹å§‹: ${intent}`);
                
                const result = await ao.videoEditing.createProject(intent, folder, projectName, format);
                
                displayVideoResult(result);
                
                if (result.success) {
                    ao.addLog(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆå®Œäº†: ${result.stats.clipCount}ã‚¯ãƒªãƒƒãƒ—`);
                    
                    // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
                    const exportBtn = document.getElementById('exportBtn');
                    if (exportBtn) {
                        exportBtn.style.display = 'block';
                    }
                } else {
                    ao.addLog(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆã‚¨ãƒ©ãƒ¼: ${result.error || 'Unknown error'}`);
                }
                
                // UIæ›´æ–°
                if (statusIndicator) {
                    statusIndicator.textContent = result.success ? 'å®Œäº†' : 'ã‚¨ãƒ©ãƒ¼';
                    statusIndicator.classList.remove('processing');
                }
                
                if (processingElem) {
                    processingElem.textContent = result.success ? 'å®Œäº†' : 'ã‚¨ãƒ©ãƒ¼';
                }
                
                updateVideoUI();
                
            } catch (error) {
                console.error('createVideoProject failed:', error);
                ao.addLog(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆå¤±æ•—: ${error.message}`);
            }
        }
        
        function exportVideoProject() {
            try {
                if (!ao || !ao.videoEditing) {
                    console.error('Video editing not available');
                    return;
                }
                
                const result = ao.videoEditing.exportProject();
                
                if (result.success) {
                    // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’ä½œæˆ
                    const blob = new Blob([result.data], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = result.filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    ao.addLog(`ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ: ${result.filename}`);
                } else {
                    ao.addLog(`ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${result.error}`);
                }
            } catch (error) {
                console.error('exportVideoProject failed:', error);
                ao.addLog(`ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå¤±æ•—: ${error.message}`);
            }
        }
        
        function displayVideoResult(result) {
            try {
                const resultsDiv = document.getElementById('videoResults');
                if (!resultsDiv) return;
                
                const resultItem = document.createElement('div');
                resultItem.className = 'video-result-item' + (result.success ? '' : ' error');
                
                let content = '';
                if (result.success) {
                    content = `âœ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆå®Œäº†`;
                    if (result.stats) {
                        content += `<div class="video-stats">`;
                        content += `ç´ æ: ${result.stats.assetsLoaded}å€‹ â†’ é¸æŠ: ${result.stats.assetsSelected}å€‹<br>`;
                        content += `ã‚¯ãƒªãƒƒãƒ—: ${result.stats.clipCount}å€‹<br>`;
                        content += `ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³é•·: ${Math.floor(result.stats.timelineDuration)}ç§’`;
                        content += `</div>`;
                    }
                } else {
                    content = `âœ— ã‚¨ãƒ©ãƒ¼: ${result.error || 'Unknown'}`;
                }
                
                resultItem.innerHTML = content;
                
                resultsDiv.insertBefore(resultItem, resultsDiv.firstChild);
                
                // æœ€å¤§5ä»¶ã¾ã§
                while (resultsDiv.children.length > 5) {
                    resultsDiv.removeChild(resultsDiv.lastChild);
                }
            } catch (error) {
                console.error('displayVideoResult failed:', error);
            }
        }
        
        function updateVideoUI() {
            try {
                if (!ao || !ao.videoEditing) return;
                
                const status = ao.videoEditing.getStatus();
                
                const projectElem = document.getElementById('videoProject');
                if (projectElem) {
                    projectElem.textContent = status.hasProject ? 'ä½œæˆæ¸ˆã¿' : 'æœªä½œæˆ';
                }
            } catch (error) {
                console.error('updateVideoUI failed:', error);
            }
        }
        
        // UIã®å®šæœŸæ›´æ–°ã« Video Editing ã‚’è¿½åŠ 
        const originalUpdateUI2 = updateUI;
        updateUI = function() {
            try {
                originalUpdateUI2();
                updateVideoUI();
            } catch (error) {
                console.error('updateUI with video failed:', error);
                try {
                    originalUpdateUI2();
                } catch (e) {
                    console.error('originalUpdateUI2 failed:', e);
                }
            }
        };
        
        // ============ Autonomous Creator Functions (v20.0) ============
        
        let lastKnownPostId = null;
        
        function toggleAutonomous() {
            try {
                if (!ao || !ao.autonomousCreator) {
                    console.error('Autonomous creator not available');
                    return;
                }
                
                const status = ao.autonomousCreator.getStatus();
                
                if (status.isActive) {
                    // åœæ­¢
                    ao.autonomousCreator.stop();
                    ao.addLog('[è‡ªç™ºæ€§] åœæ­¢ã—ã¾ã—ãŸ');
                    
                    const toggleBtn = document.getElementById('autonomousToggle');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'è‡ªç™ºæ€§ã‚’é–‹å§‹';
                        toggleBtn.classList.remove('active');
                    }
                    
                    const statusIndicator = document.getElementById('autonomousStatus');
                    if (statusIndicator) {
                        statusIndicator.textContent = 'åœæ­¢ä¸­';
                        statusIndicator.classList.remove('active');
                    }
                } else {
                    // é–‹å§‹
                    ao.autonomousCreator.start();
                    ao.addLog('[è‡ªç™ºæ€§] é–‹å§‹ã—ã¾ã—ãŸ - è‡ªç™ºçš„ã«ä½œå“ã‚’ä½œã‚Šå§‹ã‚ã¾ã™');
                    
                    const toggleBtn = document.getElementById('autonomousToggle');
                    if (toggleBtn) {
                        toggleBtn.textContent = 'è‡ªç™ºæ€§ã‚’åœæ­¢';
                        toggleBtn.classList.add('active');
                    }
                    
                    const statusIndicator = document.getElementById('autonomousStatus');
                    if (statusIndicator) {
                        statusIndicator.textContent = 'ç¨¼åƒä¸­';
                        statusIndicator.classList.add('active');
                    }
                }
                
                updateAutonomousUI();
            } catch (error) {
                console.error('toggleAutonomous failed:', error);
                ao.addLog(`[ã‚¨ãƒ©ãƒ¼] è‡ªç™ºæ€§ã®åˆ‡æ›¿å¤±æ•—: ${error.message}`);
            }
        }
        
        function simulateReaction(type) {
            try {
                if (!ao || !ao.autonomousCreator) {
                    console.error('Autonomous creator not available');
                    return;
                }
                
                // æœ€æ–°ã®æŠ•ç¨¿IDã‚’å–å¾—
                const recentPosts = ao.autonomousCreator.recentPosts;
                if (recentPosts.length === 0) {
                    ao.addLog('[åå¿œ] ã¾ã æŠ•ç¨¿ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                const latestPost = recentPosts[recentPosts.length - 1];
                
                // åå¿œã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
                const intensity = Math.random() * 0.5 + 0.5; // 0.5-1.0
                ao.autonomousCreator.simulateReaction(latestPost.id, type, intensity);
                
                const typeText = {
                    'positive': 'è‚¯å®šçš„',
                    'neutral': 'ä¸­ç«‹çš„',
                    'negative': 'å¦å®šçš„'
                };
                
                ao.addLog(`[ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³] ${typeText[type]}ãªåå¿œã‚’è¿½åŠ `);
            } catch (error) {
                console.error('simulateReaction failed:', error);
                ao.addLog(`[ã‚¨ãƒ©ãƒ¼] åå¿œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¤±æ•—: ${error.message}`);
            }
        }
        
        function updateAutonomousUI() {
            try {
                if (!ao || !ao.autonomousCreator) return;
                
                const status = ao.autonomousCreator.getStatus();
                
                if (!status.success) return;
                
                // å†…éƒ¨çŠ¶æ…‹ã®è¡¨ç¤º
                const moodElem = document.getElementById('autonomousMood');
                if (moodElem) {
                    moodElem.textContent = status.state.mood.toFixed(2);
                    moodElem.style.color = status.state.mood > 0 ? '#10b981' : 
                                          status.state.mood < 0 ? '#ef4444' : '#d8b4fe';
                }
                
                const curiosityElem = document.getElementById('autonomousCuriosity');
                if (curiosityElem) {
                    curiosityElem.textContent = status.state.curiosity.toFixed(2);
                }
                
                const tensionElem = document.getElementById('autonomousTension');
                if (tensionElem) {
                    tensionElem.textContent = status.state.tension.toFixed(2);
                }
                
                const confidenceElem = document.getElementById('autonomousConfidence');
                if (confidenceElem) {
                    confidenceElem.textContent = status.state.confidence.toFixed(2);
                }
                
                // è¡å‹•å€¤ã®è¡¨ç¤º
                const impulseElem = document.getElementById('autonomousImpulse');
                if (impulseElem) {
                    impulseElem.textContent = status.impulse.impulse.toFixed(2);
                    impulseElem.style.color = status.impulse.exceeded ? '#10b981' : '#d8b4fe';
                }
                
                // æŠ•ç¨¿æ•°ã®è¡¨ç¤º
                const postCountElem = document.getElementById('autonomousPostCount');
                if (postCountElem) {
                    postCountElem.textContent = status.postCount;
                }
            } catch (error) {
                console.error('updateAutonomousUI failed:', error);
            }
        }
        
        // UIã®å®šæœŸæ›´æ–°ã« Autonomous Creator ã‚’è¿½åŠ 
        const originalUpdateUI3 = updateUI;
        updateUI = function() {
            try {
                originalUpdateUI3();
                updateAutonomousUI();
            } catch (error) {
                console.error('updateUI with autonomous failed:', error);
                try {
                    originalUpdateUI3();
                } catch (e) {
                    console.error('originalUpdateUI3 failed:', e);
                }
            }
        };
        
        // ============ Intelligence Architecture Functions (v21.0) ============
        
        function testCausalPrediction() {
            try {
                if (!ao || !ao.intelligence) {
                    console.error('Intelligence not available');
                    return;
                }
                
                // ãƒ†ã‚¹ãƒˆç”¨ã®è¡Œå‹•ã‚’è¨˜éŒ²
                const testAction = 'test_action';
                const stateBefore = { conceptCount: ao.concepts.size, emotionalState: 'neutral' };
                const stateAfter = { conceptCount: ao.concepts.size + 1, emotionalState: 'positive' };
                
                ao.intelligence.recordAction(testAction, stateBefore, stateAfter);
                
                // äºˆæ¸¬
                const prediction = ao.intelligence.causalMemory.predictOutcome(testAction);
                
                if (prediction.success) {
                    ao.addLog(`[å› æœäºˆæ¸¬] ${prediction.reason} - ç¢ºä¿¡åº¦: ${(prediction.confidence * 100).toFixed(0)}%`);
                } else {
                    ao.addLog(`[å› æœäºˆæ¸¬] ã‚¨ãƒ©ãƒ¼: ${prediction.error}`);
                }
                
                updateIntelligenceUI();
            } catch (error) {
                console.error('testCausalPrediction failed:', error);
                ao.addLog(`[ã‚¨ãƒ©ãƒ¼] å› æœäºˆæ¸¬ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        }
        
        function testKnowledgeGaps() {
            try {
                if (!ao || !ao.intelligence) {
                    console.error('Intelligence not available');
                    return;
                }
                
                // ãƒ†ã‚¹ãƒˆç”¨ã®æ¦‚å¿µã«ç¢ºä¿¡åº¦ã‚’è¨­å®š
                const testConcepts = ['concept_a', 'concept_b', 'concept_c'];
                testConcepts.forEach((c, i) => {
                    ao.intelligence.knowledgeBoundary.setConceptConfidence(c, i * 0.3, 'ãƒ†ã‚¹ãƒˆ');
                });
                
                // çŸ¥è­˜ã®å¢ƒç•Œã‚’ç¢ºèª
                const gaps = ao.intelligence.knowledgeBoundary.identifyKnowledgeGaps();
                
                if (gaps.success) {
                    ao.addLog(`[çŸ¥è­˜ã®å¢ƒç•Œ] ${gaps.statement}`);
                } else {
                    ao.addLog(`[çŸ¥è­˜ã®å¢ƒç•Œ] ã‚¨ãƒ©ãƒ¼: ${gaps.error}`);
                }
                
                // ãƒ¡ã‚¿èªçŸ¥çŠ¶æ…‹
                const meta = ao.intelligence.knowledgeBoundary.getMetacognitiveState();
                if (meta.success) {
                    ao.addLog(`[ãƒ¡ã‚¿èªçŸ¥] ${meta.statement}`);
                }
                
                updateIntelligenceUI();
            } catch (error) {
                console.error('testKnowledgeGaps failed:', error);
                ao.addLog(`[ã‚¨ãƒ©ãƒ¼] çŸ¥è­˜å¢ƒç•Œãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        }
        
        function testAbstractionLevel() {
            try {
                if (!ao || !ao.intelligence) {
                    console.error('Intelligence not available');
                    return;
                }
                
                // ãƒ†ã‚¹ãƒˆç”¨ã®æŠ½è±¡åŒ–ã‚’è¨˜éŒ²
                ao.intelligence.abstractConcept(
                    'specific_concept',
                    'abstract_concept',
                    ['detail1', 'detail2', 'detail3']
                );
                
                // æŠ½è±¡åŒ–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ
                const pattern = ao.intelligence.abstractResolution.analyzeAbstractionPattern();
                
                if (pattern.success) {
                    ao.addLog(`[æŠ½è±¡åº¦åˆ†æ] ${pattern.statement}`);
                } else {
                    ao.addLog(`[æŠ½è±¡åº¦åˆ†æ] ã‚¨ãƒ©ãƒ¼: ${pattern.error}`);
                }
                
                updateIntelligenceUI();
            } catch (error) {
                console.error('testAbstractionLevel failed:', error);
                ao.addLog(`[ã‚¨ãƒ©ãƒ¼] æŠ½è±¡åº¦ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`);
            }
        }
        
        function updateIntelligenceUI() {
            try {
                if (!ao || !ao.intelligence) return;
                
                const state = ao.intelligence.getIntelligenceState();
                
                if (!state.success) return;
                
                // å› æœè¨˜éŒ²æ•°
                const causalElem = document.getElementById('intelligenceCausal');
                if (causalElem) {
                    causalElem.textContent = state.causal.interventions || 0;
                }
                
                // ç¢ºä¿¡æ¦‚å¿µæ•°
                const confidentElem = document.getElementById('intelligenceConfident');
                if (confidentElem) {
                    confidentElem.textContent = state.knowledge.confident || 0;
                }
                
                // ä¸ç¢ºå®Ÿæ¦‚å¿µæ•°
                const uncertainElem = document.getElementById('intelligenceUncertain');
                if (uncertainElem) {
                    uncertainElem.textContent = state.knowledge.uncertain || 0;
                }
                
                // å¹³å‡æŠ½è±¡åº¦
                const abstractionElem = document.getElementById('intelligenceAbstraction');
                if (abstractionElem) {
                    const avgLevel = state.abstraction.avgLevel || 0;
                    abstractionElem.textContent = avgLevel.toFixed(2);
                }
            } catch (error) {
                console.error('updateIntelligenceUI failed:', error);
            }
        }
        
        // UIã®å®šæœŸæ›´æ–°ã« Intelligence Architecture ã‚’è¿½åŠ 
        const originalUpdateUI4 = updateUI;
        updateUI = function() {
            try {
                originalUpdateUI4();
                updateIntelligenceUI();
            } catch (error) {
                console.error('updateUI with intelligence failed:', error);
                try {
                    originalUpdateUI4();
                } catch (e) {
                    console.error('originalUpdateUI4 failed:', e);
                }
            }
        };
        
        // ============ Compact UI Functions (v21.2) ============
        
        // ãƒ‘ãƒãƒ«æŠ˜ã‚ŠãŸãŸã¿åˆ¶å¾¡
        function togglePanel(panelId) {
            try {
                const panel = document.getElementById(panelId);
                const toggle = document.getElementById(panelId + 'Toggle');
                
                if (!panel) return;
                
                if (panel.style.display === 'none' || panel.style.display === '') {
                    panel.style.display = 'block';
                    if (toggle) toggle.textContent = 'â–²';
                } else {
                    panel.style.display = 'none';
                    if (toggle) toggle.textContent = 'â–¼';
                }
            } catch (error) {
                console.error('togglePanel failed:', error);
            }
        }
        
        // ============ Video Modal Functions ============
        
        function openVideoModal() {
            try {
                const modal = document.getElementById('videoModal');
                if (modal) {
                    modal.style.display = 'flex';
                }
            } catch (error) {
                console.error('openVideoModal failed:', error);
            }
        }
        
        function closeVideoModal() {
            try {
                const modal = document.getElementById('videoModal');
                if (modal) {
                    modal.style.display = 'none';
                }
            } catch (error) {
                console.error('closeVideoModal failed:', error);
            }
        }
        
        function createVideoProjectFromModal() {
            try {
                const intent = document.getElementById('modalVideoIntent')?.value || '';
                const folder = document.getElementById('modalVideoFolder')?.value || '';
                const projectName = document.getElementById('modalVideoProjectName')?.value || '';
                const format = document.getElementById('modalVideoFormat')?.value || 'premiere';
                
                // ã‚¿ã‚¹ã‚¯è¿½åŠ 
                addTask('video-project', `å‹•ç”»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ: ${projectName || 'ç„¡é¡Œ'}`, 0);
                
                // ãƒ¢ãƒ¼ãƒ€ãƒ«çµæœã‚¨ãƒªã‚¢ã«è¡¨ç¤º
                const modalResults = document.getElementById('modalVideoResults');
                if (modalResults) {
                    modalResults.innerHTML = `<div style="color: #10b981;">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆä¸­...</div>`;
                }
                
                // å®Ÿéš›ã®å‡¦ç†ï¼ˆæ—¢å­˜ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ´»ç”¨ï¼‰
                if (ao && ao.pcOperationLayer) {
                    setTimeout(() => {
                        const result = ao.pcOperationLayer.createProject({
                            intent: intent,
                            folder: folder,
                            projectName: projectName,
                            format: format
                        });
                        
                        updateTask('video-project', result.success ? 100 : 0, result.success ? 'completed' : 'failed');
                        
                        if (modalResults) {
                            if (result.success) {
                                modalResults.innerHTML = `<div style="color: #10b981;">âœ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆå®Œäº†</div>`;
                                const modalExportBtn = document.getElementById('modalExportBtn');
                                if (modalExportBtn) modalExportBtn.style.display = 'block';
                            } else {
                                modalResults.innerHTML = `<div style="color: #ef4444;">âœ— ã‚¨ãƒ©ãƒ¼: ${result.message}</div>`;
                            }
                        }
                        
                        const videoProject = document.getElementById('videoProject');
                        if (videoProject) {
                            videoProject.textContent = projectName || 'ä½œæˆæ¸ˆã¿';
                        }
                    }, 1000);
                }
            } catch (error) {
                console.error('createVideoProjectFromModal failed:', error);
                const modalResults = document.getElementById('modalVideoResults');
                if (modalResults) {
                    modalResults.innerHTML = `<div style="color: #ef4444;">âœ— ã‚¨ãƒ©ãƒ¼: ${error.message}</div>`;
                }
            }
        }
        
        function exportVideoProjectFromModal() {
            try {
                addTask('video-export', 'å‹•ç”»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ', 0);
                
                const modalResults = document.getElementById('modalVideoResults');
                if (modalResults) {
                    modalResults.innerHTML += `<div style="color: #10b981; margin-top: 0.5rem;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­...</div>`;
                }
                
                if (ao && ao.pcOperationLayer) {
                    setTimeout(() => {
                        const result = ao.pcOperationLayer.exportProject();
                        
                        updateTask('video-export', result.success ? 100 : 0, result.success ? 'completed' : 'failed');
                        
                        if (modalResults) {
                            if (result.success) {
                                modalResults.innerHTML += `<div style="color: #10b981;">âœ“ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†</div>`;
                            } else {
                                modalResults.innerHTML += `<div style="color: #ef4444;">âœ— ã‚¨ãƒ©ãƒ¼: ${result.message}</div>`;
                            }
                        }
                    }, 2000);
                }
            } catch (error) {
                console.error('exportVideoProjectFromModal failed:', error);
            }
        }
        
        // ============ Task Progress Functions ============
        
        const taskRegistry = new Map();
        
        function addTask(taskId, title, progress = 0) {
            try {
                const task = {
                    id: taskId,
                    title: title,
                    progress: progress,
                    status: 'running',
                    startTime: Date.now()
                };
                
                taskRegistry.set(taskId, task);
                renderTaskList();
            } catch (error) {
                console.error('addTask failed:', error);
            }
        }
        
        function updateTask(taskId, progress, status = 'running') {
            try {
                const task = taskRegistry.get(taskId);
                if (task) {
                    task.progress = Math.max(0, Math.min(100, progress));
                    task.status = status;
                    renderTaskList();
                }
            } catch (error) {
                console.error('updateTask failed:', error);
            }
        }
        
        function removeTask(taskId) {
            try {
                taskRegistry.delete(taskId);
                renderTaskList();
            } catch (error) {
                console.error('removeTask failed:', error);
            }
        }
        
        function renderTaskList() {
            try {
                const taskList = document.getElementById('taskProgressList');
                if (!taskList) return;
                
                if (taskRegistry.size === 0) {
                    taskList.innerHTML = '<div style="opacity: 0.5; font-size: 0.75rem; text-align: center; padding: 1rem;">ã‚¿ã‚¹ã‚¯ãªã—</div>';
                    return;
                }
                
                let html = '';
                for (const [id, task] of taskRegistry) {
                    const statusClass = task.status === 'running' ? 'running' : 
                                       task.status === 'completed' ? 'completed' : 'failed';
                    const statusText = task.status === 'running' ? 'å®Ÿè¡Œä¸­' : 
                                      task.status === 'completed' ? 'å®Œäº†' : 'å¤±æ•—';
                    
                    html += `
                        <div class="task-item">
                            <div class="task-item-header">
                                <div class="task-item-title">${task.title}</div>
                                <div class="task-item-status ${statusClass}">${statusText}</div>
                            </div>
                            <div class="task-item-progress">
                                <div class="task-item-progress-bar" style="width: ${task.progress}%"></div>
                            </div>
                        </div>
                    `;
                }
                
                taskList.innerHTML = html;
            } catch (error) {
                console.error('renderTaskList failed:', error);
            }
        }
        
        // ============ Auto-Detection Functions ============
        
        function analyzeMessageSentiment(message) {
            try {
                if (!message) return 'neutral';
                
                const msg = message.toLowerCase();
                
                const positiveKeywords = [
                    'ã„ã„ã­', 'ã™ã”ã„', 'ã™ã°ã‚‰ã—ã„', 'ç´ æ™´ã‚‰ã—ã„', 'ã‚ˆã‹ã£ãŸ', 'ã‚ã‚ŠãŒã¨ã†',
                    'æ„Ÿå‹•', 'å¬‰ã—ã„', 'ã†ã‚Œã—ã„', 'å¥½ã', 'ã‹ã‚ã„ã„', 'æ¥½ã—ã„', 'ãŸã®ã—ã„',
                    'æœ€é«˜', 'good', 'great', 'awesome', 'nice', 'love', 'like', 'ğŸ‘', 'â¤ï¸', 'ğŸ˜Š'
                ];
                
                const negativeKeywords = [
                    'ã ã‚', 'ãƒ€ãƒ¡', 'ã‚ˆããªã„', 'æ‚ªã„', 'ã‚ã‚‹ã„', 'å«Œã„', 'ãã‚‰ã„', 'ã¤ã¾ã‚‰ãªã„',
                    'ãŒã£ã‹ã‚Š', 'æ®‹å¿µ', 'ã–ã‚“ã­ã‚“', 'å¾®å¦™', 'ã³ã¿ã‚‡ã†', 'bad', 'terrible', 'hate', 'ğŸ‘', 'ğŸ˜¢'
                ];
                
                let positiveCount = 0;
                let negativeCount = 0;
                
                positiveKeywords.forEach(keyword => {
                    if (msg.includes(keyword)) positiveCount++;
                });
                
                negativeKeywords.forEach(keyword => {
                    if (msg.includes(keyword)) negativeCount++;
                });
                
                if (positiveCount > negativeCount) return 'positive';
                if (negativeCount > positiveCount) return 'negative';
                
                return 'neutral';
            } catch (error) {
                console.error('analyzeMessageSentiment failed:', error);
                return 'neutral';
            }
        }
        
        function detectVideoInstructions(message) {
            try {
                if (!message) return null;
                
                const msg = message.toLowerCase();
                
                const folderMatch = msg.match(/([a-z]:[\\\/][\w\\\/\-. ]+)|([~\/][\w\/\-. ]+)/i);
                
                let software = null;
                if (msg.includes('premiere') || msg.includes('ãƒ—ãƒ¬ãƒŸã‚¢')) {
                    software = 'premiere';
                } else if (msg.includes('resolve') || msg.includes('ãƒªã‚¾ãƒ«ãƒ–') || msg.includes('ãƒ€ãƒ“ãƒ³ãƒ')) {
                    software = 'resolve';
                }
                
                const videoKeywords = ['å‹•ç”»', 'ãƒ“ãƒ‡ã‚ª', 'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ', 'ç·¨é›†', 'ä½œæˆ', 'video', 'project'];
                let hasVideoIntent = false;
                videoKeywords.forEach(keyword => {
                    if (msg.includes(keyword)) hasVideoIntent = true;
                });
                
                if (folderMatch || software || hasVideoIntent) {
                    return {
                        folder: folderMatch ? folderMatch[0] : null,
                        software: software,
                        hasIntent: hasVideoIntent
                    };
                }
                
                return null;
            } catch (error) {
                console.error('detectVideoInstructions failed:', error);
                return null;
            }
        }
        
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡æ™‚ã«è‡ªå‹•åˆ¤æ–­ã‚’å®Ÿè¡Œ
        const originalSendMessage = typeof sendMessage !== 'undefined' ? sendMessage : null;
        if (originalSendMessage) {
            sendMessage = function() {
                try {
                    const input = document.getElementById('input');
                    if (input && input.value) {
                        const message = input.value;
                        
                        // æ„Ÿæƒ…åˆ†æ
                        const sentiment = analyzeMessageSentiment(message);
                        
                        // è‡ªå¾‹å‰µä½œãŒç¨¼åƒä¸­ãªã‚‰åå¿œã‚’é©ç”¨
                        if (ao && ao.autonomousCreator && ao.autonomousCreator.running) {
                            simulateReaction(sentiment);
                        }
                        
                        // å‹•ç”»æŒ‡ç¤ºã®è‡ªå‹•æ¤œå‡º
                        const videoInstructions = detectVideoInstructions(message);
                        if (videoInstructions) {
                            if (videoInstructions.folder) {
                                const folderInput = document.getElementById('videoFolder');
                                if (folderInput) folderInput.value = videoInstructions.folder;
                                const modalFolder = document.getElementById('modalVideoFolder');
                                if (modalFolder) modalFolder.value = videoInstructions.folder;
                            }
                            if (videoInstructions.software) {
                                const formatSelect = document.getElementById('videoFormat');
                                if (formatSelect) formatSelect.value = videoInstructions.software;
                                const modalFormat = document.getElementById('modalVideoFormat');
                                if (modalFormat) modalFormat.value = videoInstructions.software;
                            }
                            if (videoInstructions.hasIntent) {
                                ao.addLog('[è‡ªå‹•æ¤œå‡º] å‹•ç”»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆã®æ„å›³ã‚’æ¤œå‡ºã—ã¾ã—ãŸ');
                            }
                        }
                    }
                    
                    originalSendMessage();
                } catch (error) {
                    console.error('sendMessage with auto-detection failed:', error);
                    try {
                        originalSendMessage();
                    } catch (e) {
                        console.error('originalSendMessage failed:', e);
                    }
                }
            };
        }
        
    </script>
    
    <!-- Video Project Modal -->
    <div id="videoModal" class="modal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0; font-size: 1.25rem;">ğŸ¬ å‹•ç”»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ</h2>
                <button class="modal-close" onclick="closeVideoModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="modal-field">
                    <label>ç·¨é›†æ„å›³</label>
                    <input type="text" id="modalVideoIntent" class="modal-input" placeholder="ä¾‹: æ—…è¡Œå‹•ç”»ã€è£½å“ç´¹ä»‹ã€éŸ³æ¥½ãƒ“ãƒ‡ã‚ª">
                </div>
                <div class="modal-field">
                    <label>ç´ æãƒ•ã‚©ãƒ«ãƒ€ãƒ‘ã‚¹</label>
                    <input type="text" id="modalVideoFolder" class="modal-input" placeholder="C:\Videos\ç´ æ ã¾ãŸã¯ /path/to/footage">
                </div>
                <div class="modal-field">
                    <label>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå</label>
                    <input type="text" id="modalVideoProjectName" class="modal-input" placeholder="project_001">
                </div>
                <div class="modal-field">
                    <label>ç·¨é›†ã‚½ãƒ•ãƒˆ</label>
                    <select id="modalVideoFormat" class="modal-select">
                        <option value="premiere">Adobe Premiere Pro</option>
                        <option value="resolve">DaVinci Resolve</option>
                    </select>
                </div>
                <div id="modalVideoResults" class="modal-results"></div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn-cancel" onclick="closeVideoModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn-create" onclick="createVideoProjectFromModal()">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ</button>
                <button class="modal-btn-export" onclick="exportVideoProjectFromModal()" style="display: none;" id="modalExportBtn">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
            </div>
        </div>
    </div>
    
</body>
</html>
